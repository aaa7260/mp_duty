---
title: "bash脚本中指定参数方法 | getopt/getopts"
date: 2023-12-22T12:22:15Z
draft: ["false"]
tags: [
  "fetched",
  "生信小知识"
]
categories: ["Acdemic"]
---
bash脚本中指定参数方法 | getopt/getopts by 生信小知识
------
<div><section><h2><span>bash脚本中指定参数方法 | getopt/getopts</span></h2><blockquote><p>微信公众号：<strong>生信小知识</strong><br>关注可了解更多的生物信息学教程及知识。问题或建议，请公众号留言;</p></blockquote><h3><span>目录</span></h3><p><span><span>前言</span></span><span><span>1. getopt命令</span></span><span><span><span>1.1 getopt命令用法说明</span></span></span><span><span><span>1.2 基础使用实例</span></span></span><span><span><span>1.3 使用长选项</span></span></span><span><span><span>1.4 配合脚本使用</span></span></span><span><span>2. getopts命令</span></span><span><span><span>2.1 getopts命令用法说明</span></span></span><span><span><span>2.2 简单使用实例</span></span></span><span><span><span>2.3 错误使用实例1 输入了没有定义的参数</span></span></span><span><span><span>2.4 错误使用实例2 缺失了必要参数</span></span></span><span><span>3. case命令补充说明</span></span><span><span><span>3.1 case命令介绍</span></span></span><span><span><span>3.2 实例</span></span></span><span><span>4. set 及 shift 命令补充说明</span></span><span><span><span>4.1 set -- 命令</span></span></span><span><span><span>4.2 shift 命令</span></span></span><span><span>后记</span></span></p><h3><span>前言</span></h3><p>在写 <code>bash</code> 脚本的时候，我们一般会使用 <code>$n</code> 的形式来获取具体的参数，例如：</p><ul><li><p><code>$0</code>：脚本名称</p></li><li><p><code>$1</code>：第1个参数</p></li><li><p><code>$2</code>：第2个参数</p></li><li><p><code>$n</code>：第n个参数</p></li><li><p><code>$@</code>：所有参数。被双引号（" "）包含时，与 <code>$*</code> 稍有不同，下面将会讲到。</p></li><li><p><code>$*</code>：所有参数</p></li><li><p><code>$#</code>：传递给脚本的参数个数</p></li></ul><blockquote><p>详见过去推文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTk0Mzg2Nw==&amp;mid=2247488088&amp;idx=1&amp;sn=7086bd8d9e793948e173b47699e57f0c&amp;scene=21#wechat_redirect" data-linktype="2">几种编程语言中获取参数的方法</a></p></blockquote><p>但是这种传递方法的坏处也很明显，就是参数的位置很固定，并且对于<strong>开关型参数难以传递</strong>。</p><p>因此今天学习下另外一种参数传递方式，可以解决上述问题。</p><h3><span>1. getopt命令</span></h3><blockquote><p>参考：</p><ul><li><p><span>https://blog.csdn.net/bjbz_cxy/article/details/124032986</span></p></li><li><p><span>https://blog.csdn.net/qq_24406903/article/details/118731808</span></p></li></ul></blockquote><p>在Linux中提供了两个命令：<code>getopt</code> 与 <code>getopts</code>。其中 <code>getopts</code> 是 <code>getopt</code> 更高阶的命令，我们先从最简单的介绍，先从 <code>getopt</code> 开始介绍。</p><h4><span>1.1 getopt命令用法说明</span></h4><p><code>getopt</code> 命令是用来解析Shell脚本命令行参数的工具，具体用法如下：</p><pre><code>NAME<br>       getopt - parse <span>command</span> options (enhanced)<br><br>SYNOPSIS<br>       getopt optstring parameters<br>       getopt [options] [--] optstring parameters<br>       getopt [options] -o|--options optstring [options] [--] parameters<br><br>OPTIONS (常用)<br>-a, --alternative                    <span># 允许长选项以单个 "-" 开始</span><br>-h, --<span>help</span>                            <span># 用法指南</span><br>-l, --longoptions &lt;longopts&gt;        <span># 要识别的长选项，不同选项名之间使用逗号分隔</span><br>-n, --name &lt;progname&gt;                <span># 将错误报告给的程序名</span><br>-o, --options &lt;shortopts&gt;            <span># 要识别的短选项</span><br>-q, --quiet                            <span># 当出现没有定义的选项时，禁止 getopt 的错误报告</span><br>-Q, --quiet-output                    <span># 不输出正常结果，但是可以输出错误结果</span><br>-s, --shell &lt;shell&gt;                    <span># 设置 shell 的格式，例如'sh' 'bash', 'csh', and 'tcsh'</span><br></code></pre><h4><span>1.2 基础使用实例</span></h4><p>下面我们在实例例子中去学习具体的使用规则。</p><pre><code>$ getopt abcd -a -b -c -d<br> -a -b -c -d --<br></code></pre><p>上面的 <code>abcd</code> 即 <code>optstring</code>，每个字母都视为一个<strong>选项</strong>，<code>getopt</code> 会拆分成：<code>-a</code>、<code>-b</code>、<code>-c</code>、<code>-d</code>。</p><p>当 <code>optstring</code> 中没有指定选项字母，而在后面的 <code>parameters</code> 待解析字符中却出现了，则会报错：</p><pre><code>$ getopt abcd -a -b -c -d -h<br>getopt: invalid option -- <span>'h'</span><br> -a -b -c -d --<br></code></pre><p>如果我们想要忽略多余的选项，而不报错，则可以使用 <code>-q</code> 选项：</p><pre><code>$ getopt -q -- abcd -a -b -c -d -h<br> -a -b -c -d --<br></code></pre><p>此外，我们也可以通过在 <code>optstring</code> 前加入一个 “<code>:</code>” 符号，来达到使用 <code>-q</code> 选项相同的效果：</p><pre><code>$ getopt -- :abcd -a -b -c -d -h<br> -a -b -c -d --<br></code></pre><p>同时，如果我们想要保留报错信息，但是在报错时，将程序名改为程序本身，那么我们可以使用 <code>-n</code> 选项：</p><pre><code>$ getopt -n get_options -- abcd -a -b -c -d -h<br>get_options: invalid option -- <span>'h'</span><br> -a -b -c -d --<br></code></pre><p>如果我们<strong>期望某个选项需要一个输入值</strong>，那么可以在这个选项的后面加上 “<code>:</code>”：</p><pre><code>$ getopt ab:<span>cd</span> -a -b this -c -d<br> -a -b this -c -d --<br></code></pre><p>可以看到 <code>b</code> 后面跟了一个 <code>:</code> 符号，<strong>这个符号的作用是代表这个选项是一个需要输入值的选项</strong>，如果不给就会报错：</p><pre><code>$ getopt ab:<span>cd</span> -b<br>getopt: option requires an argument -- <span>'b'</span><br> --<br></code></pre><p>需要注意如果你没有给这个选项一个参数的情况下后面跟了一个选项，那么这个选项会被视为参数：</p><pre><code>$ getopt ab:<span>cd</span> -b -d<br> -b -d --<br></code></pre><p>也就是说，当你这个选项被定义为需要输入参数时，<strong>它会读取这个选项空格后的一个字符串，以空格分隔作为它的输入参数</strong>。</p><p>如果你想这个选项可有输入值也可以没有输入值那么可以使用 “<code>::</code>” 符号：</p><pre><code>$ getopt ab::<span>cd</span> -b<br> -b  --<br></code></pre><p>如果我们在选项后<strong>多给了一些参数</strong>，那么这些结果会被放到 <code>--</code> 之后的最后部分：</p><pre><code>$ getopt -- ab::<span>cd</span> -b -c -d <span>test</span><br> -b <span>''</span> -c -d -- <span>'test'</span><br></code></pre><blockquote><p>其中：<code>-b</code> 后面因为可有可无参数，因此分析后给予空白符；<code>-c</code> 无需参数，因此分析后后面没有任何参数；<code>-d</code> 无需参数，但是后面却多了一个 <code>test</code> 字符，因此分析后得到有效参数 <code>-d</code>，同时将多余参数 "<code>test</code>" 放到 <code>--</code> 之后的最后部分。</p></blockquote><p>上述所有的写法都是直接标注了短选项的字母，为了好区分，我们也可以使用 <code>-o</code> 指定具体的短选项的字母：</p><pre><code>$ getopt -o ab:<span>cd</span> -- -a -b this -c -d<br> -a -b <span>'this'</span> -c -d --<br><br><span># 上述写法和不指定 -o 的写法一致：</span><br>$ getopt -- ab:<span>cd</span> -a -b this -c -d<br> -a -b <span>'this'</span> -c -d --<br></code></pre><p><strong>小结：</strong><code>optstring</code> 中包含了<strong>所有可以被脚本识别的选项字母</strong>，并且对于这些字母而言：如果后面紧跟了<strong>1个冒号</strong>【<code>:</code>】，则说明这个字母参数后面<strong>必须跟着一个具体的参数值</strong>。例如：如果在 <code>optstring</code> 中包含了 <code>a:</code>，则表示在命令行中，我们需要写成 <code>-a VALUE</code> 的形式，并将 <code>VALUE</code> 赋值给 <code>OPTARG</code> 变量。如果后面紧跟了<strong>2个冒号</strong>【<code>:</code>】，则说明字母参数后面<strong>可以有参数值，也可以没有参数值</strong>。</p><h4><span>1.3 使用长选项</span></h4><p>我们在使用工具时，常常可以看到一些长选项，例如经典的 “<code>--help</code>”，我们在 <code>getopt</code> 命令中，同样可以通过 <code>-l</code> 参数实现传递长选项的功能：</p><pre><code>$ getopt -q -l arg1,arg2,arg3 -- abcd -a -b -c --arg1 --arg2 --arg3<br> -a -b -c --arg1 --arg2 --arg3 --<br></code></pre><blockquote><p>注意：长选项是使用 "<code>,</code>" 符号分割的，并且在给选项时需要使用 "<code>--</code>"</p></blockquote><p>如果在长选项中包含需要后面连接参数时，我们可以这样写：</p><pre><code>$ getopt -o abcd -l arg1:,arg2::,arg3 -- -a -b -c --arg1 <span>test</span> --arg2 --arg3<br> -a -b -c --arg1 <span>'test'</span> --arg2 <span>''</span> --arg3 --<br></code></pre><h4><span>1.4 配合脚本使用</span></h4><p>我们先来看一个在脚本 <code>getopt.sh</code> 中使用 <code>getopt</code> 命令来分配参数的例子：</p><pre><code><span>#/bin/bash</span><br><br><span>set</span> -- $(getopt ab:c:d <span>"<span>$@</span>"</span>)<br><span>while</span> [[ -n <span>"<span>$1</span>"</span> ]]<br><span>do</span><br>    <span>case</span> <span>"<span>$1</span>"</span> <span>in</span><br>        -a) <span>echo</span> <span>"Found the -a option"</span> ;;<br>        -b) par=<span>"<span>$2</span>"</span><br>            <span>echo</span> <span>"Found the -b option, par = <span>$par</span>"</span><br>            <span>shift</span> ;;<br>        -c) par=<span>"<span>$2</span>"</span><br>            <span>echo</span> <span>"Found the -c option, par = <span>$par</span>"</span><br>            <span>shift</span> ;;<br>        -d) <span>echo</span> <span>"Found the -d option"</span> ;;<br>        --) <span>break</span> ;;<br>        *) <span>echo</span> <span>"<span>$1</span> is not option"</span> ;;<br>    <span>esac</span><br>    <span>shift</span><br><span>done</span><br><br><span>shift</span><br>count=1<br><span>for</span> param <span>in</span> <span>"<span>$@</span>"</span><br><span>do</span><br>    <span>echo</span> <span>"Parameter #<span>$count</span>: <span>$param</span>"</span><br>    count=$[ <span>$count</span> + 1 ]<br><span>done</span><br></code></pre><p>接下来我们对其进行逐行解析：</p><ol><li><p>line3：将脚本所有参数传递给 <code>getopt</code> 进行解析，并将解析后的结果以 <code>$1</code>、 <code>$2</code>、 <code>$3</code> 等格式进行传递。具体详情请查看第4部分内容：【4. set 及 shift 命令补充说明】以及 <a href="https://mp.weixin.qq.com/s?__biz=MjM5NTk0Mzg2Nw==&amp;mid=2247488088&amp;idx=1&amp;sn=7086bd8d9e793948e173b47699e57f0c&amp;scene=21#wechat_redirect" data-linktype="2">几种编程语言中获取参数的方法</a></p></li><li><p>line4-19（<code>while</code> 循环）：</p></li></ol><ul><li><p><code>[[ -n "$1" ]]</code> 判断：在line3命令中，如果有参数，则这些参数会被分配给 <code>$1</code> ，此时的判断则为真。</p></li><li><p>循环体：根据不同的选项，如 <code>-a</code>、 <code>-b</code>、 <code>-c</code> 和 <code>-d</code> 等，利用 <code>case</code> 判断匹配，并执行后面的命令。关于 <code>case</code> 命令的使用说明请查看第3部分内容：【3. case命令补充说明】</p></li><li><p>line8和line11：因为 <code>-b/-c</code> 选项后有参数，故此处将 <code>$2</code> 赋值给 <code>par</code> 变量。</p></li><li><p>line15：因为 <code>getopt</code> 命令的最后输出是 <code>--</code>，故当我们匹配到这个字符时，则可以结束提取</p></li><li><p><code>shift</code> 命令：在line10、line13和line18中，存在有 <code>shift</code> 命令，主要用于将 <code>getopt</code> 解析的结果index进行后移。具体详情请查看第4部分内容：【4. set 及 shift 命令补充说明】</p></li></ul><ol><li><p>line21：当分配完所有选项和参数后，此时指针处于 <code>getopt</code> 命令的最后输出 <code>--</code> 上，为了方便后面打印具体的结果文件，需要将指针手动后移1位</p></li><li><p><span>line22-27：用于打印解析后的文件结果</span></p></li></ol><p>接下来我们用一个实际命令行来展示下该脚本的结果：</p><pre><code>$ bash getopt.sh -a -b 123 -c 456 -d target_file.txt<br>Found the -a option<br>Found the -b option, par = 123<br>Found the -c option, par = 456<br>Found the -d option<br>Parameter <span>#1: target_file.txt</span><br></code></pre><h3><span>2. getopts命令</span></h3><h4><span>2.1 getopts命令用法说明</span></h4><p><code>getopts</code> 命令是 <code>getopt</code> 命令的升级版本，同样也是用来解析Shell脚本命令行参数的工具。但是 <code>getopts</code> 不同于 <code>getopt</code>，它没有提供那么多选项，也没有那么多种用法，它只有一种用法：</p><pre><code><span>getopts</span> optstring name [args]<br></code></pre><h4><span>2.2 简单使用实例</span></h4><p>虽然 <code>getopts</code> 命令的使用说明非常简单，但是它是专门为 <code>shell</code> 提供的，<strong>在脚本中使用时会更加简单方便</strong>。</p><p>我们通过一个简单的脚本 <code>getopts.sh</code> 来做示例：</p><pre><code><span>#!/bin/bash<br></span><br><span>while</span> <span>getopts</span> <span>"a:b::cd:ef:gh"</span> opt<br><span>do</span><br>    <span>case</span> <span>$opt</span> <span>in</span><br>        a) <span>echo</span> <span>"The argument of -a is: <span>${OPTARG}</span>"</span> ;;<br>        b) <span>echo</span> <span>"The argument of -b is: <span>${OPTARG}</span>"</span> ;;<br>        c) <span>echo</span> <span>"The argument of -c is: <span>${OPTARG}</span>"</span> ;;<br>        d) <span>echo</span> <span>"The argument of -d is: <span>${OPTARG}</span>"</span> ;;<br>        e) <span>echo</span> <span>"The argument of -e is: <span>${OPTARG}</span>"</span> ;;<br>        f) <span>echo</span> <span>"The argument of -f is: <span>${OPTARG}</span>"</span> ;;<br>        g) <span>echo</span> <span>"The argument of -g is: <span>${OPTARG}</span>"</span> ;;<br>        h) <span>echo</span> <span>"The argument of -h is: <span>${OPTARG}</span>"</span> ;;<br>        *) <span>echo</span> <span>"The argument is wrong, please check!"</span> ;;<br>    <span>esac</span><br><span>done</span><br></code></pre><blockquote><p>关于 <code>case</code> 命令的使用说明请查看第3部分内容：【3. case命令补充说明】</p></blockquote><p>在脚本中，参数会自动解析，并<strong>将选项传递给 <code>opt</code> 变量</strong>，而<strong>选项对应的参数值，则自动传递给 <code>OPTARG</code> 变量</strong>。</p><p>正常情况下，我们在命令行中输入：</p><pre><code>$ bash getopts.sh -a testA -b testB -c -d testD -e -f testF -g -h<br>The argument of -a is: testA<br>The argument of -b is: testB<br>The argument of -c is:<br>The argument of -d is: testD<br>The argument of -e is:<br>The argument of -f is: testF<br>The argument of -g is:<br>The argument of -h is:<br></code></pre><p>如果我们只输入部分参数：</p><pre><code>$ bash getopts.sh -a testA -b testB<br>The argument of -a is: testA<br>The argument of -b is: testB<br></code></pre><p>这些都符合我们的预期。</p><h4><span>2.3 错误使用实例1 输入了没有定义的参数</span></h4><p>如果我们输入了没有定义的参数：</p><pre><code>$ bash getopts.sh -a testA -t<br>The argument of -a is: testA<br>getopts.sh: illegal option -- t<br>The argument is wrong, please check!<br></code></pre><p>可以看到，我们可以同时看到2个信息：</p><ul><li><p><code>getopts.sh: illegal option -- t</code>：来自 <code>getopts</code> 命令的报错。</p></li><li><p><code>The argument is wrong, please check!</code>：来自 <code>case</code> 的匹配。</p></li></ul><p>在我们的脚本中，我们可能更希望只看到第二条信息，而不出现第一条信息，于是我们可以对脚本 <code>getopts.sh</code> 进行修改：</p><pre><code><span>#!/bin/bash<br></span><br><span>while</span> <span>getopts</span> <span>":a:b::cd:ef:gh"</span> opt<br><span>do</span><br>    <span>case</span> <span>$opt</span> <span>in</span><br>        a) <span>echo</span> <span>"The argument of -a is: <span>${OPTARG}</span>"</span> ;;<br>        b) <span>echo</span> <span>"The argument of -b is: <span>${OPTARG}</span>"</span> ;;<br>        c) <span>echo</span> <span>"The argument of -c is: <span>${OPTARG}</span>"</span> ;;<br>        d) <span>echo</span> <span>"The argument of -d is: <span>${OPTARG}</span>"</span> ;;<br>        e) <span>echo</span> <span>"The argument of -e is: <span>${OPTARG}</span>"</span> ;;<br>        f) <span>echo</span> <span>"The argument of -f is: <span>${OPTARG}</span>"</span> ;;<br>        g) <span>echo</span> <span>"The argument of -g is: <span>${OPTARG}</span>"</span> ;;<br>        h) <span>echo</span> <span>"The argument of -h is: <span>${OPTARG}</span>"</span> ;;<br>        *) <span>echo</span> <span>"The argument is wrong, please check!"</span> ;;<br>    <span>esac</span><br><span>done</span><br></code></pre><p>再次重复运行相同的代码：</p><pre><code>$ bash getopts.sh -a testA -t<br>The argument of -a is: testA<br>The argument is wrong, please check!<br></code></pre><h4><span>2.4 错误使用实例2 缺失了必要参数</span></h4><p>如果对于需要参数的选项，没有给定参数，例如：</p><pre><code>$ bash getopts.sh -a -b testB -c -d testD -e -f testF -g -h<br>The argument of -a is: -b<br></code></pre><p>可以看到，此时脚本只是把 <code>-b</code> 误当作 <code>-a</code> 的参数，而剩余所有的参数均没能解析出来，原因是：</p><pre><code>bash getopts.sh -a -b testB -c -d testD -e -f testF -g -h<br><br><span># -a -b： -a 的参数是 -b</span><br><span># test：没有 - 开头，被识别为文件，而非参数，故认为命令到此结束，故对后面的命令则不再进行分析</span><br></code></pre><p>如果我们改变下参数位置，则会识别到更多：</p><pre><code>$ bash getopts.sh -a -c -d testD -e -f testF -g -h -b testB<br>The argument of -a is: -c<br>The argument of -d is: testD<br>The argument of -e is:<br>The argument of -f is: testF<br>The argument of -g is:<br>The argument of -h is:<br>The argument of -b is: testB<br></code></pre><p>这个其实原则上属于逻辑错误，所以程序不会报错，但是实际的运行结果可能和我们想要的是不同的。</p><h3><span>3. case命令补充说明</span></h3><p>因为 <code>getopts</code> 命令常常需要联合 <code>case</code> 命令一同使用，故这里简要介绍下<code>case</code> 命令。</p><h4><span>3.1 case命令介绍</span></h4><p><code>case</code> 命令是 <code>if</code> 命令多分枝的简写模式，可以针对不同的判断结果，执行不同的命令。使用 <code>case</code> 命令可以使脚本结构更加清晰、层次分明。</p><p><code>case</code> 命令的使用格式类似：</p><pre><code><span>case</span> VALUE <span>in</span><br>    MODE1) COMMAND1 ;;<br>    MODE2) COMMAND2 ;;<br>    ... ;;<br>    *) COMMANDn<br><span>esac</span><br></code></pre><p>其中：</p><ul><li><p><code>VALUE</code>：是具体的值</p></li><li><p><code>MODE</code>：用于匹配的模式</p></li><li><p><code>COMMAND</code>：当成功匹配时运行的命令</p></li></ul><blockquote><p>按照MODE的书写顺序，找到首先匹配成功的MODE，执行后面的命令</p></blockquote><p>其中 <code>MODE</code> 遵循<code>Glob</code> 匹配规则，这里简单列举几个常用的 <code>MODE</code> 例子：</p><table width="100"><thead><tr><th>MODE</th><th>描述</th></tr></thead><tbody><tr><td>a)</td><td>如果 <code>$VALUE</code> 是a，则匹配</td></tr><tr><td>[[:alpha:]]</td><td>如果 <code>$VALUE</code> 是<strong>单个字母</strong>，则匹配</td></tr><tr><td>[[:upper:]]/[A-Z]</td><td>如果 <code>$VALUE</code> 是<strong>单个大写字母</strong>，则匹配</td></tr><tr><td>[[:lower:]]/[a-z]</td><td>如果 <code>$VALUE</code> 是<strong>单个小写字母</strong>，则匹配</td></tr><tr><td>[[:digit:]]/[0-9]</td><td>如果 <code>$VALUE</code> 是<strong>单个数字</strong>，则匹配</td></tr><tr><td>[[:alnum:]]</td><td>如果 <code>$VALUE</code> 是<strong>单个字母或数字</strong>，则匹配</td></tr><tr><td>[[:punct:]]</td><td>如果 <code>$VALUE</code> 是<strong>单个标点符号</strong>，则匹配</td></tr><tr><td>[[:space:]]</td><td>如果 <code>$VALUE</code> 是<strong>单个空格</strong>，则匹配</td></tr><tr><td>???)</td><td>如果 <code>$VALUE</code> 是<strong>3个字符</strong>，则匹配</td></tr><tr><td>*.txt)</td><td>如果 <code>$VALUE</code> 是以 <code>.txt</code> <strong>结尾</strong>，则匹配</td></tr><tr><td>*)</td><td>不管 <code>$VALUE</code> 是什么内容，<strong>均可匹配</strong>。将该模式作为case命令最后一个模式是一种不错的做法，可以匹配之前的模式无法匹配到的内容，也就是说，能捕获到所有的“漏网之鱼”</td></tr></tbody></table><blockquote><p>具体可以查看之前的笔记：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTk0Mzg2Nw==&amp;mid=2247489263&amp;idx=1&amp;sn=84b1baf0f4e65b12b316c016c295fd95&amp;scene=21#wechat_redirect" data-linktype="2">Linux中的glob规则与grep的正则表达式</a></p></blockquote><h4><span>3.2 实例</span></h4><p>我们先写一个最简单的测试命令：</p><pre><code><span>case</span> <span>"t123"</span> <span>in</span><br>    [[:alpha:]]) <span>echo</span> <span>"1"</span> ;; <br>    [a-z][0-9]?) <span>echo</span> <span>"2"</span> ;; <br>    [a-z]???) <span>echo</span> <span>"3"</span> ;; <br><span>esac</span><br></code></pre><p>运行后得到的结果如下：</p><pre><code>$ <span>case</span> <span>"t123"</span> <span>in</span><br>&gt; [[:alpha:]]) <span>echo</span> <span>"1"</span> ;;<br>&gt; [a-z][0-9]?) <span>echo</span> <span>"2"</span> ;;<br>&gt; [a-z]???) <span>echo</span> <span>"3"</span> ;;<br>&gt; <span>esac</span><br><br>3<br></code></pre><p>接下来我们再做一个更复杂点的脚本 <code>test.sh</code>，内容如下：</p><pre><code><span>#!/bin/bash</span><br>input=<span>$1</span><br><br><span>case</span> <span>${input}</span> <span>in</span><br>    a) <span>echo</span> <span>${input}</span>==<span>"a"</span> ;;<br>    [[:alpha:]]?) <span>echo</span> <span>"<span>${input}</span> match '[[:alpha:]]?' mode"</span> ;;<br>    [[:upper:]]) <span>echo</span> <span>"<span>${input}</span> match '[[:upper:]]' mode"</span> ;;<br>    [[:lower:]]) <span>echo</span> <span>"<span>${input}</span> match '[[:lower:]]' mode"</span> ;;<br>    [[:digit:]]) <span>echo</span> <span>"<span>${input}</span> match '[[:digit:]]' mode"</span> ;;<br>    [[:alnum:]][[:alnum:]]) <span>echo</span> <span>"<span>${input}</span> match '[[:alnum:]][[:alnum:]]' mode"</span> ;;<br>    [[:punct:]]) <span>echo</span> <span>"<span>${input}</span> match '[[:punct:]]' mode"</span> ;;<br>    [[:space:]]) <span>echo</span> <span>"<span>${input}</span> match '[[:space:]]' mode"</span> ;;<br>    ???) <span>echo</span> <span>"<span>${input}</span> match '???' mode"</span> ;;<br>    123*.txt) <span>echo</span> <span>"<span>${input}</span> match '123*.txt' mode"</span> ;;<br>    [ABC].[ABC].txt) <span>echo</span> <span>"<span>${input}</span> match '[ABC].[ABC].txt' mode"</span> ;;<br>    [ABC].?.txt) <span>echo</span> <span>"<span>${input}</span> match '[ABC].?.txt' mode"</span> ;;<br>    *.txt) <span>echo</span> <span>"<span>${input}</span> match '*.txt' mode"</span> ;;<br>    *) <span>echo</span> <span>"<span>${input}</span> match '*' mode"</span> ;;<br><span>esac</span><br></code></pre><p>我们然后进行测试：</p><pre><code>$ bash test.sh a_<br>a_ match <span>'[[:alpha:]]?'</span> mode<br><br>$ bash test.sh A<br>A match <span>'[[:upper:]]'</span> mode<br><br>$ bash test.sh a<br>a==a<br><br>$ bash test.sh 1<br>1 match <span>'[[:digit:]]'</span> mode<br><br>$ bash test.sh 1a<br>1a match <span>'[[:alnum:]][[:alnum:]]'</span> mode<br><br>$ bash test.sh _<br>_ match <span>'[[:punct:]]'</span> mode<br><br>$ bash test.sh <span>" "</span><br>  match <span>'[[:space:]]'</span> mode<br><br>$ bash test.sh a1-<br>a1- match <span>'???'</span> mode<br><br>$ bash test.sh A.txt<br>A.txt match <span>'*.txt'</span> mode<br><br>$ bash test.sh 123a.txt<br>123a.txt match <span>'123*.txt'</span> mode<br><br>$ bash test.sh A.A.txt<br>A.A.txt match <span>'[ABC].[ABC].txt'</span> mode<br><br>$ bash test.sh A.W.txt<br>A.W.txt match <span>'[ABC].?.txt'</span> mode<br><br>$ bash test.sh FASDFSDAF<br>FASDFSDAF match <span>'*'</span> mode<br></code></pre><h3><span>4. set 及 shift 命令补充说明</span></h3><h4><span>4.1 set -- 命令</span></h4><p><code>set -- $value1 $value2 ... $value_n</code> 是一个特殊的用法，即将 <code>$value1 $value2 ... $value_n</code> 值分别赋值给 <code>$1 $2 ... $n</code></p><p>具体可以看下面的例子：</p><pre><code>$ <span>set</span> -- 123 345<br><br>$ <span>echo</span> <span>$1</span><br>123<br><br>$ <span>echo</span> <span>$2</span><br>345<br></code></pre><h4><span>4.2 shift 命令</span></h4><p>在Linux 中的 <code>shift</code> 命令，调用一次，表示<strong>位置参数</strong>左移一位。具体是什么意思呢？</p><p>我们知道，在Linux脚本中，我们可以使用 <code>$1</code>、 <code>$2</code>、 <code>$3</code> 等来指脚本后的第1、2、3个参数。每调用 <code>shift</code> 命令一次，我们可以将 <code>$1</code> 删除，并将后面的参数向前移动1位，即：</p><ul><li><p>原始的 <code>$1</code>：被删除</p></li><li><p>原始的 <code>$2</code>：变成现在的<code>$1</code></p></li><li><p>原始的 <code>$3</code>：变成现在的<code>$2</code></p></li></ul><h3><span>后记</span></h3><p>这样来看，在使用上，<code>getopts</code> 更加简单方便，但是没有 <code>getopt</code> 那么灵活。而使用 <code>getopt</code> 的话，我们可以使用长选项。</p><p>具体使用选择上，大家根据自己的需求，灵活选择！</p></section><p><br></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/z4RWnL3jTLy-5m4mfyj2RA",target="_blank" rel="noopener noreferrer">原文链接</a>
