---
title: "单细胞数据pbmc使用cibersort反卷积的尝试"
date: 2024-07-28T21:42:11Z
draft: ["false"]
tags: [
  "fetched",
  "东林的扯淡小屋"
]
categories: ["Acdemic"]
---
单细胞数据pbmc使用cibersort反卷积的尝试 by 东林的扯淡小屋
------
<div><section><section><ul><li><li><li><li><li></ul><pre data-lang="bash"><code><span>library(Seurat)</span></code><code><span>library(patchwork)</span></code><code><span>library(SeuratData)</span></code><code><span>data(pbmc3k)</span></code><code><span>pbmc3k<span>$pct</span>.mt &lt;- PercentageFeatureSet(pbmc3k, pattern = <span>"^MT-"</span>)</span></code><code><span>FeatureScatter(pbmc3k, feature1 = <span>"nCount_RNA"</span>, feature2 = <span>"pct.mt"</span>) +</span></code><code><span>  FeatureScatter(pbmc3k, feature1 = <span>"nCount_RNA"</span>, feature2 = <span>"nFeature_RNA"</span>)</span></code><code><span>pbmc3k &lt;- subset(pbmc3k, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; pct.mt &lt; 5)</span></code><code><span>pbmc3k &lt;- NormalizeData(pbmc3k)</span></code><code><span><span>## Performing log-normalization</span></span></code><code><span><span>## 0%   10   20   30   40   50   60   70   80   90   100%</span></span></code><code><span><span>## [----|----|----|----|----|----|----|----|----|----|</span></span></code><code><span><span>## **************************************************|</span></span></code><code><span>pbmc3k &lt;- FindVariableFeatures(pbmc3k, nfeatures = 2000)</span></code><code><span><br></span></code><code><span>all.genes &lt;- rownames(pbmc3k)</span></code><code><span>pbmc3k &lt;- ScaleData(pbmc3k, features = all.genes)</span></code><code><span>pbmc3k &lt;- RunPCA(pbmc3k, features = VariableFeatures(object = pbmc3k))</span></code><code><span>pbmc3k &lt;- FindNeighbors(pbmc3k, dims = 1:10)</span></code><code><span>pbmc3k &lt;- FindClusters(pbmc3k, resolution = 0.5)</span></code><code><span>pbmc3k &lt;- RunUMAP(pbmc3k, dims = 1:10)</span></code><code><span>pbmc3k &lt;- RunTSNE(pbmc3k, dims = 1:10)</span></code><code><span><span># note that you can set `label = TRUE` or use the LabelClusters function to help label</span></span></code><code><span><span># individual clusters</span></span></code><code><span>DimPlot(pbmc3k, reduction = <span>"umap"</span>)</span></code><code><span>DimPlot(pbmc3k, reduction = <span>"tsne"</span>)</span></code><code><span>new.cluster.ids &lt;- c(<span>"Naive CD4 T"</span>, <span>"Memory CD4 T"</span>, <span>"CD14+ Mono"</span>, <span>"B"</span>, <span>"CD8 T"</span>, <span>"FCGR3A+ Mono"</span>, </span></code><code><span>                     <span>"NK"</span>, <span>"DC"</span>, <span>"Platelet"</span>)</span></code><code><span>names(new.cluster.ids) &lt;- levels(pbmc3k)</span></code><code><span>pbmc3k &lt;- RenameIdents(pbmc3k, new.cluster.ids)</span></code><code><span>DimPlot(pbmc3k, reduction = <span>"umap"</span>, label = TRUE, pt.size = 0.5) + NoLegend()</span></code><code><span><br></span></code><code><span><span>#single cell reference sample file to build a signature matrix file to use in Cibersortx.</span></span></code><code><span><br></span></code><code><span>write.table(pbmc3k@active.ident, file=<span>'Convert_UMI_Label.tsv'</span>, quote=FALSE, sep=<span>'\t'</span>, col.names = TRUE)</span></code><code><span>write.table(pbmc3k@assays[[<span>"RNA"</span>]]@counts, file=<span>'Gene_Count_per_Cell.tsv'</span>, quote=FALSE, sep=<span>'\t'</span>, col.names = TRUE)</span></code><code><span><br></span></code><code><span><br></span></code><code><span>pbmc&lt;-AverageExpression(pbmc3k)</span></code><code><span>write.table(pbmc, file=<span>'signature_matrix.txt'</span>, quote=FALSE, sep=<span>'\t'</span>, col.names = TRUE)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># 首先读取两个文件</span></span></code><code><span>sig_matrix &lt;-<span>"LM22_human.txt"</span>  <span># CIBERSORT 内置数据库挖掘</span></span></code><code><span>mixture_file &lt;- <span>"signature_matrix.txt"</span>  <span># 约80M，TCGA数据库</span></span></code><code><span><br></span></code><code><span><span># 两个表达矩阵需要取交集</span></span></code><code><span>LM22.file &lt;- sig_matrix</span></code><code><span>exp.file &lt;- mixture_file</span></code><code><span><span>#read in data</span></span></code><code><span>X &lt;- read.csv(LM22.file,row.names=1,sep=<span>"\t"</span>)</span></code><code><span>Y &lt;- read.table(exp.file, header=T, sep=<span>"\t"</span>, check.names=F)</span></code><code><span><span>#Y &lt;- Y[!duplicated(Y[,1]),]###去重复基因名</span></span></code><code><span><span>#rownames(Y)&lt;-Y[,1]</span></span></code><code><span><span>#Y&lt;-Y[,-1]</span></span></code><code><span>X &lt;- data.matrix(X)<span>###convert data as matrix</span></span></code><code><span>Y &lt;- data.matrix(Y)</span></code><code><span>Y[1:4,1:4]<span>##check data</span></span></code><code><span>X[1:4,1:4]</span></code><code><span>dim(X)</span></code><code><span>dim(Y)</span></code><code><span><br></span></code><code><span>X &lt;- X[order(rownames(X)),]<span>###行名字母排序</span></span></code><code><span>Y &lt;- Y[order(rownames(Y)),]<span>###行名字母排序</span></span></code><code><span><br></span></code><code><span><span>#anti-log if max &lt; 50 in mixture file</span></span></code><code><span><span>if</span>(max(Y) &lt; 50) {Y &lt;- 2^Y} <span>###如果Y矩阵中最大值&lt;50，则变为2的y次方，也就是原始Y是被log2的</span></span></code><code><span><br></span></code><code><span>QN = F <span>#QN = Quantile normalization of input mixture (default = TRUE)</span></span></code><code><span><span>#quantile normalization of mixture file</span></span></code><code><span><span>if</span>(QN == TRUE){</span></code><code><span>  tmpc &lt;- colnames(Y)</span></code><code><span>  tmpr &lt;- rownames(Y)</span></code><code><span>  Y &lt;- normalize.quantiles(Y)<span>#preprocessCore的函数，正态化数据</span></span></code><code><span>  colnames(Y) &lt;- tmpc</span></code><code><span>  rownames(Y) &lt;- tmpr</span></code><code><span>}</span></code><code><span><br></span></code><code><span><span>#intersect genes</span></span></code><code><span>Xgns &lt;- row.names(X)</span></code><code><span>Ygns &lt;- row.names(Y)</span></code><code><span>YintX &lt;- Ygns %<span>in</span>% Xgns <span>###y中取x</span></span></code><code><span>Y &lt;- Y[YintX,] <span>###取共有子集</span></span></code><code><span>XintY &lt;- Xgns %<span>in</span>% row.names(Y)<span>###x中取y</span></span></code><code><span>X &lt;- X[XintY,]</span></code><code><span>dim(X)</span></code><code><span>dim(Y)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>#standardize sig matrix</span></span></code><code><span>X &lt;- (X - mean(X)) / sd(as.vector(X)) <span>###标准化数据</span></span></code><code><span>Y[1:4,1:4]</span></code><code><span>X[1:4,1:4]</span></code><code><span>boxplot(X[,1:4])</span></code><code><span>save(X,Y,file = <span>'input.Rdata'</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>rm(list = ls())</span></code><code><span>options(stringsAsFactors = F)</span></code><code><span>load(file = <span>'input.Rdata'</span>)</span></code><code><span>Y[1:4,1:4]</span></code><code><span>X[1:4,1:4]</span></code><code><span>dim(X)</span></code><code><span>dim(Y)</span></code><code><span><span># 下面的演示是为了搞清楚 CoreAlg 函数</span></span></code><code><span><span># 并不需要保存任何信息</span></span></code><code><span><br></span></code><code><span><span># 从表达矩阵Y里面，随机挑选LM22矩阵基因数量的表达量值</span></span></code><code><span>Ylist &lt;- as.list(data.matrix(Y)) <span>###将Y矩阵中每一个数值作为list的一个元素</span></span></code><code><span>yr &lt;- as.numeric(Ylist[ sample(length(Ylist),dim(X)[1]) ])<span>###从Ylist随机挑选nrow（x）个元素</span></span></code><code><span><span># yr 这个时候是一个假设的样本</span></span></code><code><span><span>#standardize mixture,就是scale 函数</span></span></code><code><span>yr &lt;- (yr - mean(yr)) / sd(yr) <span>##标准化样本</span></span></code><code><span>boxplot(yr)</span></code><code><span><span># 每次随机挑选的yr，都是需要走后面的流程</span></span></code><code><span><br></span></code><code><span><span># 一切都是默认值的支持向量机</span></span></code><code><span><span># 这里的X是LM22矩阵，不同的免疫细胞比例组合成为不同的yr</span></span></code><code><span><span># 这里的yr是随机的，反推免疫细胞比例</span></span></code><code><span>library(e1071)</span></code><code><span>out=svm(X,yr)<span>##e1071包的函数</span></span></code><code><span>out</span></code><code><span>out<span>$SV</span> <span>##SV=支持向量</span></span></code><code><span><br></span></code><code><span><span># 需要修改的参数包括：type="nu-regression",kernel="linear",nu=nus,scale=F</span></span></code><code><span><span>###参数含义，采用nu-regression,nu回归，采用线性方法从训练数据中学习得到模型，nu参数为nus值，不scale</span></span></code><code><span><span>###SVM参数https://stats.stackexchange.com/questions/94118/difference-between-ep-svr-and-nu-svr-and-least-squares-svr</span></span></code><code><span><span>###https://blog.csdn.net/csqazwsxedc/article/details/52230092</span></span></code><code><span><br></span></code><code><span>svn_itor &lt;- 3</span></code><code><span><br></span></code><code><span>y=yr</span></code><code><span><span>#try different values of nu</span></span></code><code><span>res &lt;- <span>function</span>(i){</span></code><code><span>  <span>if</span>(i==1){nus &lt;- 0.25}</span></code><code><span>  <span>if</span>(i==2){nus &lt;- 0.5}</span></code><code><span>  <span>if</span>(i==3){nus &lt;- 0.75}</span></code><code><span>  model&lt;-svm(X,y,<span>type</span>=<span>"nu-regression"</span>,kernel=<span>"linear"</span>,nu=nus,scale=F)</span></code><code><span>  model</span></code><code><span>}</span></code><code><span><br></span></code><code><span><span>#Execute In a parallel way the SVM</span></span></code><code><span><span>####Windows没有办法用mclapply开多核的，可以用parlapply</span></span></code><code><span>library(parallel)</span></code><code><span><br></span></code><code><span><span>if</span>(Sys.info()[<span>'sysname'</span>] == <span>'Windows'</span>) {</span></code><code><span>  </span></code><code><span>  out &lt;- mclapply(1:svn_itor, res, mc.cores=1) </span></code><code><span>}<span>else</span> {</span></code><code><span>  out &lt;- mclapply(1:svn_itor, res, mc.cores=svn_itor)</span></code><code><span>}</span></code><code><span><span># 运行了Support Vector Machines，函数是 svm {e1071}</span></span></code><code><span><br></span></code><code><span><span>###windows开多核</span></span></code><code><span>library(parallel)</span></code><code><span>clnum&lt;-detectCores() </span></code><code><span>cl &lt;- makeCluster(getOption(<span>"cl.cores"</span>, clnum))</span></code><code><span>clusterExport(cl, c(<span>"X"</span>,<span>"y"</span>),envir=environment())</span></code><code><span>clusterEvalQ(cl,library(e1071))</span></code><code><span>out &lt;- parLapply(cl,1:svn_itor,res)</span></code><code><span><span>####</span></span></code><code><span>out</span></code><code><span><span>#Initiate two variables with 0</span></span></code><code><span>nusvm &lt;- rep(0,svn_itor)</span></code><code><span>corrv &lt;- rep(0,svn_itor)</span></code><code><span><br></span></code><code><span><br></span></code><code><span>t &lt;- 1</span></code><code><span><span>while</span>(t &lt;= svn_itor) {</span></code><code><span>  </span></code><code><span>  <span># 得到两个向量之间矩阵乘法的权重，此时应该只得到一个数字。</span></span></code><code><span>  <span># 这样做是乘以系数</span></span></code><code><span>  </span></code><code><span>  <span># 支持向量是数据集的点，它们靠近分隔类别的平面</span></span></code><code><span>  <span># 现在的问题是，我没有任何类别（离散变量，例如“运动”、“电影”），但我有一个连续变量</span></span></code><code><span>  mySupportVectors &lt;- out[[t]]<span>$SV</span> <span>###不同nu参数的支持向量</span></span></code><code><span>  </span></code><code><span>  <span># 系数定义</span></span></code><code><span>  myCoefficients &lt;- out[[t]]<span>$coefs</span> <span>###不同nu参数的系数</span></span></code><code><span>  weights = t(myCoefficients) %*% mySupportVectors <span>####2个矩阵的乘积</span></span></code><code><span>  </span></code><code><span>  <span># 设置权重和相关性</span></span></code><code><span>  weights[<span>which</span>(weights&lt;0)]&lt;-0 <span>##小于0的乘积为0</span></span></code><code><span>  w&lt;-weights/sum(weights) <span>##相关性</span></span></code><code><span>  </span></code><code><span>  <span># 根据对应的权重与参考集相乘</span></span></code><code><span>  u &lt;- sweep(X,MARGIN=2,w,<span>'*'</span>) <span>###sweep类似于apply，多了一个STATS，代表是运算的参数</span></span></code><code><span>  </span></code><code><span>  <span># 统计每行总和</span></span></code><code><span>  k &lt;- apply(u, 1, sum)</span></code><code><span>  nusvm[t] &lt;- sqrt((mean((k - y)^2))) <span>###标准差</span></span></code><code><span>  corrv[t] &lt;- cor(k, y) <span>##相关性</span></span></code><code><span>  t &lt;- t + 1 <span>###t从1开始循环，直到t=3</span></span></code><code><span>}</span></code><code><span><span>#pick best model</span></span></code><code><span>rmses &lt;- nusvm</span></code><code><span>corrv</span></code><code><span>mn &lt;- which.min(rmses) <span>###去标准差最小的nu值为best model</span></span></code><code><span>mn  </span></code><code><span><span>#[1] 1</span></span></code><code><span>model &lt;- out[[mn]]</span></code><code><span><span># 从nus为0.25,0.5,0.75的3个模型里面挑选一个即可</span></span></code><code><span><br></span></code><code><span><span>#get and normalize coefficients</span></span></code><code><span><br></span></code><code><span>q &lt;- t(model<span>$coefs</span>) %*% model<span>$SV</span> </span></code><code><span><br></span></code><code><span>q[<span>which</span>(q&lt;0)]&lt;-0</span></code><code><span><span># w 就是计算后的22种免疫细胞的比例</span></span></code><code><span>w &lt;- (q/sum(q))</span></code><code><span><br></span></code><code><span>mix_rmse &lt;- rmses[mn]</span></code><code><span>mix_r &lt;- corrv[mn]</span></code><code><span><br></span></code><code><span><span># 会返回这个随机的y的免疫细胞组成情况，就是权重w</span></span></code><code><span>newList &lt;- list(<span>"w"</span> = w, <span>"mix_rmse"</span> = mix_rmse, <span>"mix_r"</span> = mix_r)</span></code><code><span>newList</span></code><code><span><br></span></code><code><span><span># 根据对应的权重与参考集相乘</span></span></code><code><span>u &lt;- sweep(X,MARGIN=2,w,<span>'*'</span>) </span></code><code><span>k &lt;- apply(u, 1, sum)</span></code><code><span>plot(y,k)</span></code><code><span>sqrt((mean((k - y)^2))) </span></code><code><span>cor(k, y)</span></code><code><span><span># 通常这个预测结果都惨不忍睹</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># 每次把表达矩阵通过去卷积拆分成为LM22的免疫细胞比例结果</span></span></code><code><span><br></span></code><code><span><span># 并且包装成为函数，如下：</span></span></code><code><span><br></span></code><code><span><span>#' CIBERSORT R script v1.03 (last updated 07-10-2015)</span></span></code><code><span><span>#' <span>Note:</span> Signature matrix construction is not currently available; use java version for full functionality.</span></span></code><code><span><span>#' Author: Aaron M. Newman, Stanford University (amnewman@stanford.edu)</span></span></code><code><span><span>#Core algorithm</span></span></code><code><span>CoreAlg &lt;- <span>function</span>(X, y){</span></code><code><span>  </span></code><code><span>  <span>#try different values of nu</span></span></code><code><span>  svn_itor &lt;- 3</span></code><code><span>  </span></code><code><span>  res &lt;- <span>function</span>(i){</span></code><code><span>    <span>if</span>(i==1){nus &lt;- 0.25}</span></code><code><span>    <span>if</span>(i==2){nus &lt;- 0.5}</span></code><code><span>    <span>if</span>(i==3){nus &lt;- 0.75}</span></code><code><span>    model&lt;-e1071::svm(X,y,<span>type</span>=<span>"nu-regression"</span>,kernel=<span>"linear"</span>,nu=nus,scale=F)</span></code><code><span>    model</span></code><code><span>  }</span></code><code><span>  </span></code><code><span>  <span>if</span>(Sys.info()[<span>'sysname'</span>] == <span>'Windows'</span>) out &lt;- parallel::mclapply(1:svn_itor, res, mc.cores=1) <span>else</span></span></code><code><span>    out &lt;- parallel::mclapply(1:svn_itor, res, mc.cores=svn_itor)</span></code><code><span>  </span></code><code><span>  nusvm &lt;- rep(0,svn_itor)</span></code><code><span>  corrv &lt;- rep(0,svn_itor)</span></code><code><span>  </span></code><code><span>  <span>#do cibersort</span></span></code><code><span>  t &lt;- 1</span></code><code><span>  <span>while</span>(t &lt;= svn_itor) {</span></code><code><span>    weights = t(out[[t]]<span>$coefs</span>) %*% out[[t]]<span>$SV</span></span></code><code><span>    weights[<span>which</span>(weights&lt;0)]&lt;-0</span></code><code><span>    w&lt;-weights/sum(weights)</span></code><code><span>    u &lt;- sweep(X,MARGIN=2,w,<span>'*'</span>)</span></code><code><span>    k &lt;- apply(u, 1, sum)</span></code><code><span>    nusvm[t] &lt;- sqrt((mean((k - y)^2)))</span></code><code><span>    corrv[t] &lt;- cor(k, y)</span></code><code><span>    t &lt;- t + 1</span></code><code><span>  }</span></code><code><span>  </span></code><code><span>  <span>#pick best model</span></span></code><code><span>  rmses &lt;- nusvm</span></code><code><span>  mn &lt;- which.min(rmses)</span></code><code><span>  model &lt;- out[[mn]]</span></code><code><span>  </span></code><code><span>  <span>#get and normalize coefficients</span></span></code><code><span>  q &lt;- t(model<span>$coefs</span>) %*% model<span>$SV</span></span></code><code><span>  q[<span>which</span>(q&lt;0)]&lt;-0</span></code><code><span>  w &lt;- (q/sum(q))</span></code><code><span>  </span></code><code><span>  mix_rmse &lt;- rmses[mn]</span></code><code><span>  mix_r &lt;- corrv[mn]</span></code><code><span>  </span></code><code><span>  newList &lt;- list(<span>"w"</span> = w, <span>"mix_rmse"</span> = mix_rmse, <span>"mix_r"</span> = mix_r)</span></code><code><span>  </span></code><code><span>}</span></code><code><span><br></span></code><code><span>library(preprocessCore)</span></code><code><span>library(parallel)</span></code><code><span>library(e1071)</span></code><code><span><span>#source("cibersort.R") </span></span></code><code><span><br></span></code><code><span>itor &lt;- 1</span></code><code><span>Ylist &lt;- as.list(data.matrix(Y))</span></code><code><span>dist &lt;- matrix()</span></code><code><span><span># 就是把 CoreAlg 函数运行1000次</span></span></code><code><span>perm=50</span></code><code><span><span>while</span>(itor &lt;= perm){</span></code><code><span>  <span>print</span>(itor) <span># 打印进度</span></span></code><code><span>  </span></code><code><span>  <span>#random mixture</span></span></code><code><span>  yr &lt;- as.numeric(Ylist[ sample(length(Ylist),dim(X)[1]) ])</span></code><code><span>  </span></code><code><span>  <span>#standardize mixture</span></span></code><code><span>  yr &lt;- (yr - mean(yr)) / sd(yr)</span></code><code><span>  </span></code><code><span>  <span>#run CIBERSORT core algorithm</span></span></code><code><span>  result &lt;- CoreAlg(X, yr)</span></code><code><span>  </span></code><code><span>  mix_r &lt;- result<span>$mix_r</span></span></code><code><span>  </span></code><code><span>  <span>#store correlation</span></span></code><code><span>  <span>if</span>(itor == 1) {dist &lt;- mix_r}</span></code><code><span>  <span>else</span> {dist &lt;- rbind(dist, mix_r)}</span></code><code><span>  </span></code><code><span>  itor &lt;- itor + 1</span></code><code><span>}</span></code><code><span><span>####</span></span></code><code><span>newList &lt;- list(<span>"dist"</span> = dist)<span>###获取1000次计算相关系数</span></span></code><code><span>nulldist=sort(newList<span>$dist</span>) <span>###w值排序</span></span></code><code><span><span># 这个nulldist 主要是用来计算P值</span></span></code><code><span><span>if</span>(F){</span></code><code><span>  </span></code><code><span>  P=perm</span></code><code><span>  <span>#empirical null distribution of correlation coefficients</span></span></code><code><span>  <span>if</span>(P &gt; 0) {nulldist &lt;- sort(doPerm(P, X, Y)<span>$dist</span>)} <span>###取最小的非负p值</span></span></code><code><span>  <span>print</span>(nulldist)</span></code><code><span>}</span></code><code><span>save(nulldist,file = <span>'nulldist_perm_1000.Rdata'</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span>header &lt;- c(<span>'Mixture'</span>,colnames(X),<span>"P-value"</span>,<span>"Correlation"</span>,<span>"RMSE"</span>)</span></code><code><span><span>print</span>(header)</span></code><code><span><span>#  [1] "Mixture"                      "B cells naive"               </span></span></code><code><span><span>#  [3] "B cells memory"               "Plasma cells"                </span></span></code><code><span><span>#  [5] "T cells CD8"                  "T cells CD4 naive"           </span></span></code><code><span><span>#  [7] "T cells CD4 memory resting"   "T cells CD4 memory activated"</span></span></code><code><span><span>#  [9] "T cells follicular helper"    "T cells regulatory (Tregs)"  </span></span></code><code><span><span># [11] "T cells gamma delta"          "NK cells resting"            </span></span></code><code><span><span># [13] "NK cells activated"           "Monocytes"                   </span></span></code><code><span><span># [15] "Macrophages M0"               "Macrophages M1"              </span></span></code><code><span><span># [17] "Macrophages M2"               "Dendritic cells resting"     </span></span></code><code><span><span># [19] "Dendritic cells activated"    "Mast cells resting"          </span></span></code><code><span><span># [21] "Mast cells activated"         "Eosinophils"                 </span></span></code><code><span><span># [23] "Neutrophils"                  "P-value"                     </span></span></code><code><span><span># [25] "Correlation"                  "RMSE"  </span></span></code><code><span><br></span></code><code><span>load(file = <span>'nulldist_perm_1000.Rdata'</span>)</span></code><code><span><span>print</span>(nulldist)</span></code><code><span>fivenum(<span>print</span>(nulldist)) </span></code><code><span><span>#[1] -0.079400079 -0.009724867  0.019402797  0.056885990  0.604810742</span></span></code><code><span><span>#minimum, lower-hinge, median, upper-hinge, maximum</span></span></code><code><span><br></span></code><code><span>output &lt;- matrix()</span></code><code><span>itor &lt;- 1</span></code><code><span>mix &lt;- dim(Y)[2] <span>###取mrna中的样本</span></span></code><code><span>pval &lt;- 9999</span></code><code><span><span># 表达矩阵的每个样本，都需要计算一下LM22的比例</span></span></code><code><span><span>#iterate through mix</span></span></code><code><span><span>while</span>(itor &lt;= mix){</span></code><code><span>  </span></code><code><span>  <span>##################################</span></span></code><code><span>  <span>## Analyze the first mixed sample</span></span></code><code><span>  <span>##################################</span></span></code><code><span>  </span></code><code><span>  y &lt;- Y[,itor]</span></code><code><span>  </span></code><code><span>  <span>#标准化样本数据集</span></span></code><code><span>  y &lt;- (y - mean(y)) / sd(y)</span></code><code><span>  </span></code><code><span>  <span>#执行SVR核心算法</span></span></code><code><span>  result &lt;- CoreAlg(X, y)</span></code><code><span>  </span></code><code><span>  <span>#获得结果</span></span></code><code><span>  w &lt;- result<span>$w</span></span></code><code><span>  mix_r &lt;- result<span>$mix_r</span></span></code><code><span>  mix_rmse &lt;- result<span>$mix_rmse</span></span></code><code><span>  </span></code><code><span>  <span>#计算p-value</span></span></code><code><span>  <span>if</span>(pval &gt; 0) {pval &lt;- 1 - (which.min(abs(nulldist - mix_r)) / length(nulldist))}</span></code><code><span>  </span></code><code><span>  <span>#输出output</span></span></code><code><span>  out &lt;- c(colnames(Y)[itor],w,pval,mix_r,mix_rmse)</span></code><code><span>  <span>if</span>(itor == 1) {output &lt;- out}</span></code><code><span>  <span>else</span> {output &lt;- rbind(output, out)}</span></code><code><span>  itor &lt;- itor + 1</span></code><code><span>  </span></code><code><span>}</span></code><code><span>head(output)</span></code><code><span><br></span></code><code><span><span>#save results</span></span></code><code><span>write.table(rbind(header,output), file=<span>"CIBERSORT-Results.txt"</span>, sep=<span>"\t"</span>, row.names=F, col.names=F, quote=F)</span></code><code><span><br></span></code><code><span><span>#return matrix object containing all results</span></span></code><code><span>obj &lt;- rbind(header,output)</span></code><code><span>obj &lt;- obj[,-1]</span></code><code><span>obj &lt;- obj[-1,]</span></code><code><span>obj &lt;- matrix(as.numeric(unlist(obj)),nrow=nrow(obj))</span></code><code><span>rownames(obj) &lt;- colnames(Y)</span></code><code><span>colnames(obj) &lt;- c(colnames(X),<span>"P-value"</span>,<span>"Correlation"</span>,<span>"RMSE"</span>)</span></code><code><span>obj</span></code><code><span>save(obj,file = <span>'output_obj.Rdata'</span>)</span></code><code><span><br></span></code><code><span><span>#return matrix object containing all results</span></span></code><code><span>obj &lt;- rbind(header,output)</span></code><code><span>obj &lt;- obj[,-1]</span></code><code><span>obj &lt;- obj[-1,]</span></code><code><span>obj &lt;- matrix(as.numeric(unlist(obj)),nrow=nrow(obj))</span></code><code><span>rownames(obj) &lt;- colnames(Y)</span></code><code><span>colnames(obj) &lt;- c(colnames(X),<span>"P-value"</span>,<span>"Correlation"</span>,<span>"RMSE"</span>)</span></code><code><span>obj[1:4,1:4]</span></code><code><span><span>#                              B cells naive B cells memory Plasma cells</span></span></code><code><span><span># TCGA-DK-AA74-01A-11R-A39I-07     0.0125034              0   0.00000000</span></span></code><code><span><span># TCGA-DK-A3IM-01A-11R-A20F-07     0.0000000              0   0.00000000</span></span></code><code><span><span># TCGA-GU-A42P-01A-11R-A23W-07     0.1414380              0   0.03075805</span></span></code><code><span><span># TCGA-4Z-AA7W-01A-11R-A39I-07     0.0000000              0   0.03125399</span></span></code><code><span><span>#                              T cells CD8</span></span></code><code><span><span># TCGA-DK-AA74-01A-11R-A39I-07  0.11688532</span></span></code><code><span><span># TCGA-DK-A3IM-01A-11R-A20F-07  0.04647556</span></span></code><code><span><span># TCGA-GU-A42P-01A-11R-A23W-07  0.02934341</span></span></code><code><span><span># TCGA-4Z-AA7W-01A-11R-A39I-07  0.37869645</span></span></code><code><span><br></span></code><code><span>save(obj,file = <span>'output_obj.Rdata'</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span>load(file = <span>'input.Rdata'</span>)</span></code><code><span>Y[1:4,1:4]</span></code><code><span>X[1:4,1:4]</span></code><code><span>dim(X)</span></code><code><span>dim(Y)</span></code><code><span>library(preprocessCore)</span></code><code><span>library(parallel)</span></code><code><span>library(e1071)</span></code><code><span>load(file = <span>'output_obj.Rdata'</span>)</span></code><code><span><br></span></code><code><span><span># Step3:将CIBERSORT_Result挑选整理，去除没有差异表达的细胞。</span></span></code><code><span>library(dplyr)</span></code><code><span>library(tidyr)</span></code><code><span>library(tidyverse)</span></code><code><span>cibersort_raw &lt;- read.table(<span>"CIBERSORT-Results.txt"</span>,header = T,sep = <span>'\t'</span>) %&gt;%</span></code><code><span>  rename(<span>"Patients"</span> = <span>"Mixture"</span>) %&gt;%</span></code><code><span>  select(-c(<span>"P.value"</span>,<span>"Correlation"</span>,<span>"RMSE"</span>))</span></code><code><span><span># 通过管道符一步步先将CIBERSORT_Results读入R语言中，并将其第一列列名“Mixture”修改为“Patiens”并去除了后三列。</span></span></code><code><span><span>#并赋值给cibersort_raw。</span></span></code><code><span><br></span></code><code><span>cibersort_tidy &lt;- cibersort_raw %&gt;%</span></code><code><span>  remove_rownames() %&gt;%</span></code><code><span>  column_to_rownames(<span>"Patients"</span>)</span></code><code><span><span># 将cibersort_raw第一列变为列名后赋值给cibersort_tidy。</span></span></code><code><span><br></span></code><code><span>flag &lt;- apply(cibersort_tidy,2,<span>function</span>(x) sum(x == 0) &lt; </span></code><code><span>                dim(cibersort_tidy)[1]/2)</span></code><code><span><span># 筛选出0值超过样本的一半的一些细胞</span></span></code><code><span>cibersort_tidy &lt;- cibersort_tidy[,<span>which</span>(flag)] %&gt;%</span></code><code><span>  as.matrix() %&gt;%</span></code><code><span>  t()</span></code><code><span><span># 留下在大部分样本中有所表达的细胞。</span></span></code><code><span><br></span></code><code><span>bk &lt;- c(seq(0,0.2,by = 0.01),seq(0.21,0.85,by=0.01))</span></code><code><span><span># breaks用来定义数值和颜色的对应关系。</span></span></code><code><span><br></span></code><code><span><span># Step4:将CIBERSORT_Result进行可视化</span></span></code><code><span><span>#1）热图</span></span></code><code><span>library(pheatmap)</span></code><code><span>library(RColorBrewer)</span></code><code><span>pheatmap(</span></code><code><span>  cibersort_tidy,</span></code><code><span>  breaks = bk,</span></code><code><span>  cluster_cols = T,</span></code><code><span>  scale = <span>"row"</span>,</span></code><code><span>  cluster_row = T,</span></code><code><span>  border_color = NA,</span></code><code><span>  show_colnames = T,</span></code><code><span>  show_rownames = T,</span></code><code><span>  color = c(colorRampPalette(colors = c(<span>"blue"</span>,<span>"white"</span>))(length(bk)/2),</span></code><code><span>            colorRampPalette(colors = c(<span>"white"</span>,<span>"red"</span>))(length(bk)/2)</span></code><code><span>  ))</span></code><code><span><span>#调整参数让热图更加美观。</span></span></code><code><span><br></span></code><code><span><span>#柱状图可视化细胞占比预测</span></span></code><code><span>library(RColorBrewer)</span></code><code><span>mypalette &lt;- colorRampPalette(brewer.pal(8,<span>"Set1"</span>))<span>###8种颜色</span></span></code><code><span>cibersort_barplot &lt;- cibersort_raw %&gt;%</span></code><code><span>  gather(key = Cell_type,value = Proportion,2:23)</span></code><code><span><span>#使用RColorBrewer包配置需要的色彩方案，使用gather函数中的key-value对应关系重建细胞名称和比例的对应关系并赋值给cibersort_barplot</span></span></code><code><span><br></span></code><code><span><span>#cibersort_barplot$Patient1 &lt;- factor(cibersort_barplot$Patient,</span></span></code><code><span><span>#                                   levels = str_sort(unique(cibersort_barplot$Patient),</span></span></code><code><span><span>#                                                      numeric = T))</span></span></code><code><span><br></span></code><code><span>ggplot(cibersort_barplot,aes(Patients,Proportion,fill = Cell_type)) + </span></code><code><span>  geom_bar(position = <span>"stack"</span>,<span>stat</span> = <span>"identity"</span>) +</span></code><code><span>  labs(fill = <span>"Cell Type"</span>,x = <span>""</span>,y = <span>"Estiamted Proportion"</span>) + theme_bw() +</span></code><code><span>  theme(axis.text.x = element_blank()) + theme(axis.ticks.x = element_blank()) +</span></code><code><span>  scale_y_continuous(expand = c(0.01,0)) +</span></code><code><span>  scale_fill_manual(values = mypalette(23))</span></code><code><span><span>#调整参数让柱状图更加美观。</span></span></code><code><span><br></span></code><code><span><span>#直观箱线图</span></span></code><code><span>ggplot(cibersort_barplot,aes(Cell_type,Proportion,fill = Cell_type)) + </span></code><code><span>  geom_boxplot(outlier.shape = 21,coulour = <span>"black"</span>) + theme_bw() + </span></code><code><span>  labs(x = <span>""</span>, y = <span>"Estimated Proportion"</span>) +</span></code><code><span>  theme(axis.text.x = element_blank()) + theme(axis.ticks.x = element_blank()) +</span></code><code><span>  scale_fill_manual(values = mypalette(23))</span></code><code><span><span>#调整参数让柱状图更加美观。</span></span></code><code><span><span>#这里有个比较新奇的函数是library(RColorBrewer)，是样本配色更加好看</span></span></code><code><span><br></span></code></pre></section></section><p><img data-galleryid="" data-ratio="0.7779083431257344" data-s="300,640" data-type="png" data-w="851" data-src="https://mmbiz.qpic.cn/mmbiz_png/kZ1wdgAscBorDvh5tx3klnD6Ty28Osicej4vcPfSNk7BkWWh6dibjHQcOTj10iaBgVibYzyjXlcUDCe70Uja8CyzUA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/mmbiz_png/kZ1wdgAscBorDvh5tx3klnD6Ty28Osicej4vcPfSNk7BkWWh6dibjHQcOTj10iaBgVibYzyjXlcUDCe70Uja8CyzUA/640?wx_fmt=png"></p><p>也是很有意思的结果了hhh。</p><p><mp-style-type data-value="10000"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/QN_-RBa_CLhMlYZE4At5gA",target="_blank" rel="noopener noreferrer">原文链接</a>
