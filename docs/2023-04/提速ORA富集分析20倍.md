---
title: "提速ORA富集分析20倍"
date: 2023-04-05T23:52:25Z
draft: ["false"]
tags: [
  "fetched",
  "方圆之处"
]
categories: ["Acdemic"]
---
提速ORA富集分析20倍 by 方圆之处
------
<div><section data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><span></span><p data-tool="mdnice编辑器">Over-representation analysis (ORA)是用来分析一个基因列表（例如差异基因，DE基因）是否富集在一个基因集合中的方法。一般使用超几何分布来计算p值，对应的函数是<code>phyper()</code>，参数为：</p><pre data-tool="mdnice编辑器"><code>phyper(x, m, n, k, lower.tail = <span>FALSE</span>)<br></code></pre><p data-tool="mdnice编辑器">其中<code>x</code>是基因集合中DE基因的个数，<code>m</code>是基因集合中基因的总数，<code>n</code>是不属于此基因集合的基因总数，<code>k</code>是DE基因的总数。</p><p data-tool="mdnice编辑器"><code>phyper(..., lower.tail = FALSE)</code>计算的是<span><span role="presentation" data-formula="\mathrm{Pr}(X &gt; x)" data-formula-type="inline-equation"><svg xmlns="http://www.w3.org/2000/svg" role="img" focusable="false" viewbox="0 -750 4608.6 1000" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="50" d="M130 622Q123 629 119 631T103 634T60 637H27V683H214Q237 683 276 683T331 684Q419 684 471 671T567 616Q624 563 624 489Q624 421 573 372T451 307Q429 302 328 301H234V181Q234 62 237 58Q245 47 304 46H337V0H326Q305 3 182 3Q47 3 38 0H27V46H60Q102 47 111 49T130 61V622ZM507 488Q507 514 506 528T500 564T483 597T450 620T397 635Q385 637 307 637H286Q237 637 234 628Q231 624 231 483V342H302H339Q390 342 423 349T481 382Q507 411 507 488Z"></path></g><g data-mml-node="mi" transform="translate(681, 0)"><path data-c="72" d="M36 46H50Q89 46 97 60V68Q97 77 97 91T98 122T98 161T98 203Q98 234 98 269T98 328L97 351Q94 370 83 376T38 385H20V408Q20 431 22 431L32 432Q42 433 60 434T96 436Q112 437 131 438T160 441T171 442H174V373Q213 441 271 441H277Q322 441 343 419T364 373Q364 352 351 337T313 322Q288 322 276 338T263 372Q263 381 265 388T270 400T273 405Q271 407 250 401Q234 393 226 386Q179 341 179 207V154Q179 141 179 127T179 101T180 81T180 66V61Q181 59 183 57T188 54T193 51T200 49T207 48T216 47T225 47T235 46T245 46H276V0H267Q249 3 140 3Q37 3 28 0H20V46H36Z"></path></g></g><g data-mml-node="mo" transform="translate(1073, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1462, 0)"><path data-c="58" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(2591.8, 0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="mi" transform="translate(3647.6, 0)"><path data-c="78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(4219.6, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></span></span>。在计算p值时，我们常也包含<span><span role="presentation" data-formula="X = x" data-formula-type="inline-equation"><svg xmlns="http://www.w3.org/2000/svg" role="img" focusable="false" viewbox="0 -683 2757.6 765" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="58" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(1129.8, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2185.6, 0)"><path data-c="78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></span></span>的情形，此时最终的p值为<span><span role="presentation" data-formula="\mathrm{Pr}(X \ge x)" data-formula-type="inline-equation"><svg xmlns="http://www.w3.org/2000/svg" role="img" focusable="false" viewbox="0 -750 4608.6 1000" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="50" d="M130 622Q123 629 119 631T103 634T60 637H27V683H214Q237 683 276 683T331 684Q419 684 471 671T567 616Q624 563 624 489Q624 421 573 372T451 307Q429 302 328 301H234V181Q234 62 237 58Q245 47 304 46H337V0H326Q305 3 182 3Q47 3 38 0H27V46H60Q102 47 111 49T130 61V622ZM507 488Q507 514 506 528T500 564T483 597T450 620T397 635Q385 637 307 637H286Q237 637 234 628Q231 624 231 483V342H302H339Q390 342 423 349T481 382Q507 411 507 488Z"></path></g><g data-mml-node="mi" transform="translate(681, 0)"><path data-c="72" d="M36 46H50Q89 46 97 60V68Q97 77 97 91T98 122T98 161T98 203Q98 234 98 269T98 328L97 351Q94 370 83 376T38 385H20V408Q20 431 22 431L32 432Q42 433 60 434T96 436Q112 437 131 438T160 441T171 442H174V373Q213 441 271 441H277Q322 441 343 419T364 373Q364 352 351 337T313 322Q288 322 276 338T263 372Q263 381 265 388T270 400T273 405Q271 407 250 401Q234 393 226 386Q179 341 179 207V154Q179 141 179 127T179 101T180 81T180 66V61Q181 59 183 57T188 54T193 51T200 49T207 48T216 47T225 47T235 46T245 46H276V0H267Q249 3 140 3Q37 3 28 0H20V46H36Z"></path></g></g><g data-mml-node="mo" transform="translate(1073, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1462, 0)"><path data-c="58" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(2591.8, 0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(3647.6, 0)"><path data-c="78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(4219.6, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></span></span>。那么在使用<code>phyper()</code>时，我们需要将<code>x</code>调整为<code>x-1</code>。</p><pre data-tool="mdnice编辑器"><code>phyper(x - <span>1</span>, m, n, k, lower.tail = <span>FALSE</span>)<br></code></pre><p data-tool="mdnice编辑器">已知一个DE基因列表和一个基因集合，很容易能够计算出<code>phyper()</code>需要的四个参数的值。首先我编写一个<code>ora_single()</code>函数用来计算对一个单独基因集合富集分析的p值。如下代码所示，<code>ora_single()</code>需要三个参数，一个DE基因向量，一个基因集合基因向量和一个背景基因向量。在很多情况下，并不能保证背景基因能够完全包含DE基因或者基因集合，因此，我们需要手动去除不包含在背景基因中的基因（使用<code>intersect()</code>函数）。</p><pre data-tool="mdnice编辑器"><code><span># 假设`genes`，`gene_set`和`universe`都有相同的基因ID类型</span><br>ora_single = <span>function</span>(genes, gene_set, universe) {<br>    n_universe = length(universe)<br><br>    genes = intersect(genes, universe)<br>    gene_set = intersect(gene_set, universe)<br><br>    x = length(intersect(genes, gene_set)) <span># DE genes in the gene set</span><br>    m = length(gene_set)  <span># total genes in the gene set</span><br>    n = n_universe - m    <span># total genes not in the gene set</span><br>    k = length(genes)     <span># total DE genes</span><br><br>    phyper(x - <span>1</span>, m, n, k, lower.tail = <span>FALSE</span>)<br>}<br></code></pre><p data-tool="mdnice编辑器">然后，对于一组基因集合，我们只需要使用<code>sapply()</code>或者<code>for</code>循环将<code>ora_single()</code>应用到每一个基因集合上。在<code>ora_v1()</code>中，我假设基因集合的格式是一个list，其中每一个向量表示一个基因集合。<code>ora_v1()</code>返回一个p值向量。</p><pre data-tool="mdnice编辑器"><code><span># 版本1</span><br>ora_v1 = <span>function</span>(genes, gene_sets, universe) {<br>    sapply(gene_sets, <span>function</span>(x) ora_single(genes, x, universe))<br>}<br></code></pre><p data-tool="mdnice编辑器">可见在R中编写一个支持ORA分析的函数非常简单。为了执行<code>ora_v1()</code>，我使用GO基因集合，使用蛋白编码基因作为背景基因，从其中随机抽取1000个基因作为DE基因。</p><pre data-tool="mdnice编辑器"><code><span>library</span>(org.Hs.eg.db)<br>gs = as.list(org.Hs.egGO2ALLEGS)<br>gs = lapply(gs, unique)  <span># 去掉重复的基因</span><br><span>library</span>(GO.db)<br>gs = gs[Ontology(names(gs)) == <span>"BP"</span>]  <span># 只取BP基因集合</span><br><br><span># 所有的蛋白编码基因</span><br>pc_genes = select(org.Hs.eg.db, key = <span>"protein-coding"</span>, <br>    keytype = <span>"GENETYPE"</span>, column = c(<span>"ENTREZID"</span>))[, <span>2</span>] <br>genes = sample(pc_genes, <span>1000</span>)<br></code></pre><p data-tool="mdnice编辑器">运行<code>ora_v1()</code>：</p><pre data-tool="mdnice编辑器"><code>system.time(p1 &lt;- ora_v1(genes, gs, pc_genes))<br></code></pre><pre data-tool="mdnice编辑器"><code><span>##    user  system elapsed </span><br><span>##  12.149   3.551  15.710</span><br></code></pre><p data-tool="mdnice编辑器">需要运行超过10秒钟。</p><p data-tool="mdnice编辑器">在版本1中，我使用循环的方式进行代码编写。在R中，向量化计算往往是推荐的。注意<code>phyper()</code>同样也支持以向量作为参数。在版本2中，在运行<code>phyper()</code>之前，我直接生成参数<code>x</code>，<code>m</code>和<code>n</code>向量。</p><pre data-tool="mdnice编辑器"><code><span># 版本2</span><br>ora_v2 = <span>function</span>(genes, gene_sets, universe) {<br>    <br>    genes = intersect(genes, universe)<br>    gene_sets = lapply(gene_sets, <span>function</span>(x) intersect(x, universe))<br><br>    n_universe = length(universe)<br>    n_genes = length(genes)<br>    <br>    x = sapply(gene_sets, <span>function</span>(x) length(intersect(x, genes)))<br>    m = sapply(gene_sets, length)<br>    n = n_universe - m<br>    k = n_genes<br>    <br>    phyper(x - <span>1</span>, m, n, k, lower.tail = <span>FALSE</span>)<br>}<br></code></pre><p data-tool="mdnice编辑器">使用<code>ora_v1()</code>中使用过的<code>genes</code>，<code>gs</code>和<code>pc_genes</code>变量，运行<code>ora_v2()</code>。</p><pre data-tool="mdnice编辑器"><code>system.time(p2 &lt;- ora_v2(genes, gs, pc_genes))<br></code></pre><pre data-tool="mdnice编辑器"><code><span>##    user  system elapsed </span><br><span>##   5.604   1.419   7.049</span><br></code></pre><p data-tool="mdnice编辑器">可见和<code>ora_v1()</code>相比，<code>ora_v2()</code>提速了2倍，但是还是需要若干秒。下面我们可以对<code>ora_v2()</code>进行代码profiling：</p><pre data-tool="mdnice编辑器"><code>Rprof()<br>p2 = ora_v2(genes, gs, pc_genes)<br>Rprof(<span>NULL</span>)<br>summaryRprof()$by.self<br></code></pre><pre data-tool="mdnice编辑器"><code><span>##                      self.time self.pct total.time total.pct</span><br><span>## "base::intersect"         5.52    93.88       5.74     97.62</span><br><span>## "intersect"               0.10     1.70       5.84     99.32</span><br><span>## "duplicated.default"      0.10     1.70       0.10      1.70</span><br><span>## "duplicated"              0.06     1.02       0.16      2.72</span><br><span>## "c"                       0.04     0.68       0.04      0.68</span><br><span>## "lapply"                  0.02     0.34       5.88    100.00</span><br><span>## "FUN"                     0.02     0.34       5.86     99.66</span><br><span>## "as.vector"               0.02     0.34       0.02      0.34</span><br></code></pre><p data-tool="mdnice编辑器">可见<code>intersect()</code>是代码中最耗时的一步。不过这也很好理解，在<code>ora_v2()</code>中的这一行中:</p><pre data-tool="mdnice编辑器"><code>    gene_sets = lapply(gene_sets, <span>function</span>(x) intersect(x, universe))<br></code></pre><p data-tool="mdnice编辑器">每一个基因集合记作<code>x</code>都需要和<code>universe</code>向量进行intersection。<code>universe</code>是背景基因的向量，一般非常大。在每个基因集合中，两个向量<code>x</code>和<code>universe</code>都需要被完全扫描，并且<code>universe</code>在不同基因集合中会被重复扫描。</p><p data-tool="mdnice编辑器">一个优化代码的想法是我们可以将<code>universe</code>转换为一个哈希表。那么在每个基因集合中，对其中的每个基因，我们只需要计算其是否存在于哈希表中，而不用遍历整个<code>universe</code>向量。基于这个想法，我编写了如下的Cpp代码，其中<code>unordered_set</code>是一个哈希表数据结构。</p><pre data-tool="mdnice编辑器"><code><span>library</span>(Rcpp)<br>sourceCpp(code = <span>'<br>// [[Rcpp::plugins(cpp11)]]<br><br>#include &lt;Rcpp.h&gt;<br>#include &lt;unordered_set&gt;<br>using namespace Rcpp;<br><br>// [[Rcpp::export]]<br>List intersectToList(List lt, StringVector x) {<br><br>    int n = lt.size();<br>    List out(n);<br><br>    std::unordered_set&lt;String&gt; seen;<br>    seen.insert(x.begin(), x.end());<br><br>    for(int i = 0; i &lt; n; i++) {<br>      <br>        StringVector v = as&lt;StringVector&gt;(lt[i]);<br>        LogicalVector l(v.size());<br><br>        std::unordered_set&lt;String&gt; seen2;<br><br>        for(int j = 0; j &lt; v.size(); j ++) {<br>            l[j] = seen.find(v[j]) != seen.end() &amp;&amp; seen2.insert(v[j]).second;<br>        }<br><br>        out[i] = v[l];<br>    }<br><br>    return out;<br>}<br>'</span>)<br></code></pre><p data-tool="mdnice编辑器">这个新编写的函数<code>intersectToList()</code>可以在R中使用。它接受两个参数。第一个是一个包含了若干向量的列表（<code>lt</code>），第二个参数是一个向量（<code>x</code>），其中<code>x</code>会和<code>lt</code>中的每一个向量进行intersection。在Cpp代码中，我也去掉了<code>lt</code>中每一个向量中重复的元素。</p><p data-tool="mdnice编辑器">现在我们将<code>ora_v2()</code>中原来的这行</p><pre data-tool="mdnice编辑器"><code>    gene_sets = lapply(gene_sets, <span>function</span>(x) intersect(x, universe))<br></code></pre><p data-tool="mdnice编辑器">替换成优化过的代码：</p><pre data-tool="mdnice编辑器"><code>    gene_sets = intersectToList(gene_sets, universe)<br></code></pre><p data-tool="mdnice编辑器">除了对背景基因的intersection做了优化，在对每个基因集合和DE基因做intersection时，我也使用<code>intersectToList()</code>。下面这个新函数<code>ora_v3()</code>基于<code>ora_v2()</code>，其中只修改了两行。</p><pre data-tool="mdnice编辑器"><code><span># 版本 3</span><br>ora_v3 = <span>function</span>(genes, gene_sets, universe) {<br><br>    gs_names = names(gene_sets)<br><br>    genes = intersect(genes, universe)<br>    <span># 下面这行优化过了</span><br>    gene_sets = intersectToList(gene_sets, universe)  <br><br>    n_universe = length(universe)<br>    n_genes = length(genes)<br>    <br>    <span># 下面这行优化过了</span><br>    x = sapply(intersectToList(gene_sets, genes), length)<br>    m = sapply(gene_sets, length)<br>    n = n_universe - m<br>    k = n_genes<br>    <br>    p = phyper(x - <span>1</span>, m, n, k, lower.tail = <span>FALSE</span>)<br>    names(p) = gs_names<br>    p<br>}<br></code></pre><p data-tool="mdnice编辑器">因为在Cpp代码中，基因集合名丢失了，因此在<code>ora_v3()</code>的最后三行，我手动将基因集合名添加到变量<code>p</code>中。</p><p data-tool="mdnice编辑器">现在使用相同的<code>genes</code>，<code>gs</code>和<code>pc_genes</code>变量，运行<code>ora_v3()</code>。</p><pre data-tool="mdnice编辑器"><code>system.time(p3 &lt;- ora_v3(genes, gs, pc_genes))<br></code></pre><pre data-tool="mdnice编辑器"><code><span>##    user  system elapsed </span><br><span>##   0.765   0.012   0.779</span><br></code></pre><p data-tool="mdnice编辑器">哈，现在连1秒都不需要！</p><p data-tool="mdnice编辑器">三个方法得到的p值是相同的。</p><pre data-tool="mdnice编辑器"><code>identical(p1, p2)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## [1] TRUE</span><br></code></pre><pre data-tool="mdnice编辑器"><code>identical(p1, p3)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## [1] TRUE</span><br></code></pre><p data-tool="mdnice编辑器"><code>ora_v3()</code>比<code>ora_v1()</code>快大概20倍，比<code>ora_v2()</code>快大概8倍.</p><pre data-tool="mdnice编辑器"><code><span>library</span>(microbenchmark)<br>microbenchmark(<br>    <span>"loop(v1)"</span>       = ora_v1(genes, gs, pc_genes),<br>    <span>"vectorized(v2)"</span> = ora_v2(genes, gs, pc_genes),<br>    <span>"cpp(v3)"</span>        = ora_v3(genes, gs, pc_genes),<br>    times = <span>10</span><br>)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## Unit: milliseconds</span><br><span>##            expr        min         lq       mean     median         uq        max neval</span><br><span>##        loop(v1) 14931.4735 15869.0461 16951.4684 16722.9765 17616.1699 19944.3256    10</span><br><span>##  vectorized(v2)  6254.3157  6438.0520  6946.7896  6920.0622  7206.3136  8227.8934    10</span><br><span>##         cpp(v3)   662.4454   679.9044   729.3631   712.0467   780.8184   830.0039    10</span><br></code><span></span></pre><span></span></section><p><br></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/G1gFGgu0jPzXWE97nxW4Qw",target="_blank" rel="noopener noreferrer">原文链接</a>
