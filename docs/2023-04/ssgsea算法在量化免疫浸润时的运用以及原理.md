---
title: "ssgsea算法在量化免疫浸润时的运用以及原理"
date: 2023-04-04T14:33:54Z
draft: ["false"]
tags: [
  "fetched",
  "果子学生信"
]
categories: ["Acdemic"]
---
ssgsea算法在量化免疫浸润时的运用以及原理 by 果子学生信
------
<div><section><h3><span>ssgsea在免疫浸润的使用</span></h3><p>在量化免疫浸润的时候，我们有两种主要的方法<br>第一种是CIBERSORT，他的结果是各个免疫细胞在一个样本中的占有率。<br><a href="https://mp.weixin.qq.com/s?__biz=MzIyMzA2MTcwMg==&amp;mid=2650734689&amp;idx=1&amp;sn=d6727cd63a271aec269992d4d432f8e5&amp;scene=21#wechat_redirect" data-linktype="2">量化免疫浸润时CIBERSORT的注意事项</a><br>第二种是ssGSEA，单样本GSEA分析。<br>使用起来简单，而且高度可定制。<br>以下是一句代码。</p><pre><code>gsva_data &lt;- GSVA::gsva(expr,cellMarker, method = <span>"ssgsea"</span>)<br></code></pre><p>用到的是GSVA包，expr是表达矩阵，cellMarker是基因集列表<br>计算的结果是个矩阵，行是基因集，列是样本。<br></p><figure><img data-ratio="0.56957928802589" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkayibwRWiaOoTYONP8kNCjDZonAhj7CvqI5CDCuAGcRxMMNvVQH9qdHvDA/640?wx_fmt=png" data-type="png" data-w="618" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkayibwRWiaOoTYONP8kNCjDZonAhj7CvqI5CDCuAGcRxMMNvVQH9qdHvDA/640?wx_fmt=png"></figure><p>那么接下来的问题是：<br>ssgsea返回的结果的值究竟是什么？<br>为什么用不同数量的基因集去计算同一个样本，返回的结果不一样？<br>计算出来的结果可以跨平台比较么？<br>芯片数据和RNA-seq数据，用起来有什么注意事项？<br>ssgsea是如何用基因集给样本打分的？</p><h3><span>ssgsea手工复现</span></h3><p>简单来说，就是使用随机漫步的方法，来看基因集的基因的累计密度与非基因集的基因的累计密度的偏离程度。<br>看起来复杂，手工计算后就会好很多。</p><p>现在设置三个参数<br>第一，用X代替表达矩阵expr<br>第二，用gene_sets代替基因集cellMarker<br>第三，设置一个参数用于改变数据权重alpha</p><pre><code><span>X</span>=expr<br><span>gene_sets</span>= cellMarker<br><span>alpha</span> = <span>0.25</span><br></code></pre><p>获取基因名称，以及基因个数</p><pre><code><span>row_names</span> = rownames(X)<br><span>num_genes</span> = nrow(X)<br></code></pre><p>获取每个基因集中的基因在当前表达矩阵基因中的位置</p><pre><code>gene_sets = lapply(gene_sets, <span><span>function</span>(<span>genes</span>) </span>{which(row_names %<span>in</span>% genes)})<br></code></pre><p>本来基因集中都是基因名称<br></p><figure><img data-ratio="0.3634336677814939" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkae3A0EUupjLP7P3yOv8ssvFSGKx9vPUGwfmEU0pVbUZISvu3RVNJ4ag/640?wx_fmt=png" data-type="png" data-w="897" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkae3A0EUupjLP7P3yOv8ssvFSGKx9vPUGwfmEU0pVbUZISvu3RVNJ4ag/640?wx_fmt=png"></figure><p>现在基因集全部都是位置信息<br></p><figure><img data-ratio="0.37386363636363634" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaGHDP98ibuG1xBYknVHwAUBj7qpXv4YiaGpicDjlGjdXIaEIpPQXyaS2icg/640?wx_fmt=png" data-type="png" data-w="880" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaGHDP98ibuG1xBYknVHwAUBj7qpXv4YiaGpicDjlGjdXIaEIpPQXyaS2icg/640?wx_fmt=png"></figure><p>此时295代表基因ADAM28，在基因中是第295位<br>可以验证出来，确实如此</p><pre><code><span>row_names</span><span>[295]</span><br></code></pre><p>现在，我们要把四列样本，每一列的重新排序，排序的标准就是基因的表达量，从高到底</p><pre><code>R &lt;- apply(X, <span>2</span>, <span><span>function</span><span>(x)</span> <span>as</span>.<span>integer</span><span>(rank<span>(x)</span>)</span>)<br></span></code></pre><p>此时仅仅给出每个样本中，每个基因的位置，没有物理层面改变顺序<br></p><figure><img data-ratio="0.9716713881019831" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaSsTdOmkCVyRwAoLYsib8SQUEtqIic4lrHfsF3JZsF0aMdd0IiaGhWFygg/640?wx_fmt=png" data-type="png" data-w="353" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaSsTdOmkCVyRwAoLYsib8SQUEtqIic4lrHfsF3JZsF0aMdd0IiaGhWFygg/640?wx_fmt=png"></figure><p>准备工作已经做完了，现在要做的就是计算一个每个样本中每个数据集的值</p><p>我们先简化到，计算第一个基因集在第一个样本中的富集分数<br>首先，对第一列的样本排序，获取每个基因从大到小排序后原先的位置<br>实际上就是理解order的用法，他跟sort比，不仅仅把基因排序，同时返回的是排序后的基因在原来集合中的位置</p><pre><code>gene_ranks &lt;- <span>order</span>(R[,<span>1</span>], decreasing = <span>TRUE</span>)<br></code></pre><p>获取第一个基因集</p><pre><code>gene_set_idx &lt;- gene_sets<span>[[1]]</span><br></code></pre><p>找出在基因集中的基因和不在基因集中的基因</p><pre><code><span>indicator_pos</span> = gene_ranks %in% gene_set_idx<br><span>indicator_neg</span> = !indicator_pos<br></code></pre><p>把第一个样本的基因从大到小排序</p><pre><code>gene <span>&lt;<span>-</span> <span>sort</span>(<span>R</span>[,<span>1</span>], <span>decreasing</span> = <span>TRUE)</span><br></span></code></pre><p>然后给他打分，在基因集的给1分，不在的不给分，而且给分是按照位置的权重来给的。</p><pre><code><span>rank_alpha</span>  = (gene* indicator_pos) ^ alpha<br></code></pre><p>为什么要用alpha来计算乘方呢，GSEA的alpha是1，<br>这是主要是为了改变头尾的权重，作图理解一下(这是我此刻的理解水平，以后会提高)<br>不用alpha处理是这样的,</p><pre><code>plot(gene* indicator_pos)<br></code></pre><figure><img data-ratio="0.7736486486486487" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaFhxg5qkmNv3mfYnhEGY5WleDwOSMBCcwYGzibTicFxnIojJYU1HbezGg/640?wx_fmt=png" data-type="png" data-w="888" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaFhxg5qkmNv3mfYnhEGY5WleDwOSMBCcwYGzibTicFxnIojJYU1HbezGg/640?wx_fmt=png"></figure><p>如果处理了之后是这样的</p><pre><code>plot((gene* indicator_pos) ^ alpha)<br></code></pre><p>靠感觉就是，基因集中的这25个基因的值，权重更大了。<br></p><figure><img data-ratio="0.7814269535673839" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkal93fmaxAaibOkvPeLmXtxoZ4oBnZnNlqJ7wuDJrktsAbbticBxTsHmnA/640?wx_fmt=png" data-type="png" data-w="883" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkal93fmaxAaibOkvPeLmXtxoZ4oBnZnNlqJ7wuDJrktsAbbticBxTsHmnA/640?wx_fmt=png"></figure><p>计算基因集中的基因的累计密度</p><pre><code>step_cdf_pos = cumsum(rank_alpha)/sum(rank_alpha)<br>plot(step_cdf_pos)<br></code></pre><figure><img data-ratio="0.7731376975169301" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkatNPhibMdCnTtAVvHiapKkPiaWTyCPMTOrKWIRmjNEvgsrKn5fRSTkjDZw/640?wx_fmt=png" data-type="png" data-w="886" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkatNPhibMdCnTtAVvHiapKkPiaWTyCPMTOrKWIRmjNEvgsrKn5fRSTkjDZw/640?wx_fmt=png"></figure><p>计算非基因集的基因的累计密度</p><pre><code>step_cdf_neg = cumsum(indicator_neg) / sum(indicator_neg)<br>plot(plot(step_cdf_pos))<br></code></pre><figure><img data-ratio="0.7909090909090909" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaczn9JRDuERheWYxib0C0GJaj7E2WtWp03Dvn1lbE5b5v9Y3K32u7LsA/640?wx_fmt=png" data-type="png" data-w="880" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaczn9JRDuERheWYxib0C0GJaj7E2WtWp03Dvn1lbE5b5v9Y3K32u7LsA/640?wx_fmt=png"></figure><p>现在每个基因都可以计算出两种情况的差值<br></p><figure><img data-ratio="0.7936736161035226" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkasworlMTUjPNMZBhdrf2Lb6Gng6nsb1UaNct6GqiaEMyyt1Eh72b7TGQ/640?wx_fmt=png" data-type="png" data-w="1391" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkasworlMTUjPNMZBhdrf2Lb6Gng6nsb1UaNct6GqiaEMyyt1Eh72b7TGQ/640?wx_fmt=png"></figure><p>而这个差值的和就是最终的富集分数<br>如果是GSEA算法，那么最终的是是差值的最大值，这一点是不一样的。<br>这个方法叫作随机漫步</p><pre><code>step_cdf_diff = step_cdf_pos - step_cdf_neg<br>sum(step_cdf_diff)<br></code></pre><p>这个值算出来是633.9068</p><p>这个值是第一个基因集在第一个样本中的数值，<br>正式计算时可以批量求出每个基因集在这个样本中的富集分数</p><pre><code><span>es_sample</span> = sapply(gene_sets, function(gene_set_idx) {<br>  <span># pos: match (within the gene set)</span><br>  <span># neg: non-match (outside the gene set)</span><br>  <span>indicator_pos</span> = gene_ranks %in% gene_set_idx<br>  indicator_neg = !indicator_pos<br><br>  rank_alpha  = (R[gene_ranks,<span>1</span>] * indicator_pos)<span> ^</span> alpha<br><br>  step_cdf_pos = cumsum(rank_alpha)    / sum(rank_alpha)<br>  step_cdf_neg = cumsum(indicator_neg) / sum(indicator_neg)<br><br>  step_cdf_diff = step_cdf_pos - step_cdf_neg<br><br>  <span># Use ssGSEA or not</span><br>  sum(step_cdf_diff)<br>})<br><br>es_sample<br></code></pre><figure><img data-ratio="0.22507122507122507" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkatW50OqfURVn2t92CIHysP1ibxXNicDT0UbvL8kaCLZqI6icmHmia8RJ7jg/640?wx_fmt=png" data-type="png" data-w="1404" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkatW50OqfURVn2t92CIHysP1ibxXNicDT0UbvL8kaCLZqI6icmHmia8RJ7jg/640?wx_fmt=png"></figure><p>现在这个值很大，需要矫正，就是用要处理最大值和最小值的差值，我们计算完了再来矫正。</p><p>现在，我们接着这句命令，往下走</p><pre><code>R &lt;- apply(X, <span>2</span>, <span><span>function</span><span>(x)</span> <span>as</span>.<span>integer</span><span>(rank<span>(x)</span>)</span>)<br></span></code></pre><p>批量计算</p><pre><code>es = apply(R, <span>2</span>, <span><span>function</span><span>(R_col)</span> </span>{<br>    gene_ranks = order(R_col, decreasing = <span>TRUE</span>)<br>    <span># Calc es for each gene set</span><br>    es_sample = sapply(gene_sets, <span><span>function</span><span>(gene_set_idx)</span> </span>{<br>      <span># pos: match (within the gene set)</span><br>      <span># neg: non-match (outside the gene set)</span><br>      indicator_pos = gene_ranks %in% gene_set_idx<br>      indicator_neg = !indicator_pos<br><br>      rank_alpha  = (R_col[gene_ranks] * indicator_pos) ^ alpha<br><br>      step_cdf_pos = cumsum(rank_alpha)    / sum(rank_alpha)<br>      step_cdf_neg = cumsum(indicator_neg) / sum(indicator_neg)<br><br>      step_cdf_diff = step_cdf_pos - step_cdf_neg<br><br>      <span># Use ssGSEA or not</span><br>      sum(step_cdf_diff)<br>    })<br>    unlist(es_sample)<br>  })<br></code></pre><p>这就是结果所有样本的结果<br></p><figure><img data-ratio="0.8306264501160093" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCka2NXWgCktXVUicIjWdh15GumU8ibNNSRfO6ibt0uHA2P294SBXD5mA3D3g/640?wx_fmt=png" data-type="png" data-w="431" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCka2NXWgCktXVUicIjWdh15GumU8ibNNSRfO6ibt0uHA2P294SBXD5mA3D3g/640?wx_fmt=png"></figure><p>现在进行矫正</p><pre><code><span>es</span> = es / diff(range(es))<br></code></pre><p>得到的结果，跟正式运行时是一样的。<br></p><figure><img data-ratio="0.7618025751072961" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaecbGTnqLXiaIu9NicibHcEhFh8ZAQxWBGzOIXzLP0BuZEGaC8XicydWI9Q/640?wx_fmt=png" data-type="png" data-w="466" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX0mjIxRGibZiabOpWGziajwCkaecbGTnqLXiaIu9NicibHcEhFh8ZAQxWBGzOIXzLP0BuZEGaC8XicydWI9Q/640?wx_fmt=png"></figure><p>增加行名和列名</p><pre><code>rownames(es) = names(gene_sets)<br>colnames(es) = colnames(X)<br></code></pre><p>至此，我们用手工计算的方式，复现了ssgsea的过程。</p><h3><span>注意事项</span></h3><p>根据计算，得到的结果是富集分数，而且是矫正后的富集分数，<br>所以，可以称为NES(normalized enrichment score)</p><p>又因为矫正时用的是最大值和最小值的差值，那么只要基因集的数量不一样，<br>这个差值就会不一样，那么最终的结果就会不一样。<br>这是手工复现时发现的。</p><p>这个结果能跨平台比较么，<br>我觉得不能，因为他计算时强烈的依赖当前基因的测量值以及基因的个数，<br>不同的平台没办法满足这两个条件。</p><p>计算时，我们知道，他一上来就根据测量值把基因给排了序，所以<br>芯片，或者测序数据，取不取log，我觉得都对结果没有影响。<br>我这么说，有可能不对，因为GSVA的论文中，给出了建议：<br>芯片数据需要Normalization(具体方案已经在安排)<br>测序数据RNA-seq需要是counts或者TPM，也可以使用log化后的数据。</p><p>但是，对于ssgsea的算法而言，除了要保证一开始的数据是矫正过的(因为最终是样本间比较，所以芯片样本间的矫正是必须的)。<br>其代码中并没有发现对数据有什么严格的要求，甚至我觉得log都不重要。</p><p>详细的讲解视频，在更新完了xcell，小鼠免疫浸润，后连同之前的CIBERSORT一起更新在答疑群中。<br>到时候，我应该会有新的理解。</p></section></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/TnUq-NfIc7oQTjnflVqs4g",target="_blank" rel="noopener noreferrer">原文链接</a>
