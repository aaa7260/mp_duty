---
title: "【越学越厉害】R语言编程必备，tidyverse最实用的开源包推荐！"
date: 2023-04-15T12:26:28Z
draft: ["false"]
tags: [
  "fetched",
  "R友舍"
]
categories: ["Acdemic"]
---
【越学越厉害】R语言编程必备，tidyverse最实用的开源包推荐！ by R友舍
------
<div><p data-mpa-powered-by="yiban.io"><img data-ratio="0.5625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/mPW54JA3nXft0KGXe4uCBWUBmq7SMSNXUGBFnIrn5KKbtyEgwKHHCRu4iaDvd9lmQviciasB0WuU2BSd1X0QmfQJA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1280" src="https://mmbiz.qpic.cn/mmbiz_jpg/mPW54JA3nXft0KGXe4uCBWUBmq7SMSNXUGBFnIrn5KKbtyEgwKHHCRu4iaDvd9lmQviciasB0WuU2BSd1X0QmfQJA/640?wx_fmt=jpeg"></p><p>R语言是数据科学家和统计学家的选择之一。对于数据分析和数据可视化，R语言拥有丰富的开源包提供支持。其中最受欢迎的R包之一是tidyverse。Tidyverse是Hadley Wickham设计的一组R包，它们一起工作，采用一致的规范和语法。本文将介绍一些tidyverse中最实用的开源包，以及它们的功能。</p><p><span><strong>1、首先是ggplot2</strong></span></p><p>让您快速获得数据可视化的绝佳体验，非ggplot2莫属！这种艺术般的工具，将数据的排列、美观和易读性完美融合，让你的数据变得生动起来。她的万能图层语法，让它在图形处理中毫不费力的创建出令人惊叹的作品。这正是其高超可读性的原因——无论您是业务分析，学术出版，还是统计建模，ggplot2都能让您轻松掌握亲手打造出高清晰度的漂亮图表的技巧，让您的研究更具影响力！以下是一个简单的例子：</p><p>我们采用的数据集是`iris`，该数据集包含了150朵鸢尾花的测量数据，其中包括花瓣长度、花瓣宽度、花萼长度、花萼宽度以及所属鸢尾花的种类。这里我们用ggplot2绘制散点图，其中横坐标为花萼长度，纵坐标为花瓣长度，颜色根据花的种类进行分类。</p><p>下面是数据集的前6个观测值示例：</p><section><table><thead><tr><th>Sepal.Length</th><th>Sepal.Width</th><th>Petal.Length</th><th>Petal.Width</th><th>Species</th></tr></thead><tbody><tr><td>5.1</td><td>3.5</td><td>1.4</td><td>0.2</td><td>setosa</td></tr><tr><td>4.9</td><td>3</td><td>1.4</td><td>0.2</td><td>setosa</td></tr><tr><td>4.7</td><td>3.2</td><td>1.3</td><td>0.2</td><td>setosa</td></tr><tr><td>4.6</td><td>3.1</td><td>1.5</td><td>0.2</td><td>setosa</td></tr><tr><td>5</td><td>3.6</td><td>1.4</td><td>0.2</td><td>setosa</td></tr><tr><td>5.4</td><td>3.9</td><td>1.7</td><td>0.4</td><td>setosa<br></td></tr></tbody></table></section><p>代码如下：</p><section><ul><li><li><li><li><li></ul><pre data-lang="powershell"><code><span>library(ggplot2)</span></code><code><span><span>data</span>(iris)</span></code><code><span>ggplot(<span>data</span> = iris, aes(x = Sepal.Length, y = Petal.Length, color = Species)) +</span></code><code><span>geom_point(size = <span>2</span>) +</span></code><code><span>labs(title = <span>"Iris Sepal and Petal Length"</span>, x = <span>"Sepal Length"</span>, y = <span>"Petal Length"</span>, color = <span>"Species"</span>)</span></code></pre></section><p>以下是代码绘制的散点图，其中不同颜色代表的是不同的鸢尾花种类：</p><p><img data-galleryid="" data-ratio="0.6283269961977186" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/mPW54JA3nXft0KGXe4uCBWUBmq7SMSNXdTfGdYuJDdkUPibkiauQEIhnIvMNa7ic7gNs3BLkGCoYex9qwO1mXJAkw/640?wx_fmt=png" data-type="png" data-w="1052" src="https://mmbiz.qpic.cn/mmbiz_png/mPW54JA3nXft0KGXe4uCBWUBmq7SMSNXdTfGdYuJDdkUPibkiauQEIhnIvMNa7ic7gNs3BLkGCoYex9qwO1mXJAkw/640?wx_fmt=png"></p><p mpa-paragraph-type="body"><span><strong>2、接下来是dplyr。</strong></span></p><p mpa-paragraph-type="body">当涉及到数据操纵时，您需要dplyr！这是一款高效流畅的工具，可满足您所有的数据处理需求:无论是数据的筛选、排序，还是快速汇总和过滤，dplyr都能帮助您轻松应对。最令人惊叹的是，它终于能够以清新脱俗的方式书写，让你拥有一种流畅且愉悦的使用体验，就仿佛一个技能娴熟的舞者在跳尽其所能，周而复始且增添新意。dplyr不仅易于使用，而且处理数据速度奇快，毫不磨蹭就能完成重复的工作——它将在日常数据处理中为您释放更多时间和精力，让您把更多的注意力投入到创造性、战略型活动中。规模化处理大数据时，dplyr将是您的得力助手，爬山越岭皆可轻松驾驭，是您提升数据检索技能，为学术和商业工作增添色彩的首选利器！以下是一个简单的例子：</p><p mpa-paragraph-type="body">在这里我们使用dplyr来对航班延误数据进行操作。</p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="objectivec"><code><span><span># 加载dplyr包library(dplyr)</span></span></code><code><span><br></span></code><code><span><span># 加载flights数据集data(<span>"flights"</span>)</span></span></code><code><span><br></span></code><code><span><span># 显示数据结构及部分示例数据str(flights)</span></span></code><code><span>head(flights)</span></code><code><span><br></span></code><code><span><span># 按照目的地分组，计算每个目的地的总延迟时间top_flights <span>&lt;- flights %&gt;</span>%</span></span></code><code><span>group_by(dest) %&gt;%</span></code><code><span>summarize(total_delay = sum(arr_delay)) %&gt;%</span></code><code><span>arrange(desc(total_delay)) %&gt;%</span></code><code><span>head(<span>10</span>)</span></code><code><span><br></span></code><code><span><span># 显示结果top_flights</span></span></code></pre></section><section><span>数据介绍：</span></section><section><span>航班延误数据集（flights）是一个包含了来自于美国连续的11个月的航班信息的数据集。数据集包含了实际起飞日期和时间，航班号，起飞机场和目的地机场，航空公司信息等等。其中arr_delay表示到达该目的地的延迟时间。</span></section><p>部分示例数据如下所示：<br></p><table><thead><tr><th>year</th><th>month</th><th>day</th><th>dep_time</th><th>sched_dep_time</th><th>dep_delay</th><th>arr_time</th><th>sched_arr_time</th><th>arr_delay</th><th>carrier</th><th>flight</th><th>tailnum</th><th>origin</th><th>dest</th><th>air_time</th><th>distance</th><th>hour</th><th>minute</th></tr></thead><tbody><tr><td>2013</td><td>1</td><td>1</td><td>517</td><td>515</td><td>2</td><td>830</td><td>819</td><td>11</td><td>UA</td><td>1545</td><td>N14228</td><td>EWR</td><td>IAH</td><td>227</td><td>1400</td><td>5</td><td>15</td></tr><tr><td>2013</td><td>1</td><td>1</td><td>533</td><td>529</td><td>4</td><td>850</td><td>830</td><td>20</td><td>UA</td><td>1714</td><td>N24211</td><td>LGA</td><td>IAH</td><td>227</td><td>1416</td><td>5</td><td>29</td></tr><tr><td>2013</td><td>1</td><td>1</td><td>542</td><td>540</td><td>2</td><td>923</td><td>850</td><td>33</td><td>AA</td><td>1141</td><td>N619AA</td><td>JFK</td><td>MIA</td><td>160</td><td>1089</td><td>5</td><td>40</td></tr><tr><td>2013</td><td>1</td><td>1</td><td>544</td><td>545</td><td>-1</td><td>1004</td><td>1022</td><td>-18</td><td>B6</td><td>725</td><td>N804JB</td><td>JFK</td><td>BQN</td><td>183</td><td>1576</td><td>5</td><td>45</td></tr><tr><td>2013</td><td>1</td><td>1</td><td>554</td><td>600</td><td>-6</td><td>812</td><td>837</td><td>-25</td><td>DL</td><td>461</td><td>N668DN</td><td>LGA</td><td>ATL</td><td>116</td><td>762</td><td>6</td><td>0</td></tr><tr><td>2013</td><td>1</td><td>1</td><td>554</td><td>558</td><td>-4</td><td>740</td><td>728</td><td>12</td><td>UA</td><td>1696</td><td>N39463</td><td>EWR</td><td>ORD</td><td>150</td><td>719</td><td>5</td><td>58</td></tr></tbody></table><p>使用dplyr可以对数据进行简单且快速的操作，例如上述代码就是对所有航班数据按照目的地分组，计算其延误时间并按照降序排序，最终选出前10个目的地的操作</p><section><span><strong>3、接下来是tidyr。</strong></span></section><p>假设您有一堆混乱的数据表格需要清洗，那么让tidyr成为您的救世主吧！它是一位数据整理的明星工具，尤其在不同类型数据的转换方面大有可为。其实，我们在数据清理的过程中都会遇到一些难以预料的问题，比如一些数量错位，一些混杂的值和格式差异。在这方面，tidyr使得数据转换更简单，提供了一些实用的函数，可以将数据从一种形式转化为另一种形式。通过这些功能，您可以轻松地将“宽格式”转化为“长格式”，或将“乱码”数据转换为更规范的数据格式，让您的数据得到统一，使用起来更加高效。其次，tidyr能够协助你更精确的分析数据，让数据呈现更高的质量和精度。所以，无论您是数据分析师还是数据科学家，tidyr都是您清晰、整齐和尽可能准确的数据前置处理策略中的不二之选！以下是一个简单的例子：</p><p><br></p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="makefile"><code><span>library(tidyr)</span></code><code><span>library(dplyr)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># 创建包含学生姓名和两门成绩的数据框df &lt;- data.frame(</span></span></code><code><span>name = c(<span>"Alice"</span>, <span>"Bob"</span>, <span>"Charlie"</span>),</span></code><code><span>grade_1 = c(80, 90, 95),</span></code><code><span>grade_2 = c(85, 88, 92)</span></code><code><span>)</span></code><code><span><br></span></code><code><span><span># 使用gather函数将宽格式的成绩信息转换为长格式df_long &lt;- df %&gt;%</span></span></code><code><span>gather(grade, grade_value, grade_1:grade_2)</span></code><code><span><br></span></code><code><span><span># 展示转换后的数据框df_long %&gt;%</span></span></code><code><span><span>knitr::kable()</span></span></code></pre></section><p><br>转换后的数据如下所示：<br></p><table><thead><tr><th>name</th><th>grade</th><th>grade_value</th></tr></thead><tbody><tr><td>Alice</td><td>grade_1</td><td>80</td></tr><tr><td>Bob</td><td>grade_1</td><td>90</td></tr><tr><td>Charlie</td><td>grade_1</td><td>95</td></tr><tr><td>Alice</td><td>grade_2</td><td>85</td></tr><tr><td>Bob</td><td>grade_2</td><td>88</td></tr><tr><td>Charlie</td><td>grade_2</td><td>92</td></tr></tbody></table><p>这段代码将原始数据从“宽格式”转换为了“长格式”，通过gather函数将原本的2列成绩转换为了一列“grade”和一列“grade_value”。tidyr还有其他强大的函数，如separate、unite等等。</p><section><span><strong>4、接下来，大家翘首以盼的readr来啦！</strong></span></section><p>readr可以被称作是数据读取中的“神器”，它为大家提供了一个快速而准确的数据读取器，可以轻松读取多种不同类型的数据文件，比如CSV、TXT和XLSX等。读取数据极为重要，因为一旦数据格式出现错误，就会影响后续分析和处理，所带来的麻烦就只有您自己能体会了！那么，想象一下这种情形，因为数据读取器工具不够准确，导致数据遗漏或混乱。再次进行分析就会发现一些不合理的现象，浪费了很多时间和精力。但是，借助readr这个工具，您将会在最短的时间内快速而准确地读取数据，并得到您实际想要的结果。它让您不必为文件夹、文件、数据类型和文件格式等琐碎问题烦恼，只需在短暂的时间里，轻轻松松地得到数据，尽情享受数据分析的乐趣吧！</p><p>以下是一个简单的例子：<span></span></p><section><ul><li><li></ul><pre data-lang="powershell"><code><span>library(readr)</span></code><code><span><span>data</span> &lt;- read_csv(<span>"path_to_csv_file"</span>)</span></code></pre></section><p>这段代码将CSV文件读取到R中，并将其存储在名为“data”的变量中。readr还提供了其他有用的函数，如write_csv、parse_number等等。<br></p><p><span><strong>5、最后是purrr！</strong></span></p><p><span>purrr</span>这个包不简单，它提供了一系列高级的函数，能够轻松简化许多常见的编程任务，如迭代、映射以及过滤等等。它是数据分析师最好的朋友，因为它为您的好朋友（数据集）提供了无与伦比的处理能力！想象一下这种情景，您需要对大量数据进行筛选，筛选出精确的数据集合，这时您需要用到purrr里面的“过滤函数”；或者，您需要对几个数据集进行比较，这时您可以尝试使用映射函数。这只是其众多函数的冰山一角，purrr能够轻松处理面对的任何灵活性与复杂性数据，并简化数据分析的过程。通过这些高级函数，您可以更容易地探索和分析数据，而且还能够找出数据集合的应用和使用它们的方法。这样，您的项目将会变得更为简单和高效，假如还没有使用purrr，那么赶紧行动起来吧，体验这个包带来的强大威力! 以下是一个简单的例子：<br></p><p>好的，我来介绍三个使用purrr包的R语言代码案例，它们分别是对数据进行拟合、切分和统计汇总。以下是具体的介绍和代码：</p><p><strong>案例一：对数据进行线性拟合</strong></p><p>在这个案例中，我们将使用purrr包中的map函数，对mtcars数据集中的每一列应用线性回归模型，获取系数和截距：</p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="perl"><code><span>library(purrr)</span></code><code><span>library(dplyr)</span></code><code><span><span># 加载数据</span></span></code><code><span>data(mtcars)</span></code><code><span><span># 使用map函数进行线性拟合，输出每一列的系数和截距</span></span></code><code><span>mtcars %&gt;%</span></code><code><span><span>map</span>(~ lm(.x ~ wt, data = mtcars) %&gt;%</span></code><code><span>summary() %&gt;%</span></code><code><span>coef() %&gt;%</span></code><code><span><span>`[`</span>(<span>"wt"</span>,) %&gt;%</span></code><code><span>t()) %&gt;%</span></code><code><span>enframe(name = <span>"var"</span>, value = <span>"coefficients"</span>) %&gt;%</span></code><code><span>unnest() %&gt;%</span></code><code><span>mutate_at(vars(<span>2</span>:<span>3</span>), round, digits = <span>3</span>)</span></code></pre></section><p mpa-paragraph-type="body"><br></p><section>在上面的代码块中，我们通过管道符连接了map()和其他函数，将回归系数和截距提取出来。最后，我们将数据集转换为宽格式，并将系数和截距四舍五入至小数点后3位。输出结果如下：</section><section><ul><li><li><li><li><li><li></ul><pre data-lang="css"><code><span># <span>A</span> <span>tibble</span>: 2 <span>x</span> 3</span></code><code><span><span>var</span>   <span>coefficients</span>    <span>x</span></span></code><code><span>       </span></code><code><span><br></span></code><code><span>1 <span>mpg</span> <span>-5</span><span>.33</span>  37<span>.3</span></span></code><code><span>2 <span>cyl</span> <span>-2</span><span>.88</span>  37<span>.9</span></span></code></pre></section><p mpa-paragraph-type="body"><br></p><p mpa-paragraph-type="body"><strong>案例二：对数据进行切分</strong></p><p mpa-paragraph-type="body">在这个案例中，我们将使用purrr包中的map()函数，将数据集中的各个组切分，并对每个组应用函数：</p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="properties"><code><span><span>library(purrr)</span></span></code><code><span><span>library(dplyr)</span></span></code><code><span><span># 加载数据</span></span></code><code><span><span>data(mtcars)</span></span></code><code><span><span># 将数据集按不同的车型切分</span></span></code><code><span><span>groups</span> <span>&lt;- mtcars %&gt;%</span></span></code><code><span><span>group_split(carb)</span></span></code><code><span><span># 对切分后的各组数据进行描述性统计</span></span></code><code><span><span>maps</span> <span>&lt;- map(groups, ~ summary(.x) %&gt;%</span></span></code><code><span><span>as_tibble()</span> <span>%&gt;%</span></span></code><code><span><span>mutate(group</span> = <span>unique(.x$carb)))</span></span></code><code><span><span># 将各组统计结果合并</span></span></code><code><span><span>result</span> <span>&lt;- bind_rows(maps)</span></span></code><code><span><span>result</span></span></code></pre></section><p mpa-paragraph-type="body"><br></p><p mpa-paragraph-type="body">在这个案例中，我们使用`group_split()`函数将数据集按照不同的`carb`值进行切分，并使用map()函数对每个组应用`summary()`函数来计算描述性统计信息。最后，我们将统计结果合并为一个数据集，其中每一行对应一个组。输出结果如下：</p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="css"><code><span># <span>A</span> <span>tibble</span>: 10 <span>x</span> 12</span></code><code><span><span>mpg</span>  <span>cyl</span>  <span>disp</span>    <span>hp</span>  <span>drat</span>    <span>wt</span>  <span>qsec</span>    <span>vs</span>    <span>am</span>  <span>gear</span>  <span>carb</span> <span>group</span></span></code><code><span><br></span></code><code><span>1  29<span>.1</span>     4  78<span>.7</span>    <span>NA</span>  4<span>.08</span> 1<span>.613</span> 18<span>.61</span>     1     1     4     1     1</span></code><code><span>2  22<span>.8</span>     4 108.     93  3<span>.85</span> 2<span>.32</span>  18<span>.61</span>     1     1     4     1     1</span></code><code><span>3  19<span>.7</span>     6 145     175  3<span>.62</span> 2<span>.77</span>  15<span>.5</span>      0     1     5     2     2</span></code><code><span>4  15<span>.2</span>     8 304     150  3<span>.15</span> 3<span>.44</span>  17<span>.3</span>      0     0     3     2     2</span></code><code><span>5  19<span>.2</span>     8 400.    175  3<span>.08</span> 3<span>.84</span>  17<span>.0</span>      0     0     3     2     2</span></code><code><span>6  14<span>.7</span>     8 440     230  3<span>.23</span> 5<span>.34</span>  17<span>.4</span>      0     0     3     4     4</span></code><code><span>7  10<span>.4</span>     8 472     205  2<span>.93</span> 5<span>.25</span>  18<span>.0</span>      0     0     3     4     4</span></code><code><span>8  14<span>.3</span>     8 360.    245  3<span>.21</span> 3<span>.57</span>  15<span>.8</span>      0     0     3     4     4</span></code><code><span>9  13<span>.3</span>     8 350     245  3<span>.73</span> 3<span>.84</span>  15<span>.4</span>      0     0     3     4     4</span></code><code><span>10 15<span>.8</span>     8 351     264  4<span>.22</span> 3<span>.17</span>  14<span>.5</span>      0     1     5     4     4</span></code></pre></section><p mpa-paragraph-type="body"><br></p><p mpa-paragraph-type="body"><strong>案例三：对列表进行统计汇总</strong></p><p mpa-paragraph-type="body">在这个案例中，我们将使用purrr包中的map()函数，将一个列表转换为数据框，并根据一列数据进行统计汇总：</p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="perl"><code><span>library(purrr)</span></code><code><span>library(tibble)</span></code><code><span><span># 创建列表</span></span></code><code><span>my_list &lt;- list(a = c(<span>1</span>, <span>2</span>, <span>3</span>), b = c(<span>4</span>, <span>5</span>, <span>6</span>), c = c(<span>7</span>, <span>8</span>, <span>9</span>))</span></code><code><span><span># 将列表转换为数据框</span></span></code><code><span>my_df &lt;- map_df(my_list, ~ data.frame(<span>values</span> = .x, group = names(my_list)),</span></code><code><span>.id = <span>"id"</span>)</span></code><code><span><span># 根据id和group进行汇总</span></span></code><code><span>my_summary &lt;- my_df %&gt;%</span></code><code><span>group_by(id, group) %&gt;%</span></code><code><span>summarise(mean_value = mean(<span>values</span>),</span></code><code><span>sd_value = sd(<span>values</span>)) %&gt;%</span></code><code><span>ungroup()</span></code><code><span>my_summary</span></code></pre></section><p mpa-paragraph-type="body"><br></p><p mpa-paragraph-type="body">在上述代码中，我们首先使用`list()`函数创建了一个列表，然后使用`map_df()`函数将其转换为一个数据框，在转换的过程中使用`.id = "id"`参数，以便后续的汇总操作。接着，我们使用`summarise()`函数进行汇总操作，计算每个分组（通过id和group列分组）的。此外，purrr还有许多其他有用的函数，如map_chr、map_int等等。</p><p mpa-paragraph-type="body">总之，这些包都是数据分析工作中不可或缺的工具，能够大大提高用户的效率和准确性。使用这些包，数据科学家们可以快速、简单地处理、可视化和分析大量数据，让数据的价值得到最大化。那么，如果您想提高自己的数据处理技能，tidyverse是您不得不学的技能，让我们一起跟上数据时代的步伐！</p><p mpa-paragraph-type="body"><br></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/ikDSwXAiUruMH4wUwsQ5WA",target="_blank" rel="noopener noreferrer">原文链接</a>
