---
title: "homer2学习笔记"
date: 2023-04-16T10:04:50Z
draft: ["false"]
tags: [
  "fetched",
  "生信小知识"
]
categories: ["Acdemic"]
---
homer2学习笔记 by 生信小知识
------
<div><section><span></span><h2><span>homer2学习笔记</span></h2><blockquote><p>微信公众号：<strong>生信小知识</strong><br>关注可了解更多的生物信息学教程及知识。问题或建议，请公众号留言;</p></blockquote><h3><span>目录</span></h3><p><span><span>前言</span></span><span><span>1. 安装</span></span><span><span>2. 配置</span></span><span><span><span>2.1 环境变量</span></span></span><span><span><span>2.2 基因组及注释文件安装</span></span></span><span><span>3. 程序解读</span></span><span><span><span>3.1 提取目标序列</span></span></span><span><span><span>3.2 提取背景序列</span></span></span><span><span><span>3.3 GC Normalization</span></span></span><span><span><span>3.4 自动Normalization</span></span></span><span><span><span>3.5 将目标序列转变为Oligo Table</span></span></span><span><span><span>3.6 Oligo 自动Normalization（可选）</span></span></span><span><span><span>3.7 全局搜索</span></span></span><span><span><span>3.8 矩阵优化</span></span></span><span><span><span>3.9 Mask and Repeat</span></span></span><span><span><span>3.10 Known Motifs</span></span></span><span><span><span>3.11 Screen Each Motif</span></span></span><span><span><span>3.12 Motif Files</span></span></span><span><span><span>3.13 De novo motif output</span></span></span><span><span><span>3.14 Known motif output</span></span></span><span><span>后记</span></span></p><h3><span>前言</span></h3><p>homer是一个主要用来寻找motif的软件，这里简单对homer的工作原理，还有使用方法做一定的记录。</p><h3><span>1. 安装</span></h3><p>直接使用conda安装即可：</p><pre><code>conda install homer<br></code></pre><h3><span>2. 配置</span></h3><h4><span>2.1 环境变量</span></h4><p>在安装homer时，程序默认 configureHomer.pl 存放在 homer 的路径中，但<strong>没有将其添加至环境变量</strong>，我们需要将其手动添加到PATH中。</p><p>具体路径在：</p><pre><code>$HOME/miniconda/envs/test/share/homer/configureHomer.pl<br></code></pre><p>我们可以将下面2个路径都加入到PATH中：</p><pre><code><span>$HOME</span>/miniconda/envs/<span>test</span>/share/homer<br><span>$HOME</span>/miniconda/envs/<span>test</span>/share/homer/bin<br></code></pre><p>这样我们就可以直接使用了。</p><h4><span>2.2 基因组及注释文件安装</span></h4><p>在分析motif之前，还需要预先配置目标物种的参考基因组。HOMER内置了多种常见物种的基因组信息，使用子程序 <code>configureHomer.pl</code> 来获取基因组数据：</p><pre><code>nohup configureHomer.pl -install hg38 1&gt;std.out 2&gt;err.out &amp;<br></code></pre><p>因为该过程相对耗时，建议直接放后台处理。</p><h3><span>3. 程序解读</span></h3><blockquote><p>参考：</p><ul><li><p><span>http://homer.ucsd.edu/homer/motif/</span></p></li><li><p><span>http://homer.ucsd.edu/homer/ngs/peakMotifs.html</span></p></li><li><p><span>http://homer.ucsd.edu/homer/introduction/basics.html</span></p></li></ul></blockquote><p>homer其实主要包括了2个工具：</p><ul><li><p><strong>findMotifs.pl</strong>：主要检测promoter区域的motif。另外，如果我们提供一个具体的序列fa文件，想在该序列文件中的指定区域中查找motif时，也是使用该工具进行检测。</p></li><li><p><strong>findMotifsGenome.pl</strong>：用于全基因组上motif的检查</p></li></ul><p>虽然在寻找motif上，homer有不同的工具，但是他们本质上寻找motif的原理其实是类似的。</p><h4><span>3.1 提取目标序列</span></h4><blockquote><p><code>findMotifs.pl</code> / <code>findMotifsGenome.pl</code> 通用</p></blockquote><p>如果提供的是一个类似bed文件的基因组位置文件作为input，则会根据基因组坐标提取对应的序列。</p><p>如果提供的是一个基因ID，则这些对应基因的promoter序列会被提取。</p><h4><span>3.2 提取背景序列</span></h4><blockquote><p><code>findMotifs.pl</code> / <code>findMotifsGenome.pl</code> 通用</p></blockquote><p>个人认为这其实是<strong>寻找CT</strong>的步骤，也是相对难的一个点。</p><p>这里我们可以自己提供一个背景序列fa文件（使用参数 <code>-bg</code>），也可以让系统自己选择。一般默认是系统自己选择。</p><p>这时系统怎么选择就是整个寻找motif的关键了。具体选择步骤在后面逐步解释。</p><p>主要是根据提供的目标序列中GC的百分比，在基因组上找到GC比例相同的区域作为CT。具体见后。</p><p>如果是基于promoter（也就是提供的是一个基因ID），那么此时的背景序列则是剩余其他所有基因的promoter作为背景。</p><h4><span>3.3 GC Normalization</span></h4><blockquote><p><code>findMotifs.pl</code> / <code>findMotifsGenome.pl</code> 通用</p></blockquote><p>为了保证目标序列和背景序列之间的GC比例类似，homer会根据所有目标序列的GC比例，将其分组成0-5%，5-10%，10-15%，…，95-100%的组别，然后分别在背景区域中找到GC比例相同的序列作为对应的背景序列进行比较，从而消除GC比例带来的影响。</p><blockquote><p>为什么要对GC比例进行矫正呢？</p><p>我猜是因为GC比例高的区域，一般在promoter区域，而在promoter区域中，一般会有特定的序列，例如TATA box。那这个时候，如果我们从基因组上随机挑选序列作为背景去比较，这个时候我们就很容易得到TATA box的motif。但是这个TATA box的motif可能并不是真的由于ChIPseq中目标蛋白的motif。</p><p>此外，在实验过程中，由于GC之间有3个氢键，而AT之间只有2个氢键，故在PCR过程中会存在有GC bias。因此如果我们矫正GC比例，也可以对实验中的bias进行矫正。</p></blockquote><h4><span>3.4 自动Normalization</span></h4><blockquote><p><code>findMotifs.pl</code> / <code>findMotifsGenome.pl</code> 通用</p></blockquote><p>在目标序列中，一般除了GC比例的问题外，其实还会存在有其他各种各样的bias，这就体现在目标序列中可能会有某些短序列上的偏好性，例如某些目标序列中会频繁出现AA或者GG等序列。</p><p>homer在处理这个问题时，采用了类似GC Normalization的做法，统计目标区域中<strong>短序列的出现频率</strong>，从而在选择背景区域时，匹配相同比例的序列作为背景。</p><p>例如，以2mer为例，当设置为2mer时，此时碱基序列一共有4*4=16种情况。此时则计算这16种短序列出现的频率，然后在挑选背景序列时，匹配相类似的序列作为背景。</p><blockquote><p>在程序中，我们可以通过 <code>-nlen &lt;#&gt;</code> 参数设置具体使用多少mer进行矫正。</p></blockquote><h4><span>3.5 将目标序列转变为Oligo Table</span></h4><p>我们在运行程序时，需要设置我们想要找的motif序列长度是多少，默认为 <code>-len 8,10,12</code>，即分别计算在motif长度为8，10和12时的结果。</p><blockquote><p>如果长度超过12可能会出现错误。</p></blockquote><p>然后程序会根据这个长度值，在<strong>目标序列</strong>中，找到<strong>所有不同的序列</strong>，并<strong>统计每种序列在目标区域以及在背景区域中出现的次数</strong>。这就得到了Oligo Table</p><h4><span>3.6 Oligo 自动Normalization（可选）</span></h4><p>这里的做法和3.4部分的一样的，只是这里的目标序列成了在Oligo Table中记录的序列。</p><blockquote><p>在程序中，我们可以通过 <code>-olen &lt;#&gt;</code> 参数设置具体使用多少mer进行矫正。</p></blockquote><h4><span>3.7 全局搜索</span></h4><p>这里其实是在完成Oligo Table中具体数值的统计。</p><p>为了增加敏感性，homer此处可以允许一定的错配出现。</p><blockquote><p>在程序中，我们可以通过 <code>-mis &lt;#&gt;</code> 参数设置具体允许错配的碱基数目。</p></blockquote><p>经过搜索得到完整的Oligo Table后，程序就会进行统计检验。程序可以采取2种统计检验方案——超几何检验和二项分布检验。</p><p>这两种统计检验方法我过去都有讲过，在次不做过多解释。</p><p>这两种方案进行富集检验时非常类似，主要的区别在于：</p><ul><li><p><span>超几何检验：不放回抽样</span></p></li><li><p><span>二项分布检验：放回抽样</span></p></li></ul><p>在寻找motif过程中，使用超几何检验会使结果更加准确。</p><p>不过，当目标序列和背景序列数目很多时，<strong>这两者结果之间的差异非常小</strong>，但是<strong>二项分布检验的计算速度更快</strong>。因此：</p><ul><li><p>对于 <strong>findMotifsGenome.pl</strong> 来说，默认使用的是二项分布检验。但是可以通过参数 <strong>-h</strong> 来强迫使用超几何检验。</p></li><li><p>对于 <strong>findMotifs.pl</strong> 来说，默认使用的是超几何检验。</p></li></ul><blockquote><p>注意：</p><p>由于在进行统计检验是根据Oligo Table中的数值进行分析，故程序并不会考虑在一个目标序列中存在有多少个motif序列。</p><p>在最终输出结果中可以找到同一个目标序列中存在有多少个motif序列的统计。</p></blockquote><h4><span>3.8 矩阵优化</span></h4><p>这一步主要是根据上面得到结果，对所得到的序列转化为motif的位置矩阵。即<strong>获取motif每个位置上，每个碱基出现的概率</strong>。</p><h4><span>3.9 Mask and Repeat</span></h4><p>这一步是根据设置中的 <code>-S #</code> ，找到最佳的 <code>top#</code> 个motif，并将结果进行输出。</p><h4><span>3.10 Known Motifs</span></h4><p>这一步则是从数据库中导入已知motif序列，主要是从 <code>$HOME/miniconda/envs/test/share/homer/data/knownTFs/known.motifs</code> 文件中导入</p><h4><span>3.11 Screen Each Motif</span></h4><p>这一步主要是对上述所有已知的motif进行扫描匹配。</p><h4><span>3.12 Motif Files</span></h4><p>这里简单介绍下 <code>Motif Files</code> 输出文件：</p><ul><li><p><code>homerMotifs.all.motifs</code>：程序找到的所有motif结果文件，包含了长度为8、10以及12bp的结果</p></li><li><p><code>homerMotifs.motifs8</code>：程序找到的所有长度为8的motif结果文件</p></li><li><p><code>homerMotifs.motifs10</code>：程序找到的所有长度为10的motif结果文件</p></li><li><p><code>homerMotifs.motifs12</code>：程序找到的所有长度为12的motif结果文件</p></li></ul><p>因为这3个文件的格式是一样的，所以这里我以其中一个文件作为例子讲解下结果的解读：</p><pre><code>$ head -n9 homerMotifs.motifs8<br>&gt;RCAGTAYT       1-RCAGTAYT      5.667579        -654.509041     0       T:130350.0(35.70%),B:120866.0(32.88%),P:1e-284  Tpos:99.9,Tstd:55.8,Bpos:99.9,Bstd:59.4,StrandBias:0.0,Multiplicity:1.30<br>0.433   0.044   0.343   0.180<br>0.001   0.966   0.032   0.001<br>0.832   0.001   0.001   0.166<br>0.001   0.001   0.997   0.001<br>0.001   0.059   0.001   0.939<br>0.445   0.206   0.107   0.243<br>0.054   0.450   0.040   0.456<br>0.201   0.121   0.001   0.677<br></code></pre><p>第1行是<strong>以tab作为分割</strong>，以 <code>&gt;</code> 开始，后面记录了具体的motif序列。因为这个结果来自 <code>motifs8</code>，所以序列长度是8。第一行信息包含内容较多：</p><ol><li><p><code>&amp;gt;RCAGTAYT</code>：motif序列</p></li><li><p><code>1-RCAGTAYT</code>：motif的名称</p></li><li><p><code>5.667579</code>：目标序列中出现的频率与背景序列中出现频率的<strong>log比值</strong>，可以理解为富集程度，该值越大，理论上统计检验的P值应该越小。</p></li><li><p><code>-654.509041</code>：富集检验的 <code>log(P-value)</code>，这里由于不是 <code>-10*log(P-value)</code>，故此处的值均为负数。我们可以根据其数值的绝对值大小评估富集显著性。</p></li><li><p><code>0</code>：占位符，没意义</p></li><li><p><code>T:130350.0(35.70%),B:120866.0(32.88%),P:1e-284</code>：具体的富集情况，以 <code>,</code> 分割：</p></li></ol><ul><li><p><code>T:130350.0(35.70%)</code>：在目标序列中有130350.0条序列有该motif，占全部目标序列的35.70%</p></li><li><p><code>B:120866.0(32.88%)</code>：在背景序列中有120866.0条序列有该motif，占全部目标序列的32.88%</p></li><li><p><span>统计检验的P值</span></p></li></ul><ol><li><p><code>Tpos:99.9,Tstd:55.8,Bpos:99.9,Bstd:59.4,StrandBias:0.0,Multiplicity:1.30</code>：motif的统计检验结果：</p></li></ol><ul><li><p><code>Tpos</code>：在目标序列中，该motif出现的平均位置，0-based模式。如果是0表示是序列的起始处。</p></li><li><p><code>Tstd</code>：在目标序列中，该motif出现位置的标准差。</p></li><li><p><code>Bpos</code>：在背景序列中，该motif出现的平均位置，0-based模式。如果是0表示是序列的起始处。</p></li><li><p><code>Bstd</code>：在背景序列中，该motif出现位置的标准差。</p></li><li><p><code>StrandBias</code>：出现在正链与负链的<strong>log比例</strong>。</p></li><li><p><code>Multiplicity</code>：在所有（包括背景序列和目标序列）有motif的序列中，平均每个序列中有多少个motif。</p></li></ul><h4><span>3.13 De novo motif output</span></h4><p>首先，这里的结果是针对<strong>de novo找到的motif</strong>而言的。</p><p>在这里，homer会产生2个output：</p><ul><li><p><code>homerResults.html</code>：这是一个网页版本的结果汇总。</p></li><li><p><code>homerResults</code>：这是一个目录，所有在 <code>homerResults.html</code> 中出现的图，均来自这个目录中。</p></li></ul><p>对于 <code>homerResults.html</code> 而言，我们简单看看这个结果：</p><p><img data-galleryid="" data-ratio="0.4751984126984127" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/fOo3cmIWvJrJhuMNqkGjSNl7JoT3cSTAh39BPsqJc0FuIicjowHGG1DbemjtnFFPVz1k85arwmVcAavEFa7LbpQ/640?wx_fmt=png" data-type="png" data-w="2016" src="https://mmbiz.qpic.cn/mmbiz_png/fOo3cmIWvJrJhuMNqkGjSNl7JoT3cSTAh39BPsqJc0FuIicjowHGG1DbemjtnFFPVz1k85arwmVcAavEFa7LbpQ/640?wx_fmt=png"></p><blockquote><p>所有结果是按照P值进行排序。</p></blockquote><p>我们可以看到，在我标注为1的地方，其实是上面 <code>homerMotifs.all.motifs</code> 文件里的信息，我们可以看看上述文件的结果：</p><pre><code>$ head -n11 homerMotifs.all.motifs<br>&gt;ATTTGCATDA     1-ATTTGCATDA    6.737581        -586.785136     0       T:5324.0(14.82%),B:3317.5(9.20%),P:1e-254       Tpos:100.0,Tstd:56.3,Bpos:98.2,Bstd:62.2,StrandBias:-0.0,Multiplicity:1.13<br>0.656   0.171   0.088   0.085<br>0.013   0.019   0.001   0.967<br>0.055   0.197   0.009   0.739<br>0.266   0.001   0.029   0.704<br>0.186   0.019   0.789   0.006<br>0.082   0.888   0.029   0.001<br>0.913   0.050   0.004   0.033<br>0.105   0.001   0.029   0.865<br>0.368   0.099   0.251   0.282<br>0.448   0.227   0.065   0.261<br></code></pre><p>可以看到，信息都是一一对应的。</p><p>而当我们点击2的地方时，会弹出一个新的网页：</p><figure><p><img data-galleryid="" data-ratio="1.245490981963928" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/fOo3cmIWvJrJhuMNqkGjSNl7JoT3cSTA3SNMmLKfrZy4W32YMySQuiagJEWwQ413JkUtR1oYYHyTnRnIdicsCRtA/640?wx_fmt=png" data-type="png" data-w="998" src="https://mmbiz.qpic.cn/mmbiz_png/fOo3cmIWvJrJhuMNqkGjSNl7JoT3cSTA3SNMmLKfrZy4W32YMySQuiagJEWwQ413JkUtR1oYYHyTnRnIdicsCRtA/640?wx_fmt=png"></p><figcaption><br></figcaption></figure><p>可以看到，基础信息中还是从前面文本文件中提取所得，下面则是列出了该de novo motif与已知motif中最相似的结果。</p><p>而对于这些最相似的motif结果，其实都存储在 <code>homerResults</code> 目录下。</p><p>在该目录下，关键的 <code>motif#.motif</code> 文件需要额外注意：该文件记录了我们得到的motif矩阵，同时也记录了该motif最可能匹配的TF是什么。</p><h4><span>3.14 Known motif output</span></h4><p>这部分则主要记录的是匹配到已知motif的结果。其也是从上一步结果中，通过相关性计算，找到与已知motif最相关的结果进行展示：</p><p><img data-galleryid="" data-ratio="0.3012190326386158" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/fOo3cmIWvJrJhuMNqkGjSNl7JoT3cSTAEyicVcOaLezgSZaBFicwEXVrqDm7GhPCNu6cEtnCmM6D8RShKCbgl87A/640?wx_fmt=png" data-type="png" data-w="2543" src="https://mmbiz.qpic.cn/mmbiz_png/fOo3cmIWvJrJhuMNqkGjSNl7JoT3cSTAEyicVcOaLezgSZaBFicwEXVrqDm7GhPCNu6cEtnCmM6D8RShKCbgl87A/640?wx_fmt=png"></p><h3><span>后记</span></h3><p>后续有需求再做补充~<span></span></p><span></span></section><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/nYqgCZYNleU81C6OHlWNLg",target="_blank" rel="noopener noreferrer">原文链接</a>
