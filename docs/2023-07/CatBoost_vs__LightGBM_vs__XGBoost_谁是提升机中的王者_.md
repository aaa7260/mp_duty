---
title: "CatBoost vs. LightGBM vs. XGBoost：谁是提升机中的王者？"
date: 2023-07-23T23:57:43Z
draft: ["false"]
tags: [
  "fetched",
  "Datawhale"
]
categories: ["Acdemic"]
---
CatBoost vs. LightGBM vs. XGBoost：谁是提升机中的王者？ by Datawhale
------
<div><section data-darkmode-bgcolor-16095509242984="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16095509242984="rgb(255, 255, 255)" data-style="white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;" mp-original-font-size="17" mp-original-line-height="27.200000762939453" data-mpa-powered-by="yiban.io"><section data-darkmode-bgcolor-16095509242984="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16095509242984="rgb(255, 255, 255)" mp-original-font-size="17" mp-original-line-height="27.200000762939453"><section data-darkmode-bgcolor-16095509242984="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16095509242984="rgb(255, 255, 255)" mp-original-font-size="17" mp-original-line-height="27.200000762939453"><section data-id="85660" data-custom="rgb(117, 117, 118)" data-color="rgb(117, 117, 118)" data-darkmode-bgcolor-16095509242984="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16095509242984="rgb(255, 255, 255)" mp-original-font-size="17" mp-original-line-height="27.200000762939453"><section data-darkmode-bgcolor-16095509242984="rgb(25, 25, 25)" data-darkmode-original-bgcolor-16095509242984="rgb(255, 255, 255)" data-style="margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;" mp-original-font-size="17" mp-original-line-height="27.200000762939453"><section><section><section><section data-id="85660" data-custom="rgb(117, 117, 118)" data-color="rgb(117, 117, 118)"><section><p><span> Datawhale干货 </span></p><section data-style="white-space: normal; text-align: left;font-size: 14px;line-height: 1.5em; color: rgb(12, 12, 12);"><p><span><strong>作者：Hunter Phillips，编辑：</strong></span><span><strong>数据派THU</strong></span><strong></strong></p></section></section></section></section></section></section><section><mp-common-profile data-id="MzIyNjM2MzQyNg==" data-pluginname="mpprofile" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/vI9nYe94fsEXsBwQkpYLtE2vhn7Z3RVOSRu5M1VicIgqgMRKLsxsibK7OUSqUb1rUO4pfXnQyFYKqhryAIeh4MOg/0?wx_fmt=png" data-nickname="Datawhale" data-alias="Datawhale" data-signature="一个专注于AI领域的开源组织，汇聚了众多优秀学习者，使命-for the learner，和学习者一起成长。" data-from="2" data-weuitheme="light" data-weui-theme="light" data-origin_num="538" data-is_biz_ban="0" data-isban="0" data-biz_account_status="0" data-index="0"></mp-common-profile></section></section></section></section></section></section><pre><section powered-by="xiumi.us"><section><section><section powered-by="xiumi.us"><section><section><span>本文<strong><span><strong>约3400字</strong></span></strong>，建议阅读<strong><span><strong>5分钟</strong></span></strong></span></section><section><span>本文从速度和准确性两个方面为你评估模型的性能。</span></section></section></section></section></section></section></pre><p><span><br></span></p><p><span>提升算法是一类机器学习算法，通过迭代地训练一系列弱分类器（通常是决策树）来构建一个强分类器。在每一轮迭代中，新的分类器被设计为修正前一轮分类器的错误，从而逐步提高整体的分类性能。</span></p><p><span><br></span></p><p><span>尽管神经网络兴起并流行起来，但提升算法仍然相当实用。因为它们在训练数据有限、训练时间短、缺乏参数调优专业知识等的情况下，仍然有良好的表现。</span></p><p><span></span></p><p><span>提升算法有AdaBoost、CatBoost、LightGBM、XGBoost等。</span></p><p><span><br></span></p><figure data-tool="mdnice编辑器"><img data-ratio="0.2814814814814815" data-src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZCicerP9tvWicSOKQvumWMoEpNXfoKo3unvqwUWCyuKhaPfKCMxdTgsow/640?wx_fmt=png&amp;wxfrom=13&amp;tp=wxpic" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZCicerP9tvWicSOKQvumWMoEpNXfoKo3unvqwUWCyuKhaPfKCMxdTgsow/640?wx_fmt=png&amp;wxfrom=13&amp;tp=wxpic"></figure><p><span><br></span></p><p><span>本文，将重点关注CatBoost、LightGBM、XGBoost。将包括：</span></p><p><span><br></span></p><p><span>    - 结构上的区别；</span></p><p><span>    - 每个算法对分类变量的处理方式；</span></p><p><span>    - 理解参数；</span></p><p><span>    - 在数据集上的实践；</span></p><p><span>    - 每个算法的性能。</span></p><p><span><br></span></p><p><span>文章来自：https://towardsdatascience.com/catboost-vs-light-gbm-vs-xgboost-5f93620723db</span></p><p><br></p><p><span>来源：我得学城。</span></p><p><span><span>为适合中文阅读</span><span>习惯，阅读更</span><span>有代入感，原文翻译后有删改</span></span></p><p><br></p><p><br></p><p><span>由于 XGBoost（通常被称为 GBM Killer）在机器学习领域已经存在了很长时间，并且有很多文章专门介绍它，因此本文将更多地关注 CatBoost 和 LGBM。</span><br></p><p><span><br></span></p><h1 data-tool="mdnice编辑器"><span><strong><span>1. LightGBM和XGBoost的结构差异</span></strong></span></h1><p><span>LightGBM使用一种新颖的梯度单边采样（Gradient-based One-Side Sampling,GOSS）技术，在查找分裂值时过滤数据实例，而XGBoost使用预排序算法(pre-sorted algorithm)和基于直方图的算法(Histogram-based algorithm)来计算最佳分裂。</span></p><blockquote data-tool="mdnice编辑器"><p><span>上面的实例指的是观测/样本。</span></p></blockquote><p><span>首先，让我们了解一下XGBoost的预排序分裂是如何工作的：</span></p><ul data-tool="mdnice编辑器"><li><section><span>对于每个节点，枚举所有特征；</span></section></li><li><section><span>对于每个特征，按特征值对实例进行排序；</span></section></li><li><section><span>使用线性扫描来根据信息增益(information gain)决定该特征上的最佳分裂；</span></section></li><li><p><span>选择所有特征中的最佳分裂解决方案。</span></p></li></ul><p><span>简单来说，基于直方图的算法将特征的所有数据点分成离散的箱子，并使用这些箱子来找到直方图的分裂值。虽然在训练速度上比预排序算法高效，后者需要枚举预排序的特征值上的所有可能分裂点，但在速度方面仍然落后于GOSS。</span></p><p><strong><span>那么，是什么使得GOSS方法高效呢？</span></strong></p><p><span>在AdaBoost中，样本权重可以作为样本重要性的良好指标。然而，在梯度提升决策树（GBDT）中，没有原生的样本权重，因此无法直接应用于AdaBoost提出的采样方法。这就引入了基于梯度的采样方法。</span></p><blockquote data-tool="mdnice编辑器"><p><span>梯度代表损失函数切线的斜率，因此在某种意义上，如果数据点的梯度较大，这些点对于找到最佳分裂点是重要的，因为它们具有更高的误差。</span></p></blockquote><p><span>GOSS保留所有具有较大梯度的实例，并对具有较小梯度的实例进行随机采样。例如，假设我有50万行的数据，其中1万行具有较大的梯度。因此，我的算法将选择（10k行具有较大梯度 + 剩余的490k行的x%随机选择）。假设x为10％，则选择的总行数是59k，基于这些行找到了分裂值。</span></p><blockquote data-tool="mdnice编辑器"><p><span>这里的基本假设是，具有较小梯度的训练实例具有较小的训练误差，并且已经训练得很好。为了保持相同的数据分布，在计算信息增益时，GOSS引入了一个常数乘数，用于具有较小梯度的数据实例。因此，GOSS在减少数据实例数量和保持学习决策树的准确性之间取得了良好的平衡。</span></p></blockquote><figure data-tool="mdnice编辑器"><img data-ratio="0.3472041612483745" data-src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZq3erHuN29hb7kibpoJtw1g4tuDYAzuqxw3ia649ibsp8GIAbs5eCxyeDQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="png" data-w="769" src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZq3erHuN29hb7kibpoJtw1g4tuDYAzuqxw3ia649ibsp8GIAbs5eCxyeDQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></figure><p><span>LGBM在梯度/误差较大的叶子上进一步生长</span></p><h1 data-tool="mdnice编辑器"><span><strong><span>2. 每个模型如何处理分类变量？</span></strong></span></h1><h2 data-tool="mdnice编辑器"><strong><span>2.1 CatBoost</span></strong></h2><p><span>CatBoost具有灵活性，可以提供分类列的索引，以便可以使用one-hot编码进行编码，使用one_hot_max_size参数（对于具有不同值数量小于或等于给定参数值的所有特征使用one-hot编码）。</span></p><p><span>如果在cat_features参数中未传递任何内容，则CatBoost将将所有列视为数值变量。</span></p><blockquote data-tool="mdnice编辑器"><p><span>注意：如果一个包含字符串值的列没有在cat_features中提供，CatBoost会抛出错误。另外，默认为int类型的列将默认视为数值型，如果要将其视为分类变量，必须在cat_features中指定。</span></p></blockquote><p><img data-ratio="0.34629629629629627" data-src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZDBQBYhR9fBljOUibEzKCdq4KE5k3Mdn7YpjxI5Lib7VuLBEgiasfFicURg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZDBQBYhR9fBljOUibEzKCdq4KE5k3Mdn7YpjxI5Lib7VuLBEgiasfFicURg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p><span>对于剩余的分类列，其中唯一类别数大于one_hot_max_size的列，CatBoost使用一种类似于均值编码但减少过拟合的高效编码方法。该过程如下：</span></p><ul data-tool="mdnice编辑器"><li><section><span>随机以随机顺序对输入观测集进行排列，生成多个随机排列；</span></section></li><li><section><span>将标签值从浮点数或类别转换为整数；</span></section></li><li><p><span>使用以下公式将所有分类特征值转换为数值：</span></p></li></ul><p><img data-galleryid="" data-ratio="0.16289592760180996" data-s="300,640" data-type="png" data-w="442" data-src="https://mmbiz.qpic.cn/mmbiz_png/heS6wRSHVMl61qj2SiciaMkAUKnvq3MGOgdfp9hT1P2hQPtADiaOHQaMmf4kMiaFiblqGS8vxxkl5wgDXrBazibNn4gw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/mmbiz_png/heS6wRSHVMl61qj2SiciaMkAUKnvq3MGOgdfp9hT1P2hQPtADiaOHQaMmf4kMiaFiblqGS8vxxkl5wgDXrBazibNn4gw/640?wx_fmt=png"></p><section><span><br></span></section><p><span>其中，countInClass表示标签值等于“1”的对象中当前分类特征值的出现次数，prior是分子的初步值，由起始参数确定，totalCount是具有与当前分类特征值匹配的当前对象之前的总对象数。</span></p><p><span>数学上，可以用以下方程表示：</span></p><p><img data-ratio="0.1574074074074074" data-src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZsf3xtDX6yuWp1sQcghWtxek3uq3IL7pN7gLaiatFbewJCnl8qm67zAQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZsf3xtDX6yuWp1sQcghWtxek3uq3IL7pN7gLaiatFbewJCnl8qm67zAQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><h2 data-tool="mdnice编辑器"><strong><span>2.2 LightGBM</span></strong></h2><p><span>与CatBoost类似，LightGBM也可以通过输入特征名称来处理分类特征。它不会转换为独热编码，而且比独热编码快得多。LGBM使用一种特殊的算法来找到分类特征的分裂值。</span></p><p><img data-ratio="0.10555555555555556" data-src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZqEOKLgE3DsE0cHJBZ0fKqCJGxywjCjE6es7elcKNsWcWDKibfV3lH2A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZqEOKLgE3DsE0cHJBZ0fKqCJGxywjCjE6es7elcKNsWcWDKibfV3lH2A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><blockquote data-tool="mdnice编辑器"><p><span>注意：在构建LGBM数据集之前，您应该将分类特征转换为整数类型。即使通过categorical_feature参数传递了字符串值，它也不接受字符串值。</span></p></blockquote><h2 data-tool="mdnice编辑器"><strong><span>2.3 XGBoost</span></strong></h2><p><span>与CatBoost或LGBM不同，XGBoost本身不能处理分类特征，它只接受类似于随机森林的数值型数据。因此，在将分类数据提供给XGBoost之前，需要执行各种编码，如标签编码、均值编码或独热编码。</span></p><h1 data-tool="mdnice编辑器"><span><strong><span>3. 理解参数</span></strong></span></h1><p><span>所有这些模型都有很多要调整的参数，但我们只讨论其中重要的参数。下面是这些参数的列表，根据它们的功能以及在不同模型中的对应参数。</span></p><section><figure data-tool="mdnice编辑器"><img data-ratio="0.7685185185185185" data-src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZIgduluiar6tQgibESBnfx9p8xnPHs9HrfwcOIyibnukfic9orlfaKRndSA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZIgduluiar6tQgibESBnfx9p8xnPHs9HrfwcOIyibnukfic9orlfaKRndSA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></figure></section><h1 data-tool="mdnice编辑器"><span><br></span></h1><h1 data-tool="mdnice编辑器"><span><strong><span>4. 在数据集上的实现</span></strong></span></h1><p><span>我使用了2015年航班延误的Kaggle数据集，因为它既包含分类特征又包含数值特征。由于大约有500万行数据，这个数据集对于评估每种类型的提升模型在速度和准确性方面的性能是很好的。我将使用这个数据的10%子集，约50万行。</span></p><p><span>以下是用于建模的特征：</span></p><ul data-tool="mdnice编辑器"><li><section><span>MONTH，DAY，DAY_OF_WEEK：数据类型int</span></section></li><li><section><span>AIRLINE和FLIGHT_NUMBER：数据类型int</span></section></li><li><section><span>ORIGIN_AIRPORT和DESTINATION_AIRPORT：数据类型字符串</span></section></li><li><section><span>DEPARTURE_TIME：数据类型float</span></section></li><li><section><span>ARRIVAL_DELAY：这将是目标变量，并转换为表示超过10分钟延误的布尔变量</span></section></li><li><p><span>DISTANCE和AIR_TIME：数据类型float</span></p></li></ul><pre><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="kotlin"><code><span><span>import</span> pandas <span>as</span> pd, numpy <span>as</span> np, time</span></code><code><span>from sklearn.model_selection <span>import</span> train_test_split</span></code><code><span><br></span></code><code><span><span>data</span> = pd.read_csv(<span>"./data/flights.csv"</span>)</span></code><code><span><span>data</span> = <span>data</span>.sample(frac = <span>0.1</span>, random_state=<span>10</span>)</span></code><code><span><br></span></code><code><span><span>data</span> = <span>data</span>[[<span>"MONTH"</span>,<span>"DAY"</span>,<span>"DAY_OF_WEEK"</span>,<span>"AIRLINE"</span>,<span>"FLIGHT_NUMBER"</span>,<span>"DESTINATION_AIRPORT"</span>,</span></code><code><span>                 <span>"ORIGIN_AIRPORT"</span>,<span>"AIR_TIME"</span>, <span>"DEPARTURE_TIME"</span>,<span>"DISTANCE"</span>,<span>"ARRIVAL_DELAY"</span>]]</span></code><code><span><span>data</span>.dropna(inplace=True)</span></code><code><span><br></span></code><code><span><span>data</span>[<span>"ARRIVAL_DELAY"</span>] = (<span>data</span>[<span>"ARRIVAL_DELAY"</span>]&gt;<span>10</span>)*<span>1</span></span></code><code><span><br></span></code><code><span>cols = [<span>"AIRLINE"</span>,<span>"FLIGHT_NUMBER"</span>,<span>"DESTINATION_AIRPORT"</span>,<span>"ORIGIN_AIRPORT"</span>]</span></code><code><span><span>for</span> item <span>in</span> cols:</span></code><code><span>    <span>data</span>[item] = <span>data</span>[item].astype(<span>"category"</span>).cat.codes + <span>1</span></span></code><code><span><br></span></code><code><span>train, test, y_train, y_test = train_test_split(<span>data</span>.drop([<span>"ARRIVAL_DELAY"</span>], axis=<span>1</span>), <span>data</span>[<span>"ARRIVAL_DELAY"</span>],random_state=<span>10</span>, test_size=<span>0.25</span>)</span></code></pre></section><section><span><br></span></section><p><strong><span>4.1 XGBoo</span><span>st</span></strong><br></p></pre><pre><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="python"><code><span><span>import</span> xgboost <span>as</span> xgb</span></code><code><span><span>from</span> sklearn <span>import</span> metrics</span></code><code><span><span>from</span> sklearn.model_selection <span>import</span> GridSearchCV</span></code><code><span><br></span></code><code><span><span><span>def</span> <span>auc</span><span>(m, train, test)</span>:</span> </span></code><code><span>    <span>return</span> (metrics.roc_auc_score(y_train,m.predict_proba(train)[:,<span>1</span>]),</span></code><code><span>                            metrics.roc_auc_score(y_test,m.predict_proba(test)[:,<span>1</span>]))</span></code><code><span><br></span></code><code><span><span># Parameter Tuning</span></span></code><code><span>model = xgb.XGBClassifier()</span></code><code><span>param_dist = {<span>"max_depth"</span>: [<span>10</span>,<span>30</span>,<span>50</span>],</span></code><code><span>              <span>"min_child_weight"</span> : [<span>1</span>,<span>3</span>,<span>6</span>],</span></code><code><span>              <span>"n_estimators"</span>: [<span>200</span>],</span></code><code><span>              <span>"learning_rate"</span>: [<span>0.05</span>, <span>0.1</span>,<span>0.16</span>],}</span></code><code><span>grid_search = GridSearchCV(model, param_grid=param_dist, cv = <span>3</span>, </span></code><code><span>                                   verbose=<span>10</span>, n_jobs=<span>-1</span>)</span></code><code><span>grid_search.fit(train, y_train)</span></code><code><span><br></span></code><code><span>grid_search.best_estimator_</span></code><code><span><br></span></code><code><span>model = xgb.XGBClassifier(max_depth=<span>50</span>, min_child_weight=<span>1</span>,  n_estimators=<span>200</span>,\</span></code><code><span>                          n_jobs=<span>-1</span> , verbose=<span>1</span>,learning_rate=<span>0.16</span>)</span></code><code><span>model.fit(train,y_train)</span></code><code><span><br></span></code><code><span>auc(model, train, test)</span></code></pre></section><section><span><br></span></section><p><strong><span>4.2 LightGBM</span></strong><br></p></pre><pre><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="makefile"><code><span>import lightgbm as lgb</span></code><code><span>from sklearn import metrics</span></code><code><span><br></span></code><code><span>def auc2(m, train, test): </span></code><code><span>    return (metrics.roc_auc_score(y_train,m.predict(train)),</span></code><code><span>                            metrics.roc_auc_score(y_test,m.predict(test)))</span></code><code><span><br></span></code><code><span>lg = lgb.LGBMClassifier(verbose=0)</span></code><code><span>param_dist = {<span>"max_depth"</span>: [25,50, 75],</span></code><code><span>              <span>"learning_rate"</span> : [0.01,0.05,0.1],</span></code><code><span>              <span>"num_leaves"</span>: [300,900,1200],</span></code><code><span>              <span>"n_estimators"</span>: [200]</span></code><code><span>             }</span></code><code><span>grid_search = GridSearchCV(lg, n_jobs=-1, param_grid=param_dist, cv = 3, scoring=<span>"roc_auc"</span>, verbose=5)</span></code><code><span>grid_search.fit(train,y_train)</span></code><code><span>grid_search.best_estimator_</span></code><code><span><br></span></code><code><span>d_train = lgb.Dataset(train, label=y_train)</span></code><code><span>params = {<span>"max_depth"</span>: 50, <span>"learning_rate"</span> : 0.1, <span>"num_leaves"</span>: 900,  <span>"n_estimators"</span>: 300}</span></code><code><span><br></span></code><code><span><span># Without Categorical Features</span></span></code><code><span>model2 = lgb.train(params, d_train)</span></code><code><span>auc2(model2, train, test)</span></code><code><span><br></span></code><code><span><span># With Catgeorical Features</span></span></code><code><span>cate_features_name = [<span>"MONTH"</span>,<span>"DAY"</span>,<span>"DAY_OF_WEEK"</span>,<span>"AIRLINE"</span>,<span>"DESTINATION_AIRPORT"</span>,</span></code><code><span>                 <span>"ORIGIN_AIRPORT"</span>]</span></code><code><span>model2 = lgb.train(params, d_train, categorical_feature = cate_features_name)</span></code><code><span>auc2(model2, train, test)</span></code></pre></section><section><br></section></pre><h2 data-tool="mdnice编辑器"><strong><span>4.3 CatBoost</span></strong></h2><p><span>在调整CatBoost的参数时，很难传递分类特征的索引。因此，我在没有传递分类特征的情况下调整了参数，并评估了两个模型——一个使用分类特征，另一个不使用分类特征。我单独调整了one_hot_max_size，因为它不会影响其他参数。</span></p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="makefile"><code><span>import catboost as cb</span></code><code><span>cat_features_index = [0,1,2,3,4,5,6]</span></code><code><span><br></span></code><code><span>def auc(m, train, test): </span></code><code><span>    return (metrics.roc_auc_score(y_train,m.predict_proba(train)[:,1]),</span></code><code><span>                            metrics.roc_auc_score(y_test,m.predict_proba(test)[:,1]))</span></code><code><span><br></span></code><code><span>params = {'depth': [4, 7, 10],</span></code><code><span>          'learning_rate' : [0.03, 0.1, 0.15],</span></code><code><span>         'l2_leaf_reg': [1,4,9],</span></code><code><span>         'iterations': [300]}</span></code><code><span>cb = cb.CatBoostClassifier()</span></code><code><span>cb_model = GridSearchCV(cb, params, scoring=<span>"roc_auc"</span>, cv = 3)</span></code><code><span>cb_model.fit(train, y_train)</span></code><code><span><br></span></code><code><span>With Categorical features</span></code><code><span>clf = cb.CatBoostClassifier(eval_metric=<span>"AUC"</span>, depth=10, iterations= 500, l2_leaf_reg= 9, learning_rate= 0.15)</span></code><code><span>clf.fit(train,y_train)</span></code><code><span>auc(clf, train, test)</span></code><code><span><br></span></code><code><span>With Categorical features</span></code><code><span>clf = cb.CatBoostClassifier(eval_metric=<span>"AUC"</span>,one_hot_max_size=31, \</span></code><code><span>                            depth=10, iterations= 500, l2_leaf_reg= 9, learning_rate= 0.15)</span></code><code><span>clf.fit(train,y_train, cat_features= cat_features_index)</span></code><code><span>auc(clf, train, test)</span></code></pre></section><h1 data-tool="mdnice编辑器"><span><strong><span>5. 结论</span></strong></span></h1><section><figure data-tool="mdnice编辑器"><img data-ratio="0.5" data-src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZWTuia7kNAicZqhZibO4H51cJh5Bq4TLt00SoX4o4C6lvMpCSt5RMP090g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6XVKMPL95Zc9uyicQ6NGGgYgOQibWYauAZWTuia7kNAicZqhZibO4H51cJh5Bq4TLt00SoX4o4C6lvMpCSt5RMP090g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></figure></section><section><span><br></span></section><p><span>在评估模型时，我们应该从速度和准确性两个方面考虑模型的性能。</span></p><p><span>考虑到这一点，CatBoost是赢家，测试集上的准确率最高（0.816），过拟合最小（训练集和测试集的准确率接近）且预测时间和调优时间最短。但这仅仅是因为我们考虑了分类变量并调整了one_hot_max_size。如果我们不利用CatBoost的这些特性，它的准确率只有0.752，表现最差。因此，我们得出结论，CatBoost仅在数据中存在分类变量且我们正确调整它们时表现良好。</span></p><p><span>我们的下一个表现良好的模型是XGBoost。即使忽略了我们在数据中有分类变量并将其转换为数值变量供XGBoost使用的事实，它的准确率仍与CatBoost相当接近。然而，XGBoost唯一的问题是速度太慢。调整其参数真的很令人沮丧，特别是使用GridSearchCV（运行GridSearchCV花费了我6个小时，非常糟糕的主意！）。更好的方法是单独调整参数，而不是使用GridSearchCV。阅读这篇博文，了解如何巧妙地调整参数。</span></p><p><span>最后，LightGBM排名最后。这里需要注意的一点是，当使用cat_features时，它在速度和准确性方面表现不佳。我认为它表现糟糕的原因是它对分类数据使用了某种修改过的均值编码，导致过拟合（训练准确率非常高——0.999，相比之下测试准确率较低）。然而，如果像XGBoost那样正常使用它，它可以以比XGBoost快得多的速度实现类似（甚至更高）的准确性（LGBM——0.785，XGBoost——0.789）。</span></p><p><span>最后，我必须说这些观察结果适用于这个特定的数据集，对于其他数据集可能有效也可能无效。然而，一般来说，一个真实的情况是XGBoost比其他两种算法更慢。</span></p><section><span>编辑：黄继彦</span></section><p><span><img data-backh="234" data-backw="578" data-galleryid="" data-ratio="0.40555555555555556" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/vI9nYe94fsH6YyoStiabBbU3GWxXsxEGiaZIicnE9HIlvfNXgItMoItdzb8BXnic2MjfgYtQYgtqblmSZxwO61tJhQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="png" data-w="900" src="https://mmbiz.qpic.cn/sz_mmbiz_png/vI9nYe94fsH6YyoStiabBbU3GWxXsxEGiaZIicnE9HIlvfNXgItMoItdzb8BXnic2MjfgYtQYgtqblmSZxwO61tJhQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"><span>干货学习，</span><span><strong><span>点</span></strong></span><span><strong><span>赞</span></strong></span><strong><span><span>三连</span></span></strong><span>↓</span></span></p><p><mp-style-type data-value="10000"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/eDikTYDdCXnNFt-nW1UV7Q",target="_blank" rel="noopener noreferrer">原文链接</a>
