---
title: "hclust对象里究竟有什么？"
date: 2023-07-07T23:54:31Z
draft: ["false"]
tags: [
  "fetched",
  "方圆之处"
]
categories: ["Acdemic"]
---
hclust对象里究竟有什么？ by 方圆之处
------
<div><section data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><p data-tool="mdnice编辑器">等级聚类或者层级聚类是常用的数据分析方法，在R中，我们使用<code>hclust()</code>函数进行聚类分析。<code>hclust()</code>返回一个<code>hclust</code>类的对象。在本文中，让我们来揭开<code>hclust</code>对象的真面目。</p><p data-tool="mdnice编辑器">首先生成一个随机的5x5矩阵，我们对矩阵的行进行聚类。</p><pre data-tool="mdnice编辑器"><code>set.seed(<span>123456</span>)<br>m = matrix(rnorm(<span>25</span>), <span>5</span>)<br>rownames(m) = letters[<span>1</span>:<span>5</span>]<br>hc = hclust(dist(m))<br></code></pre><p data-tool="mdnice编辑器"><code>hc</code>属于一个<code>hclust</code>的类。输入<code>hc</code>变量名打印出这个变量的一些基本信息。</p><pre data-tool="mdnice编辑器"><code>hc<br><span>## Call:</span><br><span>## hclust(d = dist(m))</span><br><span>## </span><br><span>## Cluster method   : complete </span><br><span>## Distance         : euclidean </span><br><span>## Number of objects: 5</span><br></code></pre><p data-tool="mdnice编辑器">基本上就告诉你这是一个黑盒子，不告诉你其内部的结构。使用<code>plot()</code>函数可以绘制聚类图。</p><pre data-tool="mdnice编辑器"><code>plot(hc)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJm1ymdqA6yib5Ja8nibMM3OdFlj79yr7ADG5LLzxTOHD9YuiaBlCkRia1ibg/640?wx_fmt=png" data-type="png" data-w="960" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJm1ymdqA6yib5Ja8nibMM3OdFlj79yr7ADG5LLzxTOHD9YuiaBlCkRia1ibg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">本文就来揭示这个<code>hc</code>变量的内部结构。在遇到任何一个未知格式的对象时，一般我们使用<code>str()</code>来展示其内部结构：</p><pre data-tool="mdnice编辑器"><code>str(hc)<br><span>## List of 7</span><br><span>##  $ merge      : int [1:4, 1:2] -3 -1 1 -5 -4 -2 2 3</span><br><span>##  $ height     : num [1:4] 2.01 2.48 3.51 4.11</span><br><span>##  $ order      : int [1:5] 5 3 4 1 2</span><br><span>##  $ labels     : chr [1:5] "a" "b" "c" "d" ...</span><br><span>##  $ method     : chr "complete"</span><br><span>##  $ call       : language hclust(d = dist(m))</span><br><span>##  $ dist.method: chr "euclidean"</span><br><span>##  - attr(*, "class")= chr "hclust"</span><br></code></pre><p data-tool="mdnice编辑器">可以看到，<code>hc</code>只是一个包含7个成员的简单列表。最后三个成员<code>method</code>，<code>call</code>和<code>dist.method</code>只是关于此变量的一些文字标记，我们跳过不谈。我们主要看前四个成员。</p><p data-tool="mdnice编辑器">为了正确理解<code>hc</code>的格式，我们要对其中成员向量或者矩阵的顺序额外注意。我们首先介绍<code>labels</code>和<code>order</code>成员。</p><pre data-tool="mdnice编辑器"><code>hc$labels<br><span>## [1] "a" "b" "c" "d" "e"</span><br>hc$order<br><span>## [1] 5 3 4 1 2</span><br></code></pre><p data-tool="mdnice编辑器"><code>labels</code>成员包含了原始变量的文字标签，其顺序和原始变量的顺序一致。在这里<code>hc</code>是来源于矩阵<code>m</code>，那么<code>labels</code>中值的顺序和<code>m</code>行的顺序一致。如果原始矩阵没有行名的话，<code>labels</code>是一个长度为零的向量。</p><p data-tool="mdnice编辑器"><code>order</code>的顺序和<code>labels</code>不一样。等级聚类会对变量进行重排序，那么<code>order</code>中记录了排完序之后变量的下标。</p><pre data-tool="mdnice编辑器"><code>hc$order<br><span>## [1] 5 3 4 1 2</span><br></code></pre><p data-tool="mdnice编辑器">第一个元素表示聚完类后，变量5在第一个位置上，变量3在第二个位置上，以此类推。如果我们使用原始矩阵的行名的话，聚类之后的顺序为：</p><pre data-tool="mdnice编辑器"><code>hc$labels[hc$order]<br><span>## [1] "e" "c" "d" "a" "b"</span><br></code></pre><p data-tool="mdnice编辑器">也就是说，聚类之后，变量"e"在最左侧，然后分别是"c", "d", "a"和"b"。</p><p data-tool="mdnice编辑器">现在让我们来看看<code>merge</code>和<code>height</code>成员。</p><pre data-tool="mdnice编辑器"><code>hc$merge<br><span>##      [,1] [,2]</span><br><span>## [1,]   -3   -4</span><br><span>## [2,]   -1   -2</span><br><span>## [3,]    1    2</span><br><span>## [4,]   -5    3</span><br>hc$height<br><span>## [1] 2.014138 2.478801 3.507676 4.113743</span><br></code></pre><p data-tool="mdnice编辑器">第一眼看<code>hc$merge</code>，我们可能会说这是什么鬼，既有正的整数，又有负的整数。其实，<code>merge</code>使用不同的符号来表示不同类型的聚类过程中的“节点”，比如说，这是一个变量/叶节点呢，还是一个子聚类/子树节点？</p><p data-tool="mdnice编辑器">首先我们要知道，<code>hclust()</code>执行的是聚集式的聚类方式，也就是自底而上的方式。下图展示了<code>hc</code>中的四步聚类：</p><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJWHSa8agw10hwAhSouC1LYBhib1TuruyYQ9k3kvx5xjrO1Cjg87tLHJA/640?wx_fmt=png" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJWHSa8agw10hwAhSouC1LYBhib1TuruyYQ9k3kvx5xjrO1Cjg87tLHJA/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">那么，其实<code>merge</code>中记录了聚类的步骤，第一行为聚类的第一步，第二行为聚类的第二步。每一行包含两个数据，表示把两个子节点聚成一类。其中如果值为负数时，这表示这是一个变量，那么其绝对值对应着这个变量的下标（第几号变量）；如果值为正数的话，这表示这是一个子树，值对应着子树在<code>merge</code>中的下标（第几号子树）。</p><p data-tool="mdnice编辑器">现在<code>merge</code>可以读作：</p><pre data-tool="mdnice编辑器"><code>hc$merge<br><span>##      [,1] [,2]</span><br><span>## [1,]   -3   -4</span><br><span>## [2,]   -1   -2</span><br><span>## [3,]    1    2</span><br><span>## [4,]   -5    3</span><br></code></pre><ul data-tool="mdnice编辑器"><li><section>聚类第一步/<code>merge</code>中第一行：变量3（"c")和变量4（"d"）聚成一类。这个子树（或者可以看成变量3和4的父节点）的编号为1（因为是<code>merge</code>中的第一行）。</section></li><li><section>聚类第二步/<code>merge</code>中第二行：变量1（"a")和变量2（"b"）聚成一类。这个子树的编号为2。</section></li><li><section>聚类第三步/<code>merge</code>中第三行：现在这行的两个数字都是正数，这表示要合并的两个都是聚类的子树，编号为1和2。这两个在前两步已经生成。</section></li><li><section>聚类第四步/<code>merge</code>中第四行：这里有一个负数和一个正数，这表示要合并的是一个变量（变量5，"e"）和一个子树（编号为3，在第三步中生成）。</section></li></ul><p data-tool="mdnice编辑器"><code>hc$height</code>中的元素和<code>hc$merge</code>中的行对应，就是每一个子树的高度。</p><p data-tool="mdnice编辑器">现在看来，<code>hclust</code>对象的格式还是很简单的。</p><p data-tool="mdnice编辑器">我们可以试着基于<code>hc</code>的内部格式绘制聚类图。让我们按照<code>hc$merge</code>中所记录的聚类的步骤一步一步来绘制。</p><p data-tool="mdnice编辑器">第一步是绘制合并3号变量和4号变量的子树，我们知道这个子树的高度是<code>hc$height[1]</code>，但是现在缺的是这些变量或者子树在x轴上的位置。这些位置很容易获得。</p><p data-tool="mdnice编辑器">我们知道下面标签的顺序和聚类图上的顺序一致：</p><pre data-tool="mdnice编辑器"><code>hc$labels[hc$order]<br><span>## [1] "e" "c" "d" "a" "b"</span><br></code></pre><p data-tool="mdnice编辑器">也就是说，"e"在位置1，"c"在位置2，... 但是这五个标签的顺序并不是原始顺序。在<code>hc$merge</code>中，其中的整数对应的是变量的原始顺序，例如-2表示在原始顺序中的2号变量。那么我们需要一个变量，其中记录着每个变量在聚类图上的位置，并且处于原始顺序中（也就是对应"a", "b", "c", "d", "e"）。</p><p data-tool="mdnice编辑器">我们可以首先创建一个有名字的向量，其中聚类之后的位置为值，名字为变量的标签。</p><pre data-tool="mdnice编辑器"><code><span># 1:5 是在x轴上的位置</span><br>map = structure(<span>1</span>:<span>5</span>, names = hc$labels[hc$order])<br><span># 然后我们用这个有名字的向量获得对应原始顺序的变量</span><br>x = map[hc$labels]<br>x<br><span>## a b c d e </span><br><span>## 4 5 2 3 1</span><br></code></pre><p data-tool="mdnice编辑器">其实我们可以直接取<code>hc$order</code>的order获得这个向量。</p><pre data-tool="mdnice编辑器"><code>x = order(hc$order)<br>x<br><span>## [1] 4 5 2 3 1</span><br></code></pre><p data-tool="mdnice编辑器">看起来有点绕，什么叫order的order？在<code>hc$order</code>中，值是变量的原始下标（也就是第几个变量），<code>hc$order</code>的下标（也就是1, 2, 3, 4, 5）对应着在聚完类后变量在x轴上的位置。</p><pre data-tool="mdnice编辑器"><code>hc<span>$order</span><br>  value 5 3 4 1 2  <span># indices of items, i.e. item 5, item 3, ...</span><br>  pos   1 2 3 4 5  <span># pos in x-axis in the plot</span><br></code></pre><p data-tool="mdnice编辑器">那么如果我们对<code>hc$order</code>（值为<code>5, 3, 4, 1, 2</code>）进行第二次<code>order()</code>时，在返回的变量中，第一个值是<code>5, 3, 4, 1, 2</code>中最小值的位置，就是1（1号变量）的位置是4（这个4是变量1在x轴上的位置），第二个值就是2（2号变量）的位置是5（变量2在x轴上的位置）。以此类推。这就意味着，<code>order(hc$order)</code>能够返回变量在聚类图上的位置，并且处于原始顺序中。</p><p data-tool="mdnice编辑器">OK，现在我们有了所有的信息，可以一步一步的绘制聚类图了。我们按照<code>hc$merge</code>中的顺序：</p><p data-tool="mdnice编辑器">第一步/对应着<code>hc$merge</code>中的第一行，我们画一条线连接3号变量（"c"）和4号变量（"d"）。</p><pre data-tool="mdnice编辑器"><code>plot(<span>NULL</span>, xlim = c(<span>0.5</span>, <span>5.5</span>), ylim = c(<span>0</span>, max(hc$height)*<span>1.1</span>), axes = <span>FALSE</span>, ann = <span>FALSE</span>)<br>axis(side = <span>1</span>, at = <span>1</span>:<span>5</span>, labels = hc$labels[hc$order])<br>axis(side = <span>2</span>)<br><br><span># the first row in `merge` is '[1,]   -3   -4'</span><br>segments(x[<span>3</span>], hc$height[<span>1</span>], x[<span>4</span>], hc$height[<span>1</span>])<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJTBYICWoryYYsSSGbc3k02DzTSzCVUIWTuVciajqJk89RLicyl7Hm9qFA/640?wx_fmt=png" data-type="png" data-w="960" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJTBYICWoryYYsSSGbc3k02DzTSzCVUIWTuVciajqJk89RLicyl7Hm9qFA/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">第二步/对应着<code>hc$merge</code>中的第二行，我们画一条线连接1号变量（"a"）和2号变量（"b"）。</p><pre data-tool="mdnice编辑器"><code><span># the second row in `merge` is '[2,]   -1   -2'</span><br>segments(x[<span>1</span>], hc$height[<span>2</span>], x[<span>2</span>], hc$height[<span>2</span>])<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJAB1u8nFbfwL2YwAapJW06WTicu7xRsK2megz4a7ILiaw6iaw8eRNia7gRA/640?wx_fmt=png" data-type="png" data-w="960" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJAB1u8nFbfwL2YwAapJW06WTicu7xRsK2megz4a7ILiaw6iaw8eRNia7gRA/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">第三步/对应着<code>hc$merge</code>中的第三行。现在这里有个新情况，第三步我们需要合并两个子树，我们通常连接两个子树的中点。计算子树1和子树2的中点很容易。子树1的中点就是其两个子节点（变量3和变量4）的中点，子树2的中点就是其两个子节点（变量1和变量2）的中点。</p><p data-tool="mdnice编辑器">在下面的代码中，变量<code>midpoint</code>记录了中点的位置。</p><pre data-tool="mdnice编辑器"><code>midpoint = numeric(<span>0</span>)<br>midpoint[<span>1</span>] = (x[<span>3</span>]+x[<span>4</span>])/<span>2</span> <span># 子树1的中点</span><br>midpoint[<span>2</span>] = (x[<span>1</span>]+x[<span>2</span>])/<span>2</span> <span># 子树2的中点</span><br><br><span># the third row in `merge` is '[3,]    1    2'</span><br>segments(midpoint[<span>1</span>], hc$height[<span>3</span>], midpoint[<span>2</span>], hc$height[<span>3</span>])<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJaMSfo0a58tWVF8YtZJaxicREzHibXo6GUkjFQiaYQDbWGbyXpW0Ge1Fbw/640?wx_fmt=png" data-type="png" data-w="960" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJaMSfo0a58tWVF8YtZJaxicREzHibXo6GUkjFQiaYQDbWGbyXpW0Ge1Fbw/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">第四步/对应着<code>hc$merge</code>中的第四行。这一步合并5号变量和3号子树，同样我们需要先获得3号子树的中点（3号子树的中点是其两个子节点中点<code>midpoint[1]</code>和<code>midpoint[2]</code>的中点，看代码一目了然）。</p><pre data-tool="mdnice编辑器"><code>midpoint[<span>3</span>] = (midpoint[<span>1</span>] + midpoint[<span>2</span>])/<span>2</span><br><span># the third row in `merge` is '[4,]   -5    3'</span><br>segments(x[<span>5</span>], hc$height[<span>4</span>], midpoint[<span>3</span>], hc$height[<span>4</span>])<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJHuSOibyNl641BR94cHeuhF8vdyiaoeqotO45ibayoFdbkLffrvlcYOumA/640?wx_fmt=png" data-type="png" data-w="960" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJHuSOibyNl641BR94cHeuhF8vdyiaoeqotO45ibayoFdbkLffrvlcYOumA/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">我们可以添加垂直的线条，让其看起来像一个完整的聚类树。</p><pre data-tool="mdnice编辑器"><code>plot(<span>NULL</span>, xlim = c(<span>0.5</span>, <span>5.5</span>), ylim = c(<span>0</span>, max(hc$height)*<span>1.1</span>), axes = <span>FALSE</span>, ann = <span>FALSE</span>)<br>axis(side = <span>1</span>, at = <span>1</span>:<span>5</span>, labels = hc$labels[hc$order])<br>axis(side = <span>2</span>)<br><br>segments(x[<span>3</span>], hc$height[<span>1</span>], x[<span>4</span>], hc$height[<span>1</span>])<br>segments(x[<span>3</span>], <span>0</span>, x[<span>3</span>], hc$height[<span>1</span>])<br>segments(x[<span>4</span>], <span>0</span>, x[<span>4</span>], hc$height[<span>1</span>])<br><br>segments(x[<span>1</span>], hc$height[<span>2</span>], x[<span>2</span>], hc$height[<span>2</span>])<br>segments(x[<span>1</span>], <span>0</span>, x[<span>1</span>], hc$height[<span>2</span>])<br>segments(x[<span>2</span>], <span>0</span>, x[<span>2</span>], hc$height[<span>2</span>])<br><br>midpoint = numeric(<span>0</span>)<br>midpoint[<span>1</span>] = (x[<span>3</span>]+x[<span>4</span>])/<span>2</span><br>midpoint[<span>2</span>] = (x[<span>1</span>]+x[<span>2</span>])/<span>2</span><br><br>segments(midpoint[<span>1</span>], hc$height[<span>3</span>], midpoint[<span>2</span>], hc$height[<span>3</span>])<br>segments(midpoint[<span>1</span>], hc$height[<span>3</span>], midpoint[<span>1</span>], hc$height[<span>1</span>])<br>segments(midpoint[<span>2</span>], hc$height[<span>3</span>], midpoint[<span>2</span>], hc$height[<span>2</span>])<br><br>midpoint[<span>3</span>] = (midpoint[<span>1</span>] + midpoint[<span>2</span>])/<span>2</span><br>segments(x[<span>5</span>], hc$height[<span>4</span>], midpoint[<span>3</span>], hc$height[<span>4</span>])<br>segments(midpoint[<span>3</span>], hc$height[<span>4</span>], midpoint[<span>3</span>], hc$height[<span>3</span>])<br>segments(x[<span>5</span>], <span>0</span>, x[<span>5</span>], hc$height[<span>4</span>])<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJnlr5IBoQXA9U3EECjaL67zhflwYYrRTBpnTRqWDLGmjUKgiaEvKhESg/640?wx_fmt=png" data-type="png" data-w="960" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJnlr5IBoQXA9U3EECjaL67zhflwYYrRTBpnTRqWDLGmjUKgiaEvKhESg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">Wunderbar！</p><p data-tool="mdnice编辑器">为了重复利用上面的代码，我们可以把它们放在一个函数中。这个函数<code>plot_hc()</code>很简单，其中四个<code>if-else</code>代码块处理下面四个不同的条件：</p><ul data-tool="mdnice编辑器"><li><section>两个子节点都是变量（或者叶节点）</section></li><li><section>左子节点是叶节点，右子节点是一个子树</section></li><li><section>左子节点是一个子树，右子节点是叶节点</section></li><li><section>两个子节点都是子树</section></li></ul><pre data-tool="mdnice编辑器"><code>plot_hc = <span>function</span>(hc) {<br>    x = order(hc$order)<br>    nobs = length(x)<br><br>    <span>if</span>(length(hc$labels) == <span>0</span>) {<br>        hc$labels = as.character(seq_along(hc$order))<br>    }<br><br>    plot(<span>NULL</span>, xlim = c(<span>0.5</span>, nobs + <span>0.5</span>), ylim = c(<span>0</span>, max(hc$height)*<span>1.1</span>), axes = <span>FALSE</span>, ann = <span>FALSE</span>)<br>    axis(side = <span>1</span>, at = <span>1</span>:nobs, labels = hc$labels[hc$order])<br>    axis(side = <span>2</span>)<br>        <br>    merge = hc$merge<br>    order = hc$order<br>    nr = nrow(merge)<br>    midpoint = numeric(nr)<br><br>    <span>for</span>(i <span>in</span> seq_len(nr)) {<br>        child1 = merge[i, <span>1</span>]<br>        child2 = merge[i, <span>2</span>]<br><br>        <span>if</span>(child1 &lt; <span>0</span> &amp;&amp; child2 &lt; <span>0</span>) { <span># both are leaves</span><br>            segments(x[ -child1 ], <br>                     hc$height[i],<br>                     x[ -child2 ], <br>                     hc$height[i])<br>            midpoint[i] = (x[ -child1 ] + x[ -child2 ])/<span>2</span><br>            segments(x[ -child1 ], hc$height[i], x[ -child1 ], <span>0</span>)<br>            segments(x[ -child2 ], hc$height[i], x[ -child2 ], <span>0</span>)<br>        } <span>else</span> <span>if</span>(child1 &lt; <span>0</span> &amp;&amp; child2 &gt; <span>0</span>) {<br>            segments(x[ -child1 ], <br>                     hc$height[i],<br>                     midpoint[ child2 ], <br>                     hc$height[i])<br>            midpoint[i] = (x[ -child1 ] + midpoint[ child2 ])/<span>2</span><br>            segments(x[ -child1 ], hc$height[i], x[ -child1 ], <span>0</span>)<br>            segments(midpoint[ child2 ], hc$height[i], midpoint[ child2 ], hc$height[ child2 ])<br>        } <span>else</span> <span>if</span>(merge[i, <span>1</span>] &gt; <span>0</span> &amp;&amp; merge[i, <span>2</span>] &lt; <span>0</span>) {<br>            segments(midpoint[ child1 ], <br>                     hc$height[i],<br>                     x[ -child2 ], <br>                     hc$height[i])<br>            midpoint[i] = (midpoint[ child1 ] + x[ -child2 ])/<span>2</span><br>            segments(midpoint[ child1 ], hc$height[i], midpoint[ child1 ], hc$height[ child1 ])<br>            segments(x[ -child2 ], hc$height[i], x[ -child2 ], <span>0</span>)<br>        } <span>else</span> {<br>            segments(midpoint[ child1 ], <br>                     hc$height[i],<br>                     midpoint[ child2 ], <br>                     hc$height[i])<br>            midpoint[i] = (midpoint[ child1 ] + midpoint[ child2 ])/<span>2</span><br>            segments(midpoint[ child1 ], hc$height[i], midpoint[ child1 ], hc$height[ child1 ])<br>            segments(midpoint[ child2 ], hc$height[i], midpoint[ child2 ], hc$height[ child2 ])<br>        }<br>    }<br>}<br></code></pre><p data-tool="mdnice编辑器">我们试一试这个函数：</p><pre data-tool="mdnice编辑器"><code>plot_hc(hc)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJnlr5IBoQXA9U3EECjaL67zhflwYYrRTBpnTRqWDLGmjUKgiaEvKhESg/640?wx_fmt=png" data-type="png" data-w="960" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJnlr5IBoQXA9U3EECjaL67zhflwYYrRTBpnTRqWDLGmjUKgiaEvKhESg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">或者试一个更大的聚类结果：</p><pre data-tool="mdnice编辑器"><code>m2 = matrix(rnorm(<span>1000</span>), nrow = <span>100</span>)<br>hc2 = hclust(dist(m2))<br>plot_hc(hc2)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.5" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJbXdwfKBtSq0jAjsE1W79vFfUVOJkGSWGv6VA98uxUfMMOHguDsDPIw/640?wx_fmt=png" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJbXdwfKBtSq0jAjsE1W79vFfUVOJkGSWGv6VA98uxUfMMOHguDsDPIw/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">到这里，通常我们会有很大的成就感。因为<code>plot_hc()</code>是基于一个微小的数据测试和编写的，现在居然在很大的数据上能够成功运行。</p><p data-tool="mdnice编辑器">给定一个父节点<code>(top_x, top_y)</code>，和两个子节点<code>(left_x, left_y)</code>，<code>(right_x, right_y)</code>，如何连接这三个点可以普遍化。</p><p data-tool="mdnice编辑器">默认的连接方式是连接下面四个点：</p><pre data-tool="mdnice编辑器"><code>x-coordinates: left_x, left_x, right_x, right_x<br>y-coordinates: left_y, top_y, top_y, right_y<br></code></pre><p data-tool="mdnice编辑器">在<code>plot_hc()</code>中，让我们将绘制父节点和子节点的代码抽象化。我们引入一个函数<code>parent_children_connections()</code>，其中我们可以自定义如何绘制连接方式。</p><pre data-tool="mdnice编辑器"><code>plot_hc = <span>function</span>(hc) {<br>    x = order(hc$order)<br>    nobs = length(x)<br><br>    <span>if</span>(length(hc$labels) == <span>0</span>) {<br>        hc$labels = as.character(seq_along(hc$order))<br>    }<br><br>    plot(<span>NULL</span>, xlim = c(<span>0.5</span>, nobs + <span>0.5</span>), ylim = c(<span>0</span>, max(hc$height)*<span>1.1</span>), axes = <span>FALSE</span>, ann = <span>FALSE</span>)<br>    axis(side = <span>1</span>, at = <span>1</span>:nobs, labels = hc$labels[hc$order])<br>    axis(side = <span>2</span>)<br>            <br>    merge = hc$merge<br>    order = hc$order<br>    height = hc$height<br>    nr = nrow(merge)<br>    midpoint = numeric(nr)<br><br>    <span>for</span>(i <span>in</span> seq_len(nr)) {<br>        child1 = merge[i, <span>1</span>]<br>        child2 = merge[i, <span>2</span>]<br><br>        <span>if</span>(child1 &lt; <span>0</span> &amp;&amp; child2 &lt; <span>0</span>) { <span># both are leaves</span><br>            midpoint[i] = (x[ -child1 ] + x[ -child2 ])/<span>2</span><br>            parent_children_connections(<br>                x[-child1], <span>0</span>,<br>                midpoint[i], height[i],<br>                x[-child2], <span>0</span><br>            )<br>        } <span>else</span> <span>if</span>(child1 &lt; <span>0</span> &amp;&amp; child2 &gt; <span>0</span>) {<br>            midpoint[i] = (x[ -child1 ] + midpoint[ child2 ])/<span>2</span><br>            parent_children_connections(<br>                x[-child1], <span>0</span>,<br>                midpoint[i], height[i],<br>                midpoint[child2], height[child2]<br>            )<br>        } <span>else</span> <span>if</span>(child1 &gt; <span>0</span> &amp;&amp; child2 &lt; <span>0</span>) {<br>            midpoint[i] = (midpoint[ child1 ] + x[ -child2 ])/<span>2</span><br>            parent_children_connections(<br>                midpoint[child1], height[child1],<br>                midpoint[i], height[i],<br>                x[-child2], <span>0</span><br>            )<br>        } <span>else</span> {<br>            midpoint[i] = (midpoint[ child1 ] + midpoint[ child2 ])/<span>2</span><br>            parent_children_connections(<br>                midpoint[child1], height[child1],<br>                midpoint[i], height[i],<br>                midpoint[child2], height[child2]<br>            )<br>        }<br>    }<br>}<br></code></pre><p data-tool="mdnice编辑器">下面是默认的连接父节点和两个子节点的方式：</p><pre data-tool="mdnice编辑器"><code>parent_children_connections = <span>function</span>(left_x, left_y, top_x, top_y, right_x, right_y) {<br>    lines(c(left_x, left_x, right_x, right_x),<br>          c(left_y, top_y, top_y, right_y))<br>}<br>plot_hc(hc)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJAAibvdUmia3YmKgMw2zq8FP9mz7KbibWqx9CibzowDO6onbW0oyuInTJyg/640?wx_fmt=png" data-type="png" data-w="960" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJAAibvdUmia3YmKgMw2zq8FP9mz7KbibWqx9CibzowDO6onbW0oyuInTJyg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">我们可以定义一个新的方式，让连接方式呈三角形状：</p><pre data-tool="mdnice编辑器"><code>x-coordinates: left_x, top_x, right_x<br>y-coordinates: left_y, top_y, right_y<br></code></pre><pre data-tool="mdnice编辑器"><code>parent_children_connections = <span>function</span>(left_x, left_y, top_x, top_y, right_x, right_y) {<br>    lines(c(left_x, top_x, right_x),<br>          c(left_y, top_y, right_y))<br>}<br>plot_hc(hc)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJHOvvtL3Yfa8Bal1nnPONWSGC6joib7u5kEcojuonIDH8gQFWpwwKDoQ/640?wx_fmt=png" data-type="png" data-w="960" src="https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibeIbXgI86912aicPPZOfBkWJHOvvtL3Yfa8Bal1nnPONWSGC6joib7u5kEcojuonIDH8gQFWpwwKDoQ/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">同理，你可以自定义<code>parent_children_connections()</code>来实现其他连接方式，例如使用贝泽尔曲线。</p><p data-tool="mdnice编辑器">在等级聚类中，每一个父节点有两个子节点。在下一篇文章中，我将介绍一个更加普适的格式：<code>dendrogram</code>。</p></section><p><br></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/tAKjcOiev4-zCAYx_3iTWg",target="_blank" rel="noopener noreferrer">原文链接</a>
