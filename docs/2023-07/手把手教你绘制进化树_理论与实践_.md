---
title: "手把手教你绘制进化树（理论与实践）"
date: 2023-07-13T03:48:50Z
draft: ["false"]
tags: [
  "fetched",
  "水瓶之翼"
]
categories: ["Acdemic"]
---
手把手教你绘制进化树（理论与实践） by 水瓶之翼
------
<div><section data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><br><p data-tool="mdnice编辑器">********<strong>目录</strong>*******</p><figure data-tool="mdnice编辑器"><img data-ratio="1.7817796610169492" data-type="png" data-w="472" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMJweNr1T8HwbHsgvmXdXJ9OweqeAicTkMgkTibRFSnreicTyad3AQn7iauw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMJweNr1T8HwbHsgvmXdXJ9OweqeAicTkMgkTibRFSnreicTyad3AQn7iauw/640?wx_fmt=png"></figure><h2 data-tool="mdnice编辑器"><span></span><span>目的</span><span></span></h2><p data-tool="mdnice编辑器">通过系统发育进化分析，确定目标序列与其它同源序列的演化关系、遗传距离远近，或者对细菌/病毒序列进行基因分型等。（本文分享的主要是基于编码区DNA的系统发育分析）</p><h2 data-tool="mdnice编辑器"><span></span><span>方法与过程</span><span></span></h2><ol data-tool="mdnice编辑器"><li><section><p>下载 MEGA 11.0 软件</p></section></li><li><section><p>使用 blast 确定序列同源性，下载目标序列</p></section></li><li><section><p>使用 MEGA 11.0 进行多序列比对</p></section></li><li><section><p>使用 MEGA 11.0 构建进化树</p></section></li><li><section><p>将进化树导出，使用R包 ggtree 进行可视化</p></section></li></ol><h2 data-tool="mdnice编辑器"><span>1. 软件下载</span></h2><p data-tool="mdnice编辑器">MEGA(Molecular Evolutionary Genetics Analysis)是一个开源软件，我们可以直接下载最新版用于windows系统的图形化界面(GUI)版 MEGA 11.0。</p><p data-tool="mdnice编辑器">MEGA 11 对大数据集的分析进行了优化，界面也更加美观，其它功能与 MEGA 7 没什么区别，当然你也可以两个版本都下载比较一下，windows上可以同时安装不同版本的MEGA。下载网址为：</p><pre data-tool="mdnice编辑器"><code>https://www.megasoftware.net/<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.4962962962962963" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM9c6n2icE2MMdB3gnxIUKRtdY8M166Guz4t8LYVTCKWNJCnbxJbzEtjg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM9c6n2icE2MMdB3gnxIUKRtdY8M166Guz4t8LYVTCKWNJCnbxJbzEtjg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">下载时需要匿名填一些信息，下载完直接按照提示安装即可。</p><h2 data-tool="mdnice编辑器"><span>2. 目标序列获取</span></h2><p data-tool="mdnice编辑器">一般来说，我们自己至少会有1条感兴趣的目标序列，其格式应该是 FASTA 格式。我这里举了个例子，是一个细菌序列的某个基因，第一行为<code>&gt;</code>开头，后面为该序列的注释信息，第二行之后的所有内容是该基因的核酸序列。</p><p data-tool="mdnice编辑器">如果你已经有自己准备好的序列就不需要进行目标序列获取这一步啦。</p><pre data-tool="mdnice编辑器"><code>&gt;CP000702.1:1005082-1006524 Thermotoga petrophila RKU-1, complete genome<br>ATGCCATCTGTGAAGATCGGTATCATCGGTGCGGGGAGCGCGGTGTTTTCTCTGAGGCTTGTGAGTGATC<br>TTTGCAAAACGCCGGGACTCTCTGGCAGCACGGTCACCCTCATGGATATCGACGAAGAAAGACTCGACGC<br>TGTTCTGACCATCGCGAAAAAATACGTTGAAGAAGTGGGAGCGGATCTGAAATTCGAAAAAACCATGAAT<br>TTAGATGACGTCATCATCGACGCGGATTTTGTGATAAACACAGCGATGGTGGGTGGCCATACCTACTTGG<br>AGAAAGTCAGACAGATCAGTGAGAAATACGGCTACTACAGAGGAATAGACGCTCAGGAGTTTAACATGGT<br>CTCCGACTACTACACCTTCTCCAACTACAACCAGCTCAAGTACTTCGTTGAAATAGCAAGGAAGATAGAG<br>AAGCTCTCCCCAAAAGCCTGGTACTTGCAGGCAGCGAATCCCGTTTTCGAAGGAACAACCCTTGTGACAA<br>GAACGGTTCCCATAAAGGCAGTGGGATTCTGCCATGGACACTACGGCGTGATGGAGATCGTAGAGAAACT<br>GGGGCTGGAAGAAGAAAAAGTAGATTGGCAGGTCGCAGGAGTGAACCACGGTATCTGGCTGAATAGGTTC<br>AGATACAACGGGGAGAACGCGTATCCCCTCCTTGACAGGTGGATCGAGGAAAAATCAAAAGATTGGAAAC<br>CAGAGAACCCCTTCAACGATCAGCTCTCTCCCGCTGCGATAGATATGTACAGATTCTACGGTGTGATGCC<br>CATCGGTGACACCGTGAGAAACTCTTCGTGGAGGTACCACAGGGATCTTGAGACCAAGAAGAAATGGTAC<br>GGTGAACCCTGGGGAGGAGCAGATTCTGAAATAGGCTGGAAATGGTACCAGGACACACTTGGAAAGGTAA<br>CGGAGATCACAAAGAAGGTGGCAAAGTTCATCAAAGAAAATCCGTCCGCGAGGCTCTCCGACCTTGGAAG<br>TGTTCTGGGAAAAGACCTCTCAGAAAAGCAGTTTGTGCTCGAAGTAGAGAAAATCCTCGATCCAGAAAGA<br>AAGAGTGGAGAGCAGCACATCCCATTCATCGATGCGCTGTTGAACGATAACAAGGCAAGATTCGTGGTGA<br>ACATACCAAATAGGGGTATCATCCACGGAATAGACGATGACGTGGTCGTTGAAATCCCAGCCCTTGTGGA<br>CAAGAACGGAATCCATCCCGAGAAGATCGAACCACCGCTTCCAGATCGCGTGGTCAAGTACTACCTGAGA<br>CCAAGGATCATGAGAATGGAAATGGCTCTGGAGGCGTTCCTCACGGGGGACATAAGGATCATAAAAGAAC<br>TTCTCTACAGAGATCCAAGAACGAAGAACGACGAACAGGTAGAAAAGGTGATCGAGGAAATCCTCGCACT<br>CTCGGAAAACGAAGAGATGCGGAAACATTATCTGAAGAGATGA<br></code></pre><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">这里需要注意一个概念，我们用于进化分析的所有序列理论上应该都是同源的，所以并不是说随便下载几条序列都可以进行进化分析的。有些序列比对后仅仅能证明它们相似而不一定能证明它们同源，而 NCBI的blast工具就可以进行显著性检验，帮助我们判断序列同源的可靠性。</p><blockquote data-tool="mdnice编辑器"><p>需要区分<strong>同源</strong>与<strong>相似</strong>的概念。</p><p>如果两个序列享有一个共同的进化上的祖先,则这两个序列是同源(homologous)的。对这个定义需要注意的一点是，同源是个定性的概念，没有“度”的差异。对两个序列，它们或者同源或者不同源，不能说它们70%同源或80%同源。</p><p>与同源相关但不同的两个概念是相似(similarity)和相同(identity)，它们都是定量的概念，基于对序列中字符的精确比较，既可以说两个核酸序列高度相似，也可以说它们 70% 的碱基相同。</p></blockquote><h3 data-tool="mdnice编辑器"><span>2.1 blast获取同源序列</span></h3><ol data-tool="mdnice编辑器"><li><section><span><strong>进入ncbi在线网站</strong></span> -&gt; 点击右侧的blast -&gt; 选择 Nucleotide BLAST -&gt; 将前面的序列复制进去，其它参数默认即可 -&gt; 然后点击下方的 BLAST，等待比对结果。</section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="0.799074074074074" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMVlwaBN58xyWPPfzKsTu05aeatQdDwibU60Y9q7ldW4mwibvWriakz860g/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMVlwaBN58xyWPPfzKsTu05aeatQdDwibU60Y9q7ldW4mwibvWriakz860g/640?wx_fmt=png"></figure><ol start="2" data-tool="mdnice编辑器"><li><section><p><strong>比对结果的解释</strong><span data-change-font="1">​ </span><span data-change-font="1">：</span></p></section>blast 把我们输入的序列称为 query 序列，数据库中与之比对的序列称为 subject 序列。</li></ol><ul data-tool="mdnice编辑器"><li><section><p>Description 列，是对当前 subject 序列的简短介绍，它还有一个链接，鼠标左键点击它即可通往该序列比对的结果页面；</p></section></li><li><section><p>Scientific Name 列，不是我们关注的重点；</p></section></li><li><section><p>Max Score 列，代表比对到 subject 序列的片段的最高评分（因为 blast 比对时是将待比对序列拆分成一系列片段去与subject序列进行比对的）；Total Score 列，同理，即所有比对片段的评分之和。这两个评分越高，代表两个序列越相近；</p></section></li><li><section><p>Query Cover 列，代表与 query 序列的全长相比，有多少比例的 query 序列与 subject 序列能比对上（即序列比对时能覆盖到的比例）；</p></section></li><li><section><p>E value 列，即期望值。是 blast 软件进行统计显著性计算得到的值，E值越接近0，代表该 subject 序列越有可能与 query 序列同源；</p></section></li><li><section><p>Per.Ident 列，即两个序列能比对上的部分完全相同的碱基的比例；</p></section></li><li><section><p>Acc.Len 列，即 subject 序列的原始长度；Accession 列表明了 subject 序列的在 genbank 上的登录号。</p></section></li></ul><figure data-tool="mdnice编辑器"><img data-ratio="0.3814814814814815" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMSz1DFYHUkNCX77DqYFib3lY4icialbYy41ZiaZLshkfSlbX4OcWuHrmkHw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMSz1DFYHUkNCX77DqYFib3lY4icialbYy41ZiaZLshkfSlbX4OcWuHrmkHw/640?wx_fmt=png"></figure><ol start="3" data-tool="mdnice编辑器"><li><section><p><strong><span>序列同源性判断与下载</span>：</strong></p><p>我们点击 Description 列的第一条序列，可以通往比对结果的链接。</p></section></li></ol><ul data-tool="mdnice编辑器"><li><section><p>先看下图中红色方块中的内容，Score/Expect/Identities 与前面的一致（identities可以检查比对的序列是否有失配，包括插入缺失以及碱基的替换）；</p><p>Gaps代表空格数（序列比对时如果有插入/缺失，blast会通过插入空格来使序列对齐）；</p><p>Strand代表 query 序列与 subject 序列的方向，其中</p><p>Plus/Plus 代表 subject 序列与 query序列是同向的，Plus/Minus则代表是反向的。</p></section></li><li><section><p>绿色方块中显示了具体的比对情况，有gap的位置会通过<code>-</code>表示。</p></section></li><li><section><p>接着我们要判读该 subject 序列是不是可以下载下来作为我们进化分析的同源序列。事实上并没有一个严格的标准来界定序列是否同源，有文献把 Query Cover&gt;=60%，E value &lt;1e-3 的序列作为区分是否同源的依据，也有文献选择 E value &lt;1e-5，所以需要我们根据自己的研究领域进行判断，如果符合我们的要求，就可以认为比对得到的这条 subject 序列与我们的 query 序列同源，就可以下载下来用于进化分析了。</p></section></li><li><section><p>在本例中(Query Cover=100%，Strand=Plus/Plus)，直接点击粉色方块中的 Download -&gt; 选择 FASTA(aligned sequences)可以直接下载到完整的subject序列。</p></section></li></ul><figure data-tool="mdnice编辑器"><img data-ratio="0.8444444444444444" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMXyAia9rcTKy9wIpcHicq0kP2bzkJ1bic6YpRTAh6RSLkxiaA2Avpwrdwibg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMXyAia9rcTKy9wIpcHicq0kP2bzkJ1bic6YpRTAh6RSLkxiaA2Avpwrdwibg/640?wx_fmt=png"></figure><ul data-tool="mdnice编辑器"><li><section><p>当 Query Cover &lt; 100%，或者 Strand=Plus/Minus。比如我们比对到的下图中这条 subject序列，它的序列其实和我们输入的序列是反向互补的，如果直接点击 Download 其实下载的是反向互补的序列，如果我们没注意的话后面比对结果会不准确。</p><p><strong>因此</strong>我们点击下面蓝色方块中的 Genbank 链接，会进入一个新的窗口（下图2），然后在右侧的 Customize view 中勾选 Show reverse complement，接着点击 Update View即可。</p><p><strong>接着</strong>可以再手动确认一下更新的序列前几位是否与我们的 query 序列一致，然后即可下载这条 subject 序列，点击上方的 Send to 下载 FASTA 文件（下图3）</p></section></li></ul><figure data-tool="mdnice编辑器"><img data-ratio="0.39351851851851855" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMGlS5RMpJlSepBmSUiapX5u6d5NRR15y8JjYJC3K5zJj1jRGUP7D9ZKA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMGlS5RMpJlSepBmSUiapX5u6d5NRR15y8JjYJC3K5zJj1jRGUP7D9ZKA/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="0.4537037037037037" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMPibtg4jjeg5du5XLMpDYEeaayu9xwbA7CmIVY6icyDzMfXpzleOe63Jg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMPibtg4jjeg5du5XLMpDYEeaayu9xwbA7CmIVY6icyDzMfXpzleOe63Jg/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="0.5324074074074074" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMIrOEWYCxoNNRNHDCM4TURT3vg7zryJCSe1sWJq3EanUicosrcS1qmLg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMIrOEWYCxoNNRNHDCM4TURT3vg7zryJCSe1sWJq3EanUicosrcS1qmLg/640?wx_fmt=png"></figure><hr><p data-tool="mdnice编辑器"><span><strong>总结：</strong></span></p><p data-tool="mdnice编辑器">这样一条条序列检查是否同源，是否同向，然后下载是比较稳妥的方法，不会出错，但是序列多了就会比较浪费时间，我们也可以直接在比对页面直接选择多个序列批量下载 FASTA 文件(如下图所示)，但是下载后<strong>一定要注意</strong>有些序列与我们的 query 序列是反向互补的，需要将其反向互补后重新整合才能用于后面的序列比对（不过之后用MEGA也可以对序列进行反向互补操作）。</p><figure data-tool="mdnice编辑器"><img data-ratio="0.5324074074074074" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM00s0HGkyukwibLqDvQMqWN6RMUwSod2aud6o8A7EmnyT63HtF6QOEkA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM00s0HGkyukwibLqDvQMqWN6RMUwSod2aud6o8A7EmnyT63HtF6QOEkA/640?wx_fmt=png"></figure><h3 data-tool="mdnice编辑器"><span>2.2 自己判断序列同源性</span></h3><p data-tool="mdnice编辑器">还有一种情况是我们自己知道下载的序列一定是同源的，比如下载某个病毒不同毒株的某个基因序列，就没有必要通过 blast 等软件检查序列是否同源。</p><p data-tool="mdnice编辑器">比如我在 NCBI 的 Nucleotide 数据库中检索 PRRSV 病毒的 ORF5基因，如下图所示，然后下载其中一些序列用于进化分析，勾选想要的序列后还是和前面一样点击 Send to 下载 FASTA 文件即可。</p><figure data-tool="mdnice编辑器"><img data-ratio="0.49444444444444446" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMgt6N3XdCiaoxg4vu3G1WQXKE5VbRVKhO1yYKV9bXAB9xO39NZdBQGmQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMgt6N3XdCiaoxg4vu3G1WQXKE5VbRVKhO1yYKV9bXAB9xO39NZdBQGmQ/640?wx_fmt=png"></figure><h3 data-tool="mdnice编辑器"><span>2.3 序列检查</span></h3><p data-tool="mdnice编辑器">不管我们是如何获取到的序列，在将其用于比对之前一般应确保以下原则（1）尽量保证序列完整，既没有缺失也没有多余（2）用于进化分析的序列应同源（3）序列的方向应一致。</p><p data-tool="mdnice编辑器">如果我们选择的是某个基因全长或者CDs序列(即编码序列)这种会比较好检查。获取到所有序列后一般将所有序列整合到一个FASTA文件中，接着推荐使用 Sublime 软件直接打开 FASTA 文件，可以方便地对序列进行批量检查。检查的方式可以根据我们的序列特征进行，比如下面几种方法：</p><ol data-tool="mdnice编辑器"><li><section><p><span><strong>检查</strong></span><strong><code>&gt;</code></strong><span><strong>的数量</strong></span><strong>。</strong></p><p>因为1条序列由1个<code>&gt;</code>开头，<code>&gt;</code>的数量应与我们实际需要比对的序列数量一致。比如我这次需要比对18条序列，在 Sublime 中按 <code>Ctrl</code> + <code>F</code>进入搜索模式，然后搜索<code>&gt;</code>，如下图所示，此时左下角会出现文档中的<code>&gt;</code>的数量(绿色方框所示)，显示18个即说明序列数量正确。</p></section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="0.6472222222222223" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMzDjtv72Lr32P4Lxia86SBmicrvdfQ2uJPO0ibic75Dt6ueYUHK7ibndgQXg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMzDjtv72Lr32P4Lxia86SBmicrvdfQ2uJPO0ibic75Dt6ueYUHK7ibndgQXg/640?wx_fmt=png"></figure><ol start="2" data-tool="mdnice编辑器"><li><section><p><span><strong>检查序列方向</strong></span><strong>。</strong>针对我感兴趣的序列，因为我要比对的这18条序列都是CDs序列，因此大部分的序列应该都是以 ATG 起始密码子起始（有些物种可能出现GTG），我们不能直接搜索以ATG开头的行，这样会与序列中间的以ATG开头的行混淆。<span>再仔细</span>看一下这些序列，发现都是<code>&gt;</code>所在的行以1个数字结尾，然后另起一行以ATG开头，我们通过精确匹配就能准确搜索到所有以ATG开始的序列。</p><p><span>在 Sublime 中</span>按 <code>Ctrl</code> + <code>F</code>进入搜索模式，如下图所示，点击下方最左侧的正则表达式搜索，搜索式为<code>[1-9]\nATG</code>，此时左下角显示18个即说明序列方向应该正确。（该搜索式中，<code>[1-9]</code>代表第1个字符匹配1-9之间的所有数字，<code>\n</code>代表换行符）</p></section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="0.5342592592592592" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMdtP9VnlbLuMDbWPxibichtP73Dhgo3e61N7gv7LB7XwaIwdlrklIc4BQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMdtP9VnlbLuMDbWPxibichtP73Dhgo3e61N7gv7LB7XwaIwdlrklIc4BQ/640?wx_fmt=png"></figure><ol start="3" data-tool="mdnice编辑器"><li><section><strong>同样的</strong>，我用表达式<code>TAG\n\n</code>搜索时，发现所有18条序列都是以TAG结尾（终止密码子一般是 TAA、TAG、TGA）,因此可以确认我的所有序列都是完整的，且方向也是对的。</section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="0.7287037037037037" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMZH8I7qOWicicwxz1azsGWTgxu0tsFQE99KZBLlM5jfdYU3kzPZaBpianA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMZH8I7qOWicicwxz1azsGWTgxu0tsFQE99KZBLlM5jfdYU3kzPZaBpianA/640?wx_fmt=png"></figure><ol start="4" data-tool="mdnice编辑器"><li><section><p><span><strong>批量修改注释行</strong></span>，一般从genbank上下载下来的序列<code>&gt;</code>所在的行不会像我的例子中这么干净，一般会有一串信息。<span>因为</span>之后构建进化树的时候软件一般会默认使用<code>&gt;</code>后面的信息给树中的序列命名，所以我们可以提前用 Sublime 进行批量整理。</p><p>在下面的例子中，如果我们想只保留<code>&gt;</code>后面的 genbank登录号，只需要搜索<code>:</code>，然后点击右侧的 Find All，此时光标会出现在所有匹配的<code>:</code>上，此时想批量删除<code>:</code>右侧的信息，只需要按<code>Fn</code>+<code>Shift</code>+右方向键选中，然后按退格键删除即可。</p></section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="0.39537037037037037" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMhicgg9YPBMCFrTKibiajd3ibxZ1uuwkJQVH3mNZ1iaUsKs8JnwKRHoTzRlw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMhicgg9YPBMCFrTKibiajd3ibxZ1uuwkJQVH3mNZ1iaUsKs8JnwKRHoTzRlw/640?wx_fmt=png"></figure><hr><p data-tool="mdnice编辑器"><span><strong>总结：</strong></span></p><p data-tool="mdnice编辑器">前面的序列检查方法并不唯一，针对我们自己的序列特征可以进行不同的检查（比如还可以检查文档的行数，如果1个基因序列一般都占10行的话，20条序列应该就是200行，Sublime中左侧显示了行数，可以防止下载成了别的基因）。总之，其主要目的都是为了确保所有序列的方向一致，所有序列同源且完整。</p><h2 data-tool="mdnice编辑器"><span>3. 使用 MEGA 进行多序列比对</span></h2><h3 data-tool="mdnice编辑器"><span>3.1 导入待比对的 fasta 序列</span></h3><p data-tool="mdnice编辑器">依次点击：ALIGN -&gt; Edit/Build Alignment -&gt; Retrieve a sequence from a file -&gt; OK -&gt; 选择我们前面整理好的fasta文件 -&gt; 出现 Alignment Explorer 窗口：</p><figure data-tool="mdnice编辑器"><img data-ratio="0.8925925925925926" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM5rj9ddE8OR6Nl7IKmmGrPzWs51r1o5ANgRnw3ciaIO0eSzBU6xmutvg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM5rj9ddE8OR6Nl7IKmmGrPzWs51r1o5ANgRnw3ciaIO0eSzBU6xmutvg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">	导入序列后如下图所示：（这时如果想更改某条序列的名称可以在该原名字处右键选中 Edit Sequence Name编辑）</p><figure data-tool="mdnice编辑器"><img data-ratio="0.3611111111111111" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMsHc4oh1ErCuq6UBzoC4sfMtZsribUTOodo7svoCibic6hzgja1B0tbCGw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMsHc4oh1ErCuq6UBzoC4sfMtZsribUTOodo7svoCibic6hzgja1B0tbCGw/640?wx_fmt=png"></figure><h3 data-tool="mdnice编辑器"></h3><span data-change-font="1">​导入后我们还是可以检查一下序列，这时候如果存在两端有多余碱基的序列，可以很容易检查发现。在MEGA中可以进行序列裁剪、更改、方向互补等操作。如果我们没有进行步骤2.3的检查，导入MEGA后再检查也是一样的，序列的方向是其中最重要的一点，不能与其它序列反向。</span><h3 data-tool="mdnice编辑器"><span>3.2 多序列比对</span></h3><p data-tool="mdnice编辑器">MEGA提供了两种序列比对方法，Clustal W 与 MUSCLE ，有文献报道 MUSCLE 的准确性更高，且速度比Clustal W 更快，因此这里我们直接使用 MUSCLE 进行多序列比对演示。</p><p data-tool="mdnice编辑器">按<code>Ctrl</code> + <code>A</code>选中所有序列 -&gt; 点击 Alignment -&gt; 选择 Align by MUSCLE -&gt; 参数设置界面直接点击 OK 即可，一般不需要更改参数。（如果用Clustal W 进行<span>核酸序列</span>比对的话一般也不需要修改参数）</p><p data-tool="mdnice编辑器"><strong>比对后结果</strong>：</p><figure data-tool="mdnice编辑器"><img data-ratio="0.3287037037037037" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMKJUVh9oHN8fsz19nzzkibXBj8bswyJ9jf5utGAKT3ryEBKsAY0vAibvg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMKJUVh9oHN8fsz19nzzkibXBj8bswyJ9jf5utGAKT3ryEBKsAY0vAibvg/640?wx_fmt=png"></figure><h3 data-tool="mdnice编辑器"><span>3.3 保存比对结果</span></h3><p data-tool="mdnice编辑器">依次点击 Data -&gt; Export Alignment -&gt; MEGA Format，然后保存为<code>.meg</code>格式的文件即可（保存时会提示输入标题以及是否是编码序列），我这里命名为<code>example.meg</code>。<span>另外</span>我们这里也可以另外保存一份 FASTA格式的文件用于我们最后一步的可视化（我这里命名为<code>example.fas</code>）。</p><figure data-tool="mdnice编辑器"><img data-ratio="0.8680851063829788" data-type="png" data-w="940" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMIclqevfNNDqNwaoibvlXAY3R6LicDyxLxuiadHxhib56icZv9PkCxzGCo2w/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMIclqevfNNDqNwaoibvlXAY3R6LicDyxLxuiadHxhib56icZv9PkCxzGCo2w/640?wx_fmt=png"></figure><h3 data-tool="mdnice编辑器"><span>3.4 比对结果可靠性检验</span></h3><ol data-tool="mdnice编辑器"><li><section><p><strong>首先</strong>，我们可以大致看一下比对之后有没有异常序列，如果发现比对后存在明显与其它序列不同的序列，可以用MEGA进行相应编辑或者考虑删除后重新比对。</p></section></li><li><section><p><strong>其次可以检验比对结果的可靠性。</strong></p><p>如果比对结果不可靠，那么构建的进化树也会不可靠。Thompson等人（1999）的一项研究比较了一些比对程序，表明当配对比对中氨基酸一致性(identity)的平均百分比太低时，多重比对的准确性低于它们能够产生可靠的系统发育树的水平。Thompson的研究表明，当氨基酸平均identity&lt;20%时，则&lt;50%的残基是被正确比对的。在20%-30% identity 之间的“过渡带”中，约80%的残基正确对齐，&gt;30%的identity中，90%的残基正确比对。</p><p><strong>因此</strong>我们可以通过计算序列之间的 p 距离(p-distance)来检验核酸或氨基酸比对的可靠性。比如在氨基酸比对中， p-distance 值为 0.6，代表氨基酸平均 identity为 1-0.6=40%，如前所述，氨基酸的 identity 一般需要 &gt;30% 才比较可信(即 p-distance&lt;0.7)，因此当 p-distance=0.6时，我们可以认为氨基酸的比对结果是比较可靠的。</p><p><strong>对于</strong>核酸来说，检验方法类似，假如 p-distance 为 0.33，则 67% 的 identity 就可能不足以用于准确估计进化关系。p-distance&lt;0.33 一般被认为结果比较可靠。</p><p><strong>一般</strong>来说，假如核酸序列或者氨基酸序列的 p-distance 较高时，不应将多序列比对的结果用于构建进化树，而是应该删除其中不可靠的序列后重新比对，使得核酸序列或者氨基酸序列的 p-distance 满足 核酸：&lt;0.33/氨基酸：&lt;0.7。</p></section></li></ol><ul><li><section>在 MEGA 中依次点击：DISTANCE -&gt; Compute Overall Mean Distance -&gt; 选择前面导出的比对完的 <code>.meg</code> 文件：</section></li></ul><figure data-tool="mdnice编辑器"><img data-ratio="0.47129629629629627" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMfg3ThfahTgdaje4kT7K1g37faia1k1iayGVdwnfNfia2IXfIRAPU1jgkA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMfg3ThfahTgdaje4kT7K1g37faia1k1iayGVdwnfNfia2IXfIRAPU1jgkA/640?wx_fmt=png"></figure><pre data-tool="mdnice编辑器"></pre><ul><li><section>然后按照下图进行参数设置：</section></li></ul><code><br></code><figure data-tool="mdnice编辑器"><img data-ratio="1.0880149812734083" data-type="png" data-w="1068" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMHrJmM0xES1UMVxPicSchLwWLRJhQkJSxHia6AiaFUKYhtstYGyr0POurQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMHrJmM0xES1UMVxPicSchLwWLRJhQkJSxHia6AiaFUKYhtstYGyr0POurQ/640?wx_fmt=png"></figure><pre data-tool="mdnice编辑器"></pre><ul><li><section>点击OK后，可以得到 1 个平均 p-distance，</section></li><li><span><section></section>本例中是0.26&lt;0.33，因此我们可以认为</span></li><li><span>本次比对结果比较可靠。</span></li></ul><code><span></span></code><code><br></code><figure data-tool="mdnice编辑器"><img data-ratio="0.40234375" data-type="png" data-w="1024" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMtgWoKSZaFdoj8chicNCEedI8vqRumPRgbH1PylOZ3EIelV8XxA3bzqQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMtgWoKSZaFdoj8chicNCEedI8vqRumPRgbH1PylOZ3EIelV8XxA3bzqQ/640?wx_fmt=png"></figure><hr><p data-tool="mdnice编辑器"></p><p data-tool="mdnice编辑器"><span><strong>总结：</strong></span></p><p data-tool="mdnice编辑器">比对方法以及比对可靠性的检验方法有很多种，上面只是介绍了其中一种。比如 MAFFT、PRANK等比对方法就被认为准确性比较高，有文献报道 MAFFT准确性比Clustal W高、速度也更快，PRANK准确性被认为比MAFFT与Clustal W都高，但速度却相对较慢。大家在实际比对时可以尝试多种方法，并在准确性与速度方面进行一定的权衡。</p><h2 data-tool="mdnice编辑器"><span>4. 构建进化树</span></h2><p data-tool="mdnice编辑器"><strong>构建进化树的方法</strong>主要可以分为两类</p><ol data-tool="mdnice编辑器"><li><section><p><strong>基于距离的方法</strong>，基于所计算出的序列间遗传距离来构建进化树，快速，会产生单一的树。</p></section></li></ol><ul><li><section>邻接法：Neihbor Jioning(NJ)</section></li><li><section>非加权分组平均法(UPGMA)</section></li></ul><li><section><p><strong>基于字符的方法</strong>，基于描述遗传字符演化的数学模型构建进化树，速度较慢，会产生多棵树，然后根据其最优选择标准来找出最佳进化树。</p></section></li><ul><li><section>最大简约法(Maximum Parsimony,MP)</section></li><li><section>最大似然法(Maximum Likelihood,ML)</section></li><li><section>贝叶斯马尔科夫链蒙特卡洛法(BMCMC)</section></li></ul><p data-tool="mdnice编辑器">根据《phylogenetic trees made easy》作者所述，MEGA是构建NJ树最好的程序，且其强烈反对使用UPGMA法构建系统发育树。</p><h3 data-tool="mdnice编辑器"><span>4.1 构建 NJ 树</span></h3><p data-tool="mdnice编辑器">邻接法：Neihbor Jioning(NJ)是使用得最广泛的其中一种方法。我们使用MEGA根据前面的比对结果构建NJ树。</p><p data-tool="mdnice编辑器"><span><strong>邻接法基本介绍：</strong></span></p><p data-tool="mdnice编辑器">邻接法是一种基于最小进化原理的算法，基于距离矩阵构建树，它不检验所有可能的拓扑结构，能同时给出拓扑结构和分支长度。它的优点是重建的树相对准确，假设少，计算速度快，只得到一棵树。</p><p data-tool="mdnice编辑器">NJ树适用于进化距离较小、信息位点较少的短序列，可用于大型数据集（速度很快）。其缺点主要表现在将序列上的所有位点等同对待，所分析序列的进化距离不能太大（对于距离过远的序列会出现长枝吸引现象）。</p><h4 data-tool="mdnice编辑器"><span>4.1.1 检验是否适合构建NJ树</span></h4><p data-tool="mdnice编辑器">假如 Jukes-Cantor(JC)距离 &gt;1.0，则序列不适合构建NJ树，而应采用其它方法。</p><p data-tool="mdnice编辑器">我们采用与 3.4 相同的步骤，在 MEGA 中依次点击：DISTANCE -&gt; Compute Overall Mean Distance -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件，然后在参数设置中将 Model/Method 改为 Jukes-Cantor 即可计算出 JC 距离。</p><figure data-tool="mdnice编辑器"><img data-ratio="1.0892857142857142" data-type="png" data-w="1064" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMiar62jWdT9JQFMmQof9boHKYdbiaJSH5swUI8XDCicpJicibP6btqKAib7sQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMiar62jWdT9JQFMmQof9boHKYdbiaJSH5swUI8XDCicpJicibP6btqKAib7sQ/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">在本例中计算出的 JC 距离为 0.34，因此我们认为适合构建 NJ 树。</p><h4 data-tool="mdnice编辑器"><span>4.1.2 NJ 树的估计-理论</span></h4><blockquote data-tool="mdnice编辑器"><p>为什么说是估计，类似于模型构建，因为事实上我们永远无法得到真实的物种演化的系统发育树，我们所谓的构建进化树只是在用各种算法尝试得到最接近真实进化树的一颗树。</p></blockquote><p data-tool="mdnice编辑器"><strong>我们</strong>估计进化树时一般会估计多次，<span>首先</span>是在没有 Bootstrap 的情况下先估计得到一颗树，初步查看是否有明显异常的序列被异常分类到某个子树中（关于什么是 Bootstrap 后面会介绍）。如果有这种情况应对序列进行检查，必要时还需要删除某些序列，然后重新进行多序列比对，再重新估计树。当我们认为树中没有异常序列时，再设置 Bootstrap 次数（一般为1000以上，至少100），估计最终的树。</p><p data-tool="mdnice编辑器"><strong>对于</strong>最大似然法，这样估计树可以节约很多时间，因为最大似然法设置 Bootstrap 后速度会非常慢，对于 NJ 法，在序列不多的情况下（只有数百条），可以直接设置 Bootstrap，因为 NJ 法速度很快。</p><p data-tool="mdnice编辑器">在 MEGA中依次点击：PHYLOGENY -&gt; Construct/Test Neighbor Joining Tree -&gt; 设置参数，我们可以先看一下参数设计界面的各个参数。</p><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">估计 NJ 树时各参数的意义与设置：</p><ul data-tool="mdnice编辑器"><li><section>Test of Phylogeny：进化树的检验设置，我们可以根据前面说的设置为None，表明不检验（速度快），也可以设置为 Bootstrap method，然后在下面的 No.of Bootstrap Replications 设置检验次数，关于 Bootstrap 的介绍可见后面备注3。</section></li><li><section>Substitutions Type：本文只介绍比对核酸序列构建进化树，因此直接选择默认的 Nucleotide。</section></li><li><section>Model/Method：进化模型。我们这里选择 Maximum Composite Likelihood，算法原理在后面备注1中介绍。</section></li><li><section>Substitution to include：选择哪些替代类型用于计算，一般不需要改。transition 代表转换，嘌呤之间或者嘧啶之间，如 A&lt;-&gt;G,C&lt;-&gt;T；transversion 颠换，嘌呤与嘧啶之间，如A&lt;-&gt;C/T,G&lt;-&gt;C/T</section></li><li><section>Rates among Sites ：位点之间的替换率分布。我们这里选择Gamma Distributed (G)，在 Gamma Parmamter中填的参数值可以通过MEGA计算得到。关于 Rates 的介绍可见后面备注2</section></li><li><section>Patterns among Lineages 默认即可，我们一般比对的都是同源序列。</section></li><li><section>Gaps/Missing Data Treatment：该参数设置如何处理空格(gaps)。几乎完全由空格组成的位点对估计树中的分支顺序或分支长度的贡献很小，但它们确实增加了计算时间。Complete deletion，代表直接删除所有包含gap的位点。Pairwise deletion代表配对删除，从而使缺少数据的位点仅在需要时被删除而不是总被删除。Partial deletion 代表部分删除，当 Site Coverage Cutoff设置为95%时，代表如果有95%的序列在此位点上是空格，则将该位点删除。</section></li><li><section>Select Condon Positions: 代表选择密码子的哪些位点来构建树，通常全选。除非你有特殊的需求，如只想根据密码子的第三位碱基构建进化树。</section></li><li><section>Number of threads：代表分析时电脑的线程数设置，根据自己的电脑情况可随意设置。</section></li></ul><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器"><span><strong>备注1 进化模型</strong></span></p><p data-tool="mdnice编辑器">在祖先序列进化为子序列的过程中，如果仅仅计算两个核苷酸之间的距离是不够的，比如某个位点由 A 替换成了 T，我们假设计算出的它们之间的距离是0.5，然而我们无法知道这中间是否发生了其它变化，比如可能先由 A 替换成 G，接着再从 G 替换成 T，这与 A 直接替换成 T 的替换率显然是不同的。又或者某个位点未发生替换，我们计算出的它们的距离为0，然而它中间也有可能经过了其它替换，比如A-&gt;G-&gt;A。因此我们需要选择进化模型来试图解释这些替换，以更准确地估计序列进化的过程。</p><ol data-tool="mdnice编辑器"><li><section><p><strong>单参数模型：</strong></p><p>在单参数模型中，碱基替换可以通过以下矩阵表示，称之为Q矩阵，只有一种核酸替换率 α。</p></section></li></ol><ul><li><section>Jukes-Cantor model(JC)：该模型认为任何核苷酸改变为其它核苷酸的几率是相等的，只需要知道核苷酸替换率即可，因此称为 one-parameter model 或者 Jukes-Cantor model</section></li><li><section>Felsenstein 81 (F81)模型拓展了 Jukes-Cantor model，允许碱基替换的基础替换率不同。</section></li></ul><figure data-tool="mdnice编辑器"><img data-ratio="0.4226086956521739" data-type="png" data-w="575" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMC0oicHfKP0nV7CSZzCJy4gIHibTibyDehUAa8ic1puhz5cPR0iche8HvBGA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMC0oicHfKP0nV7CSZzCJy4gIHibTibyDehUAa8ic1puhz5cPR0iche8HvBGA/640?wx_fmt=png"></figure><ol start="2" data-tool="mdnice编辑器"><li><section><p><strong>其它模型：</strong></p><p>然而每种核苷酸的替换几率往往是不一样的</p></section></li></ol><ul><li><section><p>Kimura 2-parameter model(K2P) 拓展了Jukes-Cantor model，考虑核苷酸转换和颠换的替换率不一样。K2P模型假设 Q矩阵中有两种替换率，转换一种，颠换一种。</p><p>因此，K2P的Q矩阵如下，转换的替换率为α，颠换的替换率为b</p></section></li></ul><figure data-tool="mdnice编辑器"><img data-ratio="0.2634920634920635" data-type="png" data-w="630" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM2lhuFZP8zBVOD648mibeLZdjSibrspKVlYnibvtNe8nl9kn3lxFicIQIng/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM2lhuFZP8zBVOD648mibeLZdjSibrspKVlYnibvtNe8nl9kn3lxFicIQIng/640?wx_fmt=png"></figure><ul data-tool="mdnice编辑器"><li><section><p>Tamura 3-parameter model 添加了对成分偏差的修正，如果基础比率与相同频率有很大差异，可能是由于突变偏差，那么就需要考虑这种差异</p></section></li><li><section><p>Tamura-Nei model 延伸了前一个模型，把嘌呤之间的的转换和嘧啶之间的颠换的替换率进行了区分。</p></section></li><li><section><p>Felsenstein 84 (F84) model 和 HKY model也基于类似 Tamura-Nei model的假设</p></section></li><li><section><p>Maximum Composite Likelihood model 是一种基于似然性的 Tamura-Nei model的应用，提高了计算配对距离(pairse distance)的精确度</p></section></li><li><section><p>General Time-Reversible(GTR) model。该模型假设 Q矩阵有6种不同的率，认为碱基不同方向的替换概率相同(即A-&gt;C与C-&gt;A的替换率相同)。</p></section></li></ul><p data-tool="mdnice编辑器"><span>总的来说</span>，Kimura 2-parameter 与 Maximum Composite Likelihood 模型是目前构建NJ树时文献中用得比较多的模型。</p><p data-tool="mdnice编辑器"><span><strong>备注2 位点之间的替换率</strong></span></p><p data-tool="mdnice编辑器">前面的进化模型中所说的碱基替换率指的是某个位点的碱基替换为其它碱基的频率（考察的是单个位点的碱基替换），这些模型假设所有位点的碱基替换率都是一样的，但实际上，不同位点的替换率可能会不同，比如编码序列的起始密码子处，通常为ATG（有时也为GTG），因此我们可以推测起始密码子处2，3位点的碱基替换率是0。</p><p data-tool="mdnice编辑器"><span>因此</span>引入了序列中估计不同位点之间替换率的方法。Uniform Rates 假设不同位点之间的碱基替换率是相同的。<span>还有</span>一种假设是不同位点的碱基替换率的分布存在一种普遍的模式，常用的分布是伽马分布(Gamma distribution)，我们可以使用MEGA预测Gamma分布的参数。</p><p data-tool="mdnice编辑器"><span><strong>备注3 进化树的可靠性检验</strong></span></p><p data-tool="mdnice编辑器">前面已经提过，事实上我们估计的所有树都是错误的，只是通过模型算法尽量找到一颗最接近真实的树。因此我们需要一种方法来评估通过这些模型构建出来的树的可靠性。其中 Bootstrap 方法是使用得最广泛的一种，NJ、ML等方法都使用 Bootstrap 检验进化树的可靠性，不过 BMCMC 通过进化枝后验概率计算树的可靠性。<span>需要注意</span>的是 Bootstrap 评估的是我们估计树的可重现性，而非树的准确性。</p><p data-tool="mdnice编辑器"><span>下面</span>介绍 Bootstrap 的原理与过程。</p><ol data-tool="mdnice编辑器"><li><section>首先，我们把未经过Bootstrap第一次估计出的树称为原始树，比如以下面的比对结果构建出一颗原始树：</section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="1.011461318051576" data-type="png" data-w="349" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMIbIZ80xPW51Dj6GwiaHbjhgticeX8g5qLsM1JFedSq4dMIPtuemR5ibfg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMIbIZ80xPW51Dj6GwiaHbjhgticeX8g5qLsM1JFedSq4dMIPtuemR5ibfg/640?wx_fmt=png"></figure><ol start="2" data-tool="mdnice编辑器"><li><section>上面的比对结果中包括10个碱基位点，5条序列。在第1次 bootstrap 时，会重新构建1个包含10个位点的比对结果，<span>首先</span>从10个位点中随机选取1个位点的序列作为伪比对第1个位点的碱基，<span>接着</span>重新从上面10个位点的序列中选取1个位点的序列作为伪比对第2个位点的碱基，如此直到形成一个新的包含10个位点的伪比对结果。<span>这样</span>得到的伪比对结果与原比对结果的不同在于有些位点可能会重复（有放回抽样），比如说第1次 bootstrap得到下面的伪比对结果，然后基于这个伪比对结果用相同的模型与参数估计一颗新的树：</section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="1.0042194092827004" data-type="png" data-w="237" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMFic8e1YPDXNfHBUf0Vaia6CYuYXyLHlVVKBPXTvdmx6EUeicPtFOEMChw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMFic8e1YPDXNfHBUf0Vaia6CYuYXyLHlVVKBPXTvdmx6EUeicPtFOEMChw/640?wx_fmt=png"></figure><ol start="3" data-tool="mdnice编辑器"><li><section>接着按照相同的方式进行第2次、第3次…直到第1000次 bootstrap。最后会得到一颗最终的树，该树的每个节点旁都会记录一个自展值(Bootstrap value)。假如物种A的自展值为90，代表在1000次bootstrap中，有900次物种A在进化树中都被归为某一类(clade)，剩下的100次物种A被归类到别的clade。一般认为自展值&gt;70的估计出来的分支是比较可靠的。</section></li></ol><h4 data-tool="mdnice编辑器"><span>4.1.3 NJ 树的估计-实践</span></h4><ol data-tool="mdnice编辑器"><li><section><p><strong><span>估计 gamma 参数</span>：</strong></p><p>按照前面的理论知识，如果我们认为自己的序列在不同位点具有不同的碱基替换率，可以设置gamma分布，所以先用MEGA得到gamma分布的参数：</p><p>依次点击，RATES -&gt; Gamma Parameter for Site Rates (ML) -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件，不用更改参数，点击 OK即可</p></section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="0.41037735849056606" data-type="png" data-w="1060" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMuQNCSmiaybf26uL0iaWWwBRG3eOolbr3tW0mJvAJrGFZyIOiaSmTOIesA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMuQNCSmiaybf26uL0iaWWwBRG3eOolbr3tW0mJvAJrGFZyIOiaSmTOIesA/640?wx_fmt=png"></figure><pre data-tool="mdnice编辑器"><code><br></code><code> <span>在结果页面，我们可以得到一个 gamma </span></code><code><span>​分布的参数为 0.499 ：</span><br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.412962962962963" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMiarld3UvLdicNhZ5bGVPP8svjkhykW7LI8zyO9tWsHUT1OPROibNlAqjw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMiarld3UvLdicNhZ5bGVPP8svjkhykW7LI8zyO9tWsHUT1OPROibNlAqjw/640?wx_fmt=png"></figure><ol start="2" data-tool="mdnice编辑器"><li><section><p><strong>估计 NJ 进化树</strong><span>：</span></p><p>在 MEGA中依次点击：PHYLOGENY -&gt; Construct/Test Neighbor Joining Tree -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件 -&gt; 设置参数。根据前面的理论知识，我们按照下图设置参数，接着点击OK即开始估计进化树。</p></section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="1.087037037037037" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMibDjH4erMgKVewE51kqqoT3ibvkY3bf2hxQr5M3RSa49IPQ7GoXULEFw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMibDjH4erMgKVewE51kqqoT3ibvkY3bf2hxQr5M3RSa49IPQ7GoXULEFw/640?wx_fmt=png"></figure><h4 data-tool="mdnice编辑器"><span>4.1.4 树的认识与MEGA中的可视化</span></h4><ol data-tool="mdnice编辑器"><li><section><span><strong>进化树的基本结构</strong></span></section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="0.6481481481481481" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMHzxLUEYjRVFibmw0sE3XMtlYBLUzE8giawpYdXOQRXThuEVcIGBvLmlw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMHzxLUEYjRVFibmw0sE3XMtlYBLUzE8giawpYdXOQRXThuEVcIGBvLmlw/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">外部节点(绿色圆点)又被称为“叶节点”，表示采样及测序的实际生物体(例如，传染病研究中的病毒)，在进化生物学术语中又被称为“分类单元(taxa)”。内部节点(蓝色圆点)表示外部节点的假设祖先。根(红色圆点) 是进化树中所有物种的共同祖先。水平线条表示树的分支，又表示生物所发生的以时间或遗传分歧衡量的演变(灰色数字)。底部的线条表示这些分支长度的标尺。</p><ol start="2" data-tool="mdnice编辑器"><li><section><p><span><strong>MEGA中的进化树查看</strong></span></p></section></li></ol><ul><li><section><p>本例中 MEGA 得到的进化树如下图1，先看红色框，这块区域显示了树的拓扑结构，与前一个图中稍有不同的是，在内部节点旁边还出现了1个数值（红色箭头所示），这是因为我们设置了 Bootstrap，该数值即表示自展值。可以看出现在的进化树是比较拥挤的，因为枝长按照实际计算出的值被画了出来，这样可以显示生物体演变的实际程度，此时树下方会有枝长的标尺。</p></section></li><li><section><p>蓝色框中是 MEGA 中绘制进化树的图形化界面选项，我们可以根据自己的需求定制不同风格的进化树，比如我们只想看一下各个分类单元的分类情况，可以点击蓝色框中 Layout -&gt; Toggle Scaling of the Tree（粉红色箭头），就可以隐藏枝长的实际值（如下方第2张图所示），此时分支的长度不代表实际意义。</p></section></li><li><section><p>又比如我们前面提到自展值过小的估计出的分支一般不是很可靠，我们也可以通过蓝色框中的 Compute -&gt; 设置自展值 Cutoff 值为50，则会合并自展值小于50的分支（如下方第3张图所示）。</p></section></li><li><section><p>另外我们还可以在蓝色框中设置是否显示自展值、枝长、显示为环形进化树、设置clade、提取子树等，只需要点击即可实时显示效果。</p></section></li><li><section><p>另外在绿色方框中会有两个树，Bootstrap Consensus Tree可以让我们更好地看清自展值与对应的节点，不过我们后续进化树可视化一般使用Original Tree 即可。</p></section></li></ul><figure data-tool="mdnice编辑器"><img data-ratio="0.9472222222222222" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMfJxvRdiaSJNV48aKqJx6auicLfPr3g8EC4nInFY222sNjtzNuJNIQjXQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMfJxvRdiaSJNV48aKqJx6auicLfPr3g8EC4nInFY222sNjtzNuJNIQjXQ/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="0.9601851851851851" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMBt8t8DPXNbCcIGoXoqibRX7ibGxAhiamM6r2XgyxPr7Ra125xBbluxnnw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMBt8t8DPXNbCcIGoXoqibRX7ibGxAhiamM6r2XgyxPr7Ra125xBbluxnnw/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="0.9064814814814814" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMu4oOG6dloQKfPH7c6vicbhzTKVh3rNkTznHAxMEZeiaFibEWk2tCemG5w/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMu4oOG6dloQKfPH7c6vicbhzTKVh3rNkTznHAxMEZeiaFibEWk2tCemG5w/640?wx_fmt=png"></figure><h4 data-tool="mdnice编辑器"><span>4.1.5 绘制有根树</span></h4><p data-tool="mdnice编辑器"><span><strong>关于无根树与有根树</strong></span></p><p data-tool="mdnice编辑器">我们构建的树（包括其它方法如ML法、MP法等）基本上得到的都是无根树。<span>无根树</span>没有方向性可言，能从一个节点追溯其父节点也可以追溯其子节点，如果移除无根树的某个分支，可以拆分到不同的分组，这些不同的分组称为 <strong>splits</strong>。<span>有根树</span>有方向性，不能从一个节点追溯其父节点，只能追溯其子节点，因为物种进化是有方向的，如果移除有根树的某个分支，得到的分组称为 <strong>clades</strong>。</p><p data-tool="mdnice编辑器"><strong>虽然</strong>得到的是无根树，但是 MEGA 绘制出来的进化树看起来容易让人认为是有根树。我们在进化分析时往往希望得到的是有根树，因为只有有根树才能分析物种的演化关系。因此有时候通常会通过无根树人为绘制有根树。在一堆同源性较高的序列中去寻找它们的根往往不容易，因此我们往往需要借助额外的信息，常用的方法是借助外群(outgroup)。</p><p data-tool="mdnice编辑器"><strong>外群</strong>(outgroup)可以被定义为1条或多条序列，这些序列与内群(ingroup)序列的进化距离比内群序列之间的距离都要远。</p><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">在前面的例子中，我选了18条 PRRSV 病毒的 ORF5 基因的序列，要绘制有根树，我需要另外加入1条外群序列，我选择的是与 PRRSV 病毒在同一个科下的另一种病毒的 ORF5 基因序列。在重新进行多序列比对、进化树估计后，得到下方的进化树，红框中的序列为新加入的外群序列，可以发现其与前面的18条序列相比形成了单独的一个分支：</p><figure data-tool="mdnice编辑器"><img data-ratio="1.5612472160356348" data-type="png" data-w="898" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMlR0fyia73ShiaW4yKvEwGBsPgAwlKNPFiameMt3R7BXSDy2Exea7YKbicA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMlR0fyia73ShiaW4yKvEwGBsPgAwlKNPFiameMt3R7BXSDy2Exea7YKbicA/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">接下来绘制有根树，首先在图中鼠标左键点击外群所在的分支，然后鼠标右键选择 Root tree 即可（如下图1所示），接着我们得到了1颗有根树（如下图2所示）。</p><p data-tool="mdnice编辑器"><strong>虽然</strong>我们绘制的有根树看起来和无根树没什么区别，但实际上已经设置了1个根节点（下方图2中绿色箭头所示），而且仔细观察可以发现两颗树的分支长度发生了变化。上图无根树的分支看起来有两个分支分成了外群与内群，但实际上只有1个分支，其实际分支长度为这两个长度之和，MEGA中将其绘制成了看起来有两个分支的图形。下图2的有根树的分支确实存在两个分支，将其分成了内群与外群，因此分支长度也发生了改变。</p><figure data-tool="mdnice编辑器"><img data-ratio="1.6501103752759383" data-type="png" data-w="906" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM4Q2ght9g7xRlqMCVUXmhHNOFW1chxuLzOxibgzkGibDo5ouyBndjJtfg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM4Q2ght9g7xRlqMCVUXmhHNOFW1chxuLzOxibgzkGibDo5ouyBndjJtfg/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="1.6254375729288215" data-type="png" data-w="857" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMAq2p0kArfhXOzwsHmWZfqmic8rwbG2qFwBOYU3f9vf8k13icER8YDxSQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMAq2p0kArfhXOzwsHmWZfqmic8rwbG2qFwBOYU3f9vf8k13icER8YDxSQ/640?wx_fmt=png"></figure><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">接着我们就可以根据这个有根树添加不同的 clade 了。首先点击某个类别所有分类单元所在的共同分支（下图红色箭头），然后依次选择 Subtree -&gt; Draw Options -&gt; Format Subtree，即可进入设置 clade 的界面。（如果要删除设置的某个clade，还是这样选择，会出现一个Clear clade或者Clear All subtree options的选项，代表清除某个分类或者清除所有分类的设置）</p><figure data-tool="mdnice编辑器"><img data-ratio="1.0398148148148147" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM9GH8OejnIw23AyJH0EfKmiaoPJEoHdRCBVpRq3Vv5ibqicAuVeb05kObg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM9GH8OejnIw23AyJH0EfKmiaoPJEoHdRCBVpRq3Vv5ibqicAuVeb05kObg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器"><span>另外</span>有一系列选项可以进行子树的设置（下图1），大家可以自行探索。</p><p data-tool="mdnice编辑器">我们可以发现 MEGA 自带的绘图功能其实也很强大，可以达到很美观的效果，设置 clade 后如下图2所示。</p><figure data-tool="mdnice编辑器"><img data-ratio="1.5467224546722456" data-type="png" data-w="717" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMRl33UfPZhtd9IY9K1d4ENMJCqq2NIvfrHdTLLe56vGoSlZTQxZgjPg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMRl33UfPZhtd9IY9K1d4ENMJCqq2NIvfrHdTLLe56vGoSlZTQxZgjPg/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="1.2516810758885686" data-type="png" data-w="1041" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMQNHWJFxiaG60iaDO4bljRxaOOaiaTvZx9ibn3DSobrHsYibslpgt3ib2AHUQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMQNHWJFxiaG60iaDO4bljRxaOOaiaTvZx9ibn3DSobrHsYibslpgt3ib2AHUQ/640?wx_fmt=png"></figure><h4 data-tool="mdnice编辑器"><span>4.1.6 树的保存与导出</span></h4><ol data-tool="mdnice编辑器"><li><section><strong>如果</strong>不需要对树进行进一步编辑，可以直接导出 MEGA 制作的进化树图片，选择 Image，可以保存为各种格式的图片文件。</section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="0.649074074074074" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMMIITKjw3c27F3gu7ic9mACBrmqx40494x3wet5hRicxnHJNgzrDKQBQg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMMIITKjw3c27F3gu7ic9mACBrmqx40494x3wet5hRicxnHJNgzrDKQBQg/640?wx_fmt=png"></figure><ol start="2" data-tool="mdnice编辑器"><li><section><p><strong>如果</strong>想要将进化树数据导出，在其它软件中编辑，我们可以选择 File -&gt; Export Current Tree(Newick)（下图1） -&gt; 勾选两个选项，即同时导出枝长与自展值（下图2），接着会出现<code>.nwk</code>格式文件的编辑窗口（下图3），直接点击保存然后命名为想要的名字即可。我这里保存为<code>example.nwk</code>等待步骤5使用。</p><p><strong>Newick格式</strong>是计算机可读形式的树文件标准格式，与 NEXUS、Phylip 等均是较为常见的储存系统发育树及其节点和分支相关数据的文件格式。我们通过MEGA得到树文件后，将其导出为 Newick 格式的树文件，然后可以使用 ggtree 等进行可视化。</p></section></li></ol><figure data-tool="mdnice编辑器"><img data-ratio="1.0011198208286674" data-type="png" data-w="893" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMuKbP4vhslaIg1Nr9Wpxgyq4lMhH3xSPrET4rTJgib9dibCHSXErwJdUg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMuKbP4vhslaIg1Nr9Wpxgyq4lMhH3xSPrET4rTJgib9dibCHSXErwJdUg/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="0.8191027496382055" data-type="png" data-w="691" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMHt3WAyluKszbmCdc5Jeib1zrQ0JE0bxd7lETyKWCnz41z0oDYoKaEDQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMHt3WAyluKszbmCdc5Jeib1zrQ0JE0bxd7lETyKWCnz41z0oDYoKaEDQ/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="0.4074074074074074" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMaUvpN1SzpjfpxFWx0OsStqn9FZy2HY5Xhib7ia0c3MtcM8y6n0GEosng/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMaUvpN1SzpjfpxFWx0OsStqn9FZy2HY5Xhib7ia0c3MtcM8y6n0GEosng/640?wx_fmt=png"></figure><ol start="3" data-tool="mdnice编辑器"><li><section>我们也可以保存一份树文件，等待下一次使用MEGA时继续编辑，只需要点击 File -&gt; Save Current Session -&gt; 然后保存为 <code>.mtsx</code>或者<code>.mts</code>格式的文件即可。</section></li></ol><h3 data-tool="mdnice编辑器"><span>4.2 构建 ML 树</span></h3><p data-tool="mdnice编辑器">最大似然法(Maximum Likelihood,ML)也是使用得比较普遍的一种进化树构建方法。因此我这里也介绍一下如何用MEGA构建MJ树。</p><p data-tool="mdnice编辑器"><span><strong>最大似然法基本介绍：</strong></span></p><p data-tool="mdnice编辑器">最大似然法是一种基于进化模型和位点信息的树构建方法，其理论基础是基于两条基本假设：不同的性状进化是独立的、物种发生分歧后进化独立。</p><p data-tool="mdnice编辑器">在ML法中，以一个特定的替代模型分析既定的一组序列数据，使所获得的每一个拓扑结构的似然率均为最大，挑出其最大似然率的最大拓扑结构为最终树。其主要优点是如果进化模型选择合理，ML树与真实进化的吻合度最高。然而，ML树的缺点在于计算强度大，非常耗时。</p><h4 data-tool="mdnice编辑器"><span>4.2.1 选择最佳模型</span></h4><p data-tool="mdnice编辑器">我们先看一下MEGA中估计ML树的参数，选择 PHYLOGENY -&gt;  Construct/Test Maximum Parsimony Tree(s) -&gt; 可以进入参数设置页面，可以看到在 Model/Method 中提供了6个模型选项，Rates among sites提供了4个选项。</p><figure data-tool="mdnice编辑器"><img data-ratio="0.24299065420560748" data-type="png" data-w="963" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM551MOwYrroO8gAMNdtSCib3YKmQRtW9hMpsIY2UvJPM42f2cicTSpCRg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM551MOwYrroO8gAMNdtSCib3YKmQRtW9hMpsIY2UvJPM42f2cicTSpCRg/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="0.22438524590163936" data-type="png" data-w="976" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMiaHAMicFXRlz1UvVElfbBKFOkAicEZJ35RHia4QWtECrY3JTfbSAlhJKsw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMiaHAMicFXRlz1UvVElfbBKFOkAicEZJ35RHia4QWtECrY3JTfbSAlhJKsw/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">接着我可以们直接使用MEGA软件预测一个适合我们数据的上述两个参数的最佳组合。我们依次点击：MODELS -&gt; Find Best DNA/Protein Models (ML)… -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件 -&gt; 参数设置页面不需要更改（如下图1），点击OK后一段时间会出现一个模型预测结果的窗口（如下图2）。</p><figure data-tool="mdnice编辑器"><img data-ratio="0.49616858237547895" data-type="png" data-w="1044" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMXkU9Tddd2Gqh4Nuo08NxiaKZDB7hOxkl56KpQPUgvrfeZQqibANxkOaQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMXkU9Tddd2Gqh4Nuo08NxiaKZDB7hOxkl56KpQPUgvrfeZQqibANxkOaQ/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="0.5916666666666667" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMF4xRxIhBGclQDC5MQpvMbrm0S42FUYNp8kComzBicM83RKSicYEGmtLg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMF4xRxIhBGclQDC5MQpvMbrm0S42FUYNp8kComzBicM83RKSicYEGmtLg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">上图中红色框区域为MEGA为我们找到的模型结果，绿色框区域有一个对该结果的介绍。我们主要关注前5列（蓝色框所示）。</p><ul data-tool="mdnice编辑器"><li><section>Model：替换模型与Rates参数简称的组合，从上到下排序为最好到最差。如 K2+G+I，代表 Model/Method 参数选择 Kimura 2-parameter 模型；Rates among Sites参数选择 Gamma Distributed With Invariant Sites(G+I)。</section></li><li><section>Paramaters：相应模型下必须要估计的参数的数量，在所有条件都相同的情况下，通常认为估计更少的参数会更好。这里的条件指的是用合适的模型来衡量（当然条件通常不相同）</section></li><li><section>BIC、AICc、InL是三种方法计算出的分数，BIC分数计算采用的是贝叶斯信息准则(Bayesian Information Criterion)，分数越低代表模型越好，MEGA对Model列的排序就是基于BIC进行排序的。AICc分数计算采用的是校正后AIC信息准则(Akaike Information Criterion,correction)，分数越低代表模型越好。InL代表极大似然值(Maximum Likelihood value)，绝对值越低代表模型越好。</section></li></ul><p data-tool="mdnice编辑器"><span>在本例中</span>，虽然参数数量第一个模型组合比第二个模型组合大1，但其BIC、AICc、InL分数都是第一种模型组合更好一点，因此我们选择第一个组合（K2+G+I）。有时候第一个模型组合的BIC分数可能小于第二个模型组合，但是如果相差不大，且AIC、InL、参数数量都是第二个模型组合比较好的话，我们也可以考虑选择使用第二个模型组合。</p><h4 data-tool="mdnice编辑器"><span>4.2.2 估计 ML 树</span></h4><p data-tool="mdnice编辑器">如下图1，依次点击：PHYLOGENY -&gt;  Construct/Test Maximum Likelihood Tree -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件，设置参数如下图2所示。点击OK即可开始比对。</p><p data-tool="mdnice编辑器"><span><strong>关于参数的设置</strong></span></p><ul data-tool="mdnice编辑器"><li><section><p>Bootstrap：注意估计 ML 树设置 Bootstrap 检验会很耗时（电脑不太好的话有时候MEGA程序还会卡住或者闪退）。</p></section></li><li><section><p>Gaps/Missing Data Treatment与NJ树一致，其它参数我们直接选择默认即可，一般不需要修改。</p></section></li></ul><figure data-tool="mdnice编辑器"><img data-ratio="0.3819379115710254" data-type="png" data-w="1063" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMia8hicddC90MWdo79n0hUcd0PCMYf0V54jRwX1Co03MACoegyBsGeibAg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMia8hicddC90MWdo79n0hUcd0PCMYf0V54jRwX1Co03MACoegyBsGeibAg/640?wx_fmt=png"></figure><figure data-tool="mdnice编辑器"><img data-ratio="1.1601851851851852" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMwaQX56DGFZgW0k8YStBMmdfd8tFWRSzkjWImh4qyhwib5Nrw81HeOww/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMwaQX56DGFZgW0k8YStBMmdfd8tFWRSzkjWImh4qyhwib5Nrw81HeOww/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">最后我们可以得到最大似然法估计出的进化树，如下图所示，左下角红色箭头处会显示该树的log似然值（该值比真实树的似然值肯定会差一些）。其它关于树在MEGA中的可视化与NJ树一致，可见步骤4.1.4-4.1.6</p><figure data-tool="mdnice编辑器"><img data-ratio="1.6136595310907238" data-type="png" data-w="981" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMqUFFoUeIYW59vjvv0nic97Pp8u1366s2LicIPtZSYTJMTtibj9NTdJsoA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMqUFFoUeIYW59vjvv0nic97Pp8u1366s2LicIPtZSYTJMTtibj9NTdJsoA/640?wx_fmt=png"></figure><h2 data-tool="mdnice编辑器"><span>5.使用 ggtree 进行可视化</span></h2><p data-tool="mdnice编辑器"><strong>前面</strong>步骤 4.1.6 我们得到了导出的 Newick 格式的树文件，接着就可以使用R包 treeio 处理以及 ggtree 进行美化了。可视化的部分并没有统一的规范，每个人的需求不同。建议有R语言与ggplot一定基础的同学去看一看Y叔的书《R实战：系统发育树的数据集成操作及可视化》，里面讲得很详细（了解ggplot2语法学起来会很快）。不想用R画图的同学可以借助一些软件如iTOL、Figtree等，或者直接使用前面介绍的MEGA中绘制出来的进化树图片。</p><p data-tool="mdnice编辑器"><strong>下面</strong>我仅简单介绍一下如何使用treeio以及ggtree进行简单绘图，而不深入探索高级绘图的细节。我们一步一步探索ggtree的绘图过程：</p><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">如果没有安装ggtree，treeio，tidytree，需要先安装：</p><pre data-tool="mdnice编辑器"><code><span>if</span>(!<span>require</span>(<span>"ggtree"</span>,quietly = <span>T</span>)) BiocManager::install(<span>"ggtree"</span>)<br><span>if</span>(!<span>require</span>(<span>"tidytree"</span>,quietly = <span>T</span>)) BiocManager::install(<span>"tidytree"</span>)<br><span>if</span>(!<span>require</span>(<span>"treeio"</span>,quietly = <span>T</span>)) BiocManager::install(<span>"treeio"</span>)<br></code></pre><h3 data-tool="mdnice编辑器"><span>5.1 treeio与ggtree使用介绍与练习</span></h3><p data-tool="mdnice编辑器">加载需要的包</p><pre data-tool="mdnice编辑器"><code><span>library</span>(treeio)<br><span>library</span>(ggtree)<br><span>library</span>(tidytree)<br></code></pre><p data-tool="mdnice编辑器">导入Newick格式的进化树</p><pre data-tool="mdnice编辑器"><code>tree &lt;- read.tree(<span>"example.nwk"</span>)<br></code></pre><p data-tool="mdnice编辑器">我们可以先看一下 read.tree() 函数读入树文件后储存的对象格式，phylo对象是储存系统发育数据常用的一种格式，系统发育分析中用到的大多数R包都依赖于phylo对象。</p><pre data-tool="mdnice编辑器"><code>class(tree)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## [1] "phylo"</span><br></code></pre><p data-tool="mdnice编辑器">然后就可以使用ggtree画出最简单的树的拓扑结构了</p><pre data-tool="mdnice编辑器"><code>ggtree(tree)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6222222222222222" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMxSbBa1eSWuEHJLQkQ9vHfPhicHlicQOicMCFbgwT42lfDmz4SLaVS7D8A/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMxSbBa1eSWuEHJLQkQ9vHfPhicHlicQOicMCFbgwT42lfDmz4SLaVS7D8A/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">接着我们使用geom_tiplab()给每个分类单元添加名称，其实ggtree与ggplot函数的语法基本是一致的，如果要掌握ggtree最好先去了解一下ggplot语法。</p><pre data-tool="mdnice编辑器"><code>ggtree(tree)+<br>  geom_tiplab(size=<span>1.5</span>,color=<span>"purple"</span>) <span># size与color参数分别设置字体大小与颜色</span><br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6185185185185185" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM00Ud8EbYcXiaunGPRwFI3EwDaRGsF7uzichcl0I0VWMtLKvDOVzOOGfg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM00Ud8EbYcXiaunGPRwFI3EwDaRGsF7uzichcl0I0VWMtLKvDOVzOOGfg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">我们前面画出的树中，其分支长度代表了物种实际的进化程度，因此可以使用geom_treescale()添加标尺，其中标尺x,y参数的设置只需要将整个图想象成第一象限的坐标轴，然后调整标尺的位置即可：</p><pre data-tool="mdnice编辑器"><code>ggtree(tree)+<br>  geom_tiplab(size=<span>1.5</span>,color=<span>"purple"</span>)+<br>  geom_treescale(x=<span>2</span>,y=<span>20</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6203703703703703" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMycJchsxZATeh5l8f9CntAAELicMOkcWytZDsp6bT3PvvLxxYmweomEA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMycJchsxZATeh5l8f9CntAAELicMOkcWytZDsp6bT3PvvLxxYmweomEA/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">前面的树不是很整齐，如果我们不需要体现分枝长度，只需要知道各分类单元属于哪个clade，那么可以设置 branch.length="none"参数去除分支长度，使树更加美观，layout参数可以指定树的布局方式。</p><pre data-tool="mdnice编辑器"><code>ggtree(tree,branch.length = <span>"none"</span>,layout=<span>"circular"</span>)+<br>  geom_tiplab(size=<span>1.5</span>,color=<span>"purple"</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.8554729011689692" data-type="png" data-w="941" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMSsOw8ut0qiaak2Ux2lgm5dPMTD2h62wWOVqZUicKW5ekxW1SA6tjfvRA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMSsOw8ut0qiaak2Ux2lgm5dPMTD2h62wWOVqZUicKW5ekxW1SA6tjfvRA/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">这个phylo树对象在R语言中实际上是一个列表。前面画的矩形树图没有1个明显的根分支，我们可以给列表添加1个元素，即根分支的长度，我这里把长度设置为0.5，然后使用geom_rootedge()添加根分支图层</p><pre data-tool="mdnice编辑器"><code>tree$root.edge &lt;- <span>0.5</span><br>ggtree(tree)+<br>  geom_tiplab(size=<span>1.5</span>,color=<span>"purple"</span>)+<br>  geom_rootedge()<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6287037037037037" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMHvrHy2zewiceBIWRk8icHcgPMEyrOzicMo2cmefV1rvsTHdOIIdZ94nRg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMHvrHy2zewiceBIWRk8icHcgPMEyrOzicMo2cmefV1rvsTHdOIIdZ94nRg/640?wx_fmt=png"></figure><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">接下来我们探索如何对各个分类单元进行分组，即设置clade。在这之前我们先了解一下我们的树数据。因为phylo对象不容易直观理解，因此可以通过as_tibble()函数将phylo对象转换为tibble表格，与数据框差不多：</p><pre data-tool="mdnice编辑器"><code>tree_tibble &lt;- as_tibble(tree)<br></code></pre><p data-tool="mdnice编辑器">我们打开 tree_tibble 看一下就可以发现数据其实很简单，只有4列数据，node列保存了分类单元所在的节点编号，parent列保存了其父节点的编号，branch.length列保存了分支长度，label列保存了该节点对应的标签（叶节点的标签即分类单元的名称，内部节点的标签即自展值），关于节点、分支、分类单元等概念忘记的可以去步骤 4.1.4 进行回顾。</p><figure data-tool="mdnice编辑器"><img data-ratio="0.8037974683544303" data-type="png" data-w="790" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM9zq3bicoCt4JmMyznDfC2yibPEicibI9bgVr9UcKsLlavo3zmvWwkDJRww/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM9zq3bicoCt4JmMyznDfC2yibPEicibI9bgVr9UcKsLlavo3zmvWwkDJRww/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">因为每个节点都有一个编号或者标签，因此我们可以通过该编号定位到某个节点。这样就可以实现对不同 clade 进行分类、标注颜色等操作。比如说下图中红色和蓝色圆圈所在的节点下所有分类单元分别可以被归为clade1与 clade2，我们只要往tree数据中添加基于此的分组信息即可方便地使用ggtree进行分组标记颜色与注释clade。</p><figure data-tool="mdnice编辑器"><img data-ratio="0.6444444444444445" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM1Y9FfGLwHj8qUianicibEpl39GzQNDJX2SScSxuUibIrMs2jZv9NHicVVzw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM1Y9FfGLwHj8qUianicibEpl39GzQNDJX2SScSxuUibIrMs2jZv9NHicVVzw/640?wx_fmt=png"></figure><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">我们先看一下可以提取节点信息的几个函数，对于tree这个phylo对象的数据，parent()函数返回了第1个节点的父节点的节点编号</p><pre data-tool="mdnice编辑器"><code>parent(tree,<span>1</span>)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## [1] 26</span><br></code></pre><p data-tool="mdnice编辑器">相应的还有child()函数可以提取某个节点子节点的编号，</p><pre data-tool="mdnice编辑器"><code>child(tree,<span>26</span>)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## [1] 1 2</span><br></code></pre><p data-tool="mdnice编辑器">ancestor()函数提取某个节点所有父辈节点编号，直到追溯到根节点</p><pre data-tool="mdnice编辑器"><code>ancestor(tree,<span>1</span>)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## [1] 26 25 24 23 22 21 20</span><br></code></pre><p data-tool="mdnice编辑器">offspring()函数提取某个节点所有子代节点编号</p><pre data-tool="mdnice编辑器"><code>offspring(tree,<span>20</span>)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>##  [1] 21 31 19 22 11 23 28 24 27 25  4 26  3  1  2  5  6  7 29  8 30  9 10 12 32</span><br><span>## [26] 33 35 34 15 13 14 16 36 17 18</span><br></code></pre><p data-tool="mdnice编辑器">sibling()函数返回某个节点的兄弟节点</p><pre data-tool="mdnice编辑器"><code>sibling(tree,<span>1</span>)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## [1] 2</span><br></code></pre><p data-tool="mdnice编辑器">上述函数也可以针对前面转换的tibble数据进行提取，可以得到更全的信息，比如：</p><pre data-tool="mdnice编辑器"><code>child(tree_tibble,<span>26</span>)<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## # A tibble: 2 × 4</span><br><span>##   parent  node branch.length label     </span><br><span>##    &lt;int&gt; &lt;int&gt;         &lt;dbl&gt; &lt;chr&gt;     </span><br><span>## 1     26     1       0.0102  MT268280.1</span><br><span>## 2     26     2       0.00610 FJ548853.1</span><br></code></pre><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器"><strong>回到</strong>前面讲的，我们的目的是获取红蓝色圈对应的节点编号，以实现分类，因此我们只需要找到根节点编号，然后根据根节点编号获取其两个子节点编号就是我们相要的两个节点编号。</p><ul data-tool="mdnice编辑器"><li><section>有一种比较简单的方法，先将所有节点编号显示在图中，然后我们从图中找到直接用于后面的输入，使用geom_nodelab()函数映射节点编号即可，可以发现我们想要的编号是21与31：</section></li></ul><pre data-tool="mdnice编辑器"><code>ggtree(tree,branch.length = <span>"none"</span>)+geom_nodelab(aes(label=node))<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6222222222222222" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMzXib0nBibkI7mOCxxXtJsUDxMibuDzwgbdxROI1eQq0Lr9KohdhVOdkWw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMzXib0nBibkI7mOCxxXtJsUDxMibuDzwgbdxROI1eQq0Lr9KohdhVOdkWw/640?wx_fmt=png"></figure><ul data-tool="mdnice编辑器"><li><section>还有一种方法是直接提取，我们首先通过<code>ancestor(tree,1)</code>得到任意节点（这里选择了节点1）的所有祖先节点，它返回的编号顺序是一级一级往前推的，因此最后一个编号就是根节点编号，然后通过<code>rev()</code>函数反向，再取其第一个编号就是根节点编号了。</section></li></ul><pre data-tool="mdnice编辑器"><code>( node_root &lt;- rev(ancestor(tree,<span>1</span>))[<span>1</span>] )<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## [1] 20</span><br></code></pre><p data-tool="mdnice编辑器">然后我们只需要使用<code>child()</code>函数即可得到想要的节点编号，示例的进化树中根节点分出了3个节点，前两个就是我们想要用于分组的节点。</p><pre data-tool="mdnice编辑器"><code>( node &lt;- child(tree,node_root) )<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## [1] 21 31 19</span><br></code></pre><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器"><strong>接着</strong>通过groupClade函数，我们可以给树添加分组信息，只需要传入我们想要分组的节点编号的向量即可。下面的例子中，groupClade函数把节点21的所有子节点分为一组，把节点31的所有子节点分为另一组，转换为tibble数据查看一下，我们可以明显发现数据中添加了1列group信息，1代表第1组，2代表第2组，如果有别的节点不包含在我们输入的节点的子节点中，该函数会默认将这些节点标记为另外一组0。（需要注意groupClade只能对内部节点进行分组，想要将叶节点进行分组可以使用groupOTU函数）</p><pre data-tool="mdnice编辑器"><code>groupClade(tree,c(<span>21</span>,<span>31</span>)) %&gt;% as_tibble()<br></code></pre><pre data-tool="mdnice编辑器"><code><span>## # A tibble: 36 × 5</span><br><span>##    parent  node branch.length label       group</span><br><span>##     &lt;int&gt; &lt;int&gt;         &lt;dbl&gt; &lt;chr&gt;       &lt;fct&gt;</span><br><span>##  1     26     1       0.0102  MT268280.1  1    </span><br><span>##  2     26     2       0.00610 FJ548853.1  1    </span><br><span>##  3     25     3       0.00733 OQ883907.1  1    </span><br><span>##  4     24     4       0.00288 OQ357724.1  1    </span><br><span>##  5     27     5       0       NC_038291.1 1    </span><br><span>##  6     27     6       0.00921 AF331831.1  1    </span><br><span>##  7     28     7       0.0821  JN660150.1  1    </span><br><span>##  8     29     8       0.0547  MW803134.1  1    </span><br><span>##  9     30     9       0.0601  MZ416787.1  1    </span><br><span>## 10     30    10       0.0816  JN654459.1  1    </span><br><span>## # ℹ 26 more rows</span><br></code></pre><p data-tool="mdnice编辑器">分组以后我们需要将其保存为一个新的tree变量才可以进一步画图，这里保存为tree2。</p><pre data-tool="mdnice编辑器"><code>tree2 &lt;- groupClade(tree,c(<span>21</span>,<span>31</span>))<br></code></pre><p data-tool="mdnice编辑器">接着我们只需要使用类似于ggplot2的语法，使用aes函数将group分组信息映射到图中即可</p><pre data-tool="mdnice编辑器"><code>p &lt;- ggtree(tree2,aes(color=group))+<br>  geom_tiplab()<br>p<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6111111111111112" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMuqqlvp9B1PicnoZqtbM1QjHKwZI4AUqHMyHnXnYsUf7Kl1tNFIpOnhw/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMuqqlvp9B1PicnoZqtbM1QjHKwZI4AUqHMyHnXnYsUf7Kl1tNFIpOnhw/640?wx_fmt=png"></figure><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">接下来我们要进一步在分类单元右边添加clade标注。先构建一个数据框，node中还是填入刚才用于分类的编号形成的向量，name中填入对应的clade名称组成的向量，比如我想把节点21所在的分类命名为L1，把节点31所在的分类命名为L2,可以这样设置：</p><pre data-tool="mdnice编辑器"><code>dat &lt;- data.frame(node=c(<span>21</span>,<span>31</span>),<br>                  name=c(<span>"L1"</span>,<span>"L2"</span>))<br></code></pre><p data-tool="mdnice编辑器">然后使用geom_cladelab函数添加一个图层，将前面制造的dat数据映射上去即可，offset参数代表设置文本到条带之间的距离。</p><pre data-tool="mdnice编辑器"><code>p+geom_cladelab(data = dat,<br>                mapping = aes(node=node,label=name),<br>                offset=<span>0.5</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6185185185185185" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMwOjaoR8b9jNC75VUeHZX2muevrlTdwT3yL0Vjs7K3A08iaxTfloXBmQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMwOjaoR8b9jNC75VUeHZX2muevrlTdwT3yL0Vjs7K3A08iaxTfloXBmQ/640?wx_fmt=png"></figure><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">如果我们想要移除某个分类单元怎么办呢？比如我现在不想NC_001639.1出现在图中，只需要使用drop.tip函数传入需要移除的分类单元名称组成的向量即可，然后对新的树tree3绘图。</p><pre data-tool="mdnice编辑器"><code>tree3 &lt;- drop.tip(tree2,<span>"NC_001639.1"</span>)<br>ggtree(tree3)+<br>  geom_tiplab()+<br>  geom_cladelab(data = dat,<br>                mapping = aes(node=node,label=name),<br>                offset=<span>0.5</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6148148148148148" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMOnwjvusP0GdbyJo4WklzmeMFPmc5Wc1VMszvjcjTIYCnULNibwzc7yg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMOnwjvusP0GdbyJo4WklzmeMFPmc5Wc1VMszvjcjTIYCnULNibwzc7yg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器"><span>接下来</span>，如果我们只想给其中几个分类单元标上颜色，只需要映射想要标记颜色的分类单元到颜色参数即可。</p><ul data-tool="mdnice编辑器"><li><section>可以直接映射分类单元名称</section></li></ul><pre data-tool="mdnice编辑器"><code>mark &lt;- c(<span>"MT268280.1"</span>,<span>"JN660150.1"</span>,<span>"OQ803248.1"</span>)<br>ggtree(tree3,aes(color=label %<span>in</span>% mark))+<br>  geom_tiplab()+<br>  geom_cladelab(data = dat,<br>                mapping = aes(node=node,label=name),<br>                offset=<span>0.5</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6148148148148148" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMPQcdZaSgYq9nfeHetZETv3hjbw1X82kzuelJBMTlAwEb1Qqebu1ABQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMPQcdZaSgYq9nfeHetZETv3hjbw1X82kzuelJBMTlAwEb1Qqebu1ABQ/640?wx_fmt=png"></figure><ul data-tool="mdnice编辑器"><li><section>也可以映射分类单元的节点编号：</section></li></ul><pre data-tool="mdnice编辑器"><code>ggtree(tree)+<br>  geom_tiplab(size=<span>2</span>,aes(color=node %<span>in</span>% c(<span>1</span>,<span>7</span>,<span>14</span>)))<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6194444444444445" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMKmrTbb1iawf9Ahcu9ZibMHMr7LUTqQdHbeRvXKOu2XxQ0UR3EsI3NelQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMKmrTbb1iawf9Ahcu9ZibMHMr7LUTqQdHbeRvXKOu2XxQ0UR3EsI3NelQ/640?wx_fmt=png"></figure><hr><p data-tool="mdnice编辑器"><strong>另外</strong>treeio也可以提取某个子树进行画图，比如我现在只想要L1所对应的子树，只需要使用subtree函数对子树进行提取即可。node参数指定要提取的子树的某个叶节点的编号或者标签均可以，levels_back参数指定子集树应该包括多少从选定节点返回的节点（即叶节点往前追溯多少数量的节点）</p><pre data-tool="mdnice编辑器"><code>tree4 &lt;- tree_subset(tree,node=<span>1</span>,levels_back = <span>6</span>)<br>ggtree(tree4)+<br>  geom_tiplab(size=<span>2</span>,color=<span>"purple"</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6166666666666667" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM4M0W6heu7wnBCYWiafxkl6Q6F3F8GvibounkE0x4PCLjJM3EkU2S0iceA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrM4M0W6heu7wnBCYWiafxkl6Q6F3F8GvibounkE0x4PCLjJM3EkU2S0iceA/640?wx_fmt=png"></figure><h3 data-tool="mdnice编辑器"><span>5.2 进化树的可视化实践</span></h3><ol data-tool="mdnice编辑器"><li><section>下面我展示了我自己画出来的一个进化树：</section></li></ol><pre data-tool="mdnice编辑器"><code><span># 载入包</span><br><span>library</span>(treeio)<br><span>library</span>(ggtree)<br><span>library</span>(tidytree)<br><br><span>#导入树文件</span><br>tree &lt;- read.tree(<span>"example.nwk"</span>)<br>tree &lt;- drop.tip(tree,<span>"NC_001639.1"</span>) <span># 移除不需要展示的分类单元</span><br><span>#设置根分支长度</span><br>tree$root.edge &lt;- <span>0.3</span><br><span>#获取分类节点编号</span><br>tree_tibble &lt;- as_tibble(tree)<br>node_root &lt;- rev(ancestor(tree,<span>1</span>))[<span>1</span>] <span>#获取根节点编号</span><br>node &lt;- child(tree,node_root)[-<span>3</span>] <span>#获取分类节点编号</span><br>tree2 &lt;- groupClade(tree,node)<br><br><span>#定义clade名称</span><br>dat &lt;- data.frame(node=node,<br>                  name=c(<span>"L1"</span>,<span>"L2"</span>))<br><span>#ggtree可视化</span><br>p &lt;- ggtree(tree2,<br>       aes(color=group), <span>#映射分组信息</span><br>       branch.length = <span>"none"</span>,<br>       size=<span>1</span>)+ <span>#分支粗细</span><br>     geom_tiplab(size=<span>3</span>,color=<span>"purple"</span>,offset = <span>0.2</span>)+ <span>#叶节点字体大小与颜色</span><br>     geom_tippoint(size=<span>2</span>)+ <span>#给叶节点添加圆点</span><br>     geom_cladelab(data = dat, <span>#添加clade分类数据</span><br>                   mapping = aes(node=node,label=name),<br>                   offset=<span>1</span>, <span>#线条与分类单元文本之间的距离</span><br>                   offset.text=<span>0.02</span>, <span>#线条与clade文本之间的距离</span><br>                   geom=<span>"label"</span>, <span>#为clade文本添加背景</span><br>                   fill=<span>"lightblue"</span>, <span>#clade文本背景颜色</span><br>                   fontsize=<span>3.5</span>, <span>#clade文本字体大小</span><br>                   barsize=<span>0.7</span>, <span>#线条粗细，align参数即是否对齐</span><br>                   align=<span>T</span>, <br>                   barcolor=<span>"grey"</span>)+<span>#线条颜色</span><br>     geom_rootedge()+ <span>#添加根分支图层</span><br>     theme_tree(<span>"#FEE4E9"</span>)+ <span>#设置主题</span><br>     theme(legend.position = <span>"none"</span>) <span>#去除图例</span><br>p<br><br><span>#保存进化树图片</span><br>ggsave(p,file=<span>"plot1.png"</span>,width = <span>8</span>,height = <span>12</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1.5202492211838006" data-type="png" data-w="963" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMaLd5HQtk57N0mghxXtKFGmj1kvAd4vL8QqxucQuWRM2CQ6c6H1OhIQ/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMaLd5HQtk57N0mghxXtKFGmj1kvAd4vL8QqxucQuWRM2CQ6c6H1OhIQ/640?wx_fmt=png"></figure><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器">在得到上面的树后，如果我们想要调换某个分支的展示顺序，只需要简单地通过rotate函数即可完成,比如我对上图的节点20对应的分支调换展示顺序：</p><pre data-tool="mdnice编辑器"><code>rotate(p,<span>20</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="1.5269709543568464" data-type="png" data-w="964" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMDoE7DfOcWuZYbwibNXElgiaQgltq27aK0fwXwOEFpf9JJrIYCRiblL7IA/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMDoE7DfOcWuZYbwibNXElgiaQgltq27aK0fwXwOEFpf9JJrIYCRiblL7IA/640?wx_fmt=png"></figure><ol start="2" data-tool="mdnice编辑器"><li><section>我们还可以将进化树结果与多序列比对结果放在同一张图中进行展示，多序列比对结果（example.fas）我们已经从步骤3.3得到</section></li></ol><pre data-tool="mdnice编辑器"><code><span>#载入需要的包</span><br><span>library</span>(treeio)<br><span>library</span>(ggtree)<br><span>library</span>(tidytree)<br><br><span>#导入Newick树文件与多序列比对FASTA文件</span><br>tree &lt;- read.tree(<span>"example.nwk"</span>)<br>msa &lt;- read.fasta(<span>"example.fas"</span>)<br><br><span>#因为read.fasta函数导入多序列比对结果后_会识别为空格，因此需要先将空格转换为_，否则会导致无法与进化树的分类单元名匹配而绘图失败。</span><br><span>library</span>(stringr)<br>names(msa) &lt;- str_replace(names(msa),<span>" "</span>,<span>"_"</span>)<br><br><span>#先绘制进化树</span><br>p1 &lt;- ggtree(tree,branch.length = <span>"none"</span>)+geom_tiplab(size=<span>2</span>)<br><br><span>#然后用msaplot函数将两个结果绘制在一起</span><br>msaplot(p1,msa,<br>        offset = <span>3</span>,width = <span>2</span>) <span># offset为多序列比对结果与进化树之间的距离</span><br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.6064814814814815" data-type="png" data-w="1080" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMkZb6UdzP7p0zWejpzGCNPYzFCHKJe1X8PFwZL0sz3EM2mFibhRkPlyg/640?wx_fmt=png" src="https://mmbiz.qpic.cn/sz_mmbiz_png/9qvDEYXFF7YqMla3nCypkKXg5mZdOUrMkZb6UdzP7p0zWejpzGCNPYzFCHKJe1X8PFwZL0sz3EM2mFibhRkPlyg/640?wx_fmt=png"></figure><p data-tool="mdnice编辑器">最后，进化树的可视化就完成了，上面只展示了一部分比较基础的绘图方法，想要继续绘制更多高级的好看的图形还是需要自己去看书学习。</p><p data-tool="mdnice编辑器">这次的分享就到这里啦，如果喜欢就点个赞吧。</p><hr data-tool="mdnice编辑器"><p data-tool="mdnice编辑器"><strong>参考资料</strong></p><p data-tool="mdnice编辑器">《Phylogenetic Trees Made Easy》第五版，Barry G. Hall，2018</p><p data-tool="mdnice编辑器">《R实战 系统发育树的数据集成操作及可视化》第一版，余光创，2023</p><p data-tool="mdnice编辑器">《生物信息学》第一版，李霞，2010</p></section><p><br></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/8LWMm7wwfKehGxTNCqEwkw",target="_blank" rel="noopener noreferrer">原文链接</a>
