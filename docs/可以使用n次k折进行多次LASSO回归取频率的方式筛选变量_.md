---
title: "可以使用n次k折进行多次LASSO回归取频率的方式筛选变量！"
date: 2022-12-29T15:35:45Z
draft: ["false"]
tags: [
  "fetched",
  "生信作曲家"
]
categories: ["Acdemic"]
---
可以使用n次k折进行多次LASSO回归取频率的方式筛选变量！ by 生信作曲家
------
<div><section><h3><span>前言</span></h3><blockquote><p><span></span><span>生信作曲家一直致力于构建国内</span><span><strong>和谐、开放、可持续</strong></span><span><strong>的生物信息交流平台</strong>。生信作曲家的目标是<strong>为每个科研人扫清科研路上的一切障碍，让生物信息学人人可做</strong>。目前，生信作曲家已推出</span><span><strong>"</strong><strong>跟着一区文章学通机器学习</strong><strong>"</strong></span><span>，<strong>"</strong><strong>跟着一区文章学通单细胞</strong><strong>"</strong><strong>，Bootstrap，CIBERSORTx, NTP, TICPE，metaVIPER算法</strong></span><span>等多种强力教程，同时也兼具</span><strong><span>GEO数据库</span></strong><span>，</span><span><strong>ICGC数据库</strong></span><span>数据整理等核心入门技术教学，开办</span><span><strong>暑期</strong><strong>发文计划RS,max,ultra，7天发文A计划</strong><strong>，五一创新发文计划pro</strong></span><span><strong>，生信中秋分享会、小年夜分享会、暑期集训营和冬季集训营</strong>等多次。辅导同学实现纯生信SCI发表硕果累累，帮助同学实现医学事业路上的理想与追求。</span></p></blockquote><p>我们都知道，LASSO回归需要设置随机数，<strong>每次运行的结果可能是不一样的</strong>，有些同学也会去用最好的一次结果去发表文章，实际上，我们可以通过N次K折的方式反复进行LASSO，最终留下最高频出现的变量作为最终变量。</p><h3><span>代码实操</span><br></h3></section><section><pre><code>load(<span>'lasso_test.Rdata'</span>)<br></code></pre><p><img data-ratio="0.5917464996315401" data-src="https://mmbiz.qpic.cn/mmbiz_png/mo60jlFOtaA0djOxNySVMwclcjhicSYr2tbqCkm8kF5LYYr2cgd0TmK8kib7G9rUp5RSXlmWPWkVViaZUTyr9WmSg/640?wx_fmt=png" data-type="png" data-w="1357" src="https://mmbiz.qpic.cn/mmbiz_png/mo60jlFOtaA0djOxNySVMwclcjhicSYr2tbqCkm8kF5LYYr2cgd0TmK8kib7G9rUp5RSXlmWPWkVViaZUTyr9WmSg/640?wx_fmt=png"></p><pre><code>rt$group=ifelse(rt$group==<span>'Normal'</span>,<span>0</span>,<span>1</span>)<br>table(rt$group)<br><br><span># 去掉全为0 的基因</span><br>rt=rt[,colSums(rt)!=<span>0</span>]<br>outTab=data.frame()<br>pFilter=<span>0.05</span><br><span>for</span>(gene <span>in</span> colnames(rt[,<span>2</span>:(ncol(rt))])){<br>  set.seed(<span>123456</span>)<br>  glm=glm(group ~ rt[,gene], data = rt,family= binomial(link=<span>'logit'</span>))<br>  glmSummary = summary(glm)<br>  OR=exp(glm$coefficients)[<span>2</span>]<br>  OR_CI=exp(confint(glm,level = <span>0.95</span>))<br>  OR.95L=OR_CI[<span>2</span>,<span>1</span>]<br>  OR.95H=OR_CI[<span>2</span>,<span>2</span>]<br>  glmP=glmSummary$coefficients[,<span>"Pr(&gt;|z|)"</span>][<span>2</span>]<br>  <span>if</span>(glmP&lt;pFilter){<br>    outTab=rbind(outTab,<br>                 cbind(gene=gene,<br>                       OR=OR,<br>                       OR.95L=OR.95L,<br>                       OR.95H=OR.95H,<br>                       pvalue=glmP))<br>  }<br>}<br><br><br>rt=rt[,c(<span>'group'</span>,outTab$gene)]<br><br><br>folds &lt;- createMultiFolds(y=rt$group,k=<span>10</span>,times=<span>10</span>)<span>###10折200次划分,这里为节省时间做10次</span><br><br><br><span>#设定循环次数</span><br>gene = c()<br> <span>for</span>(i <span>in</span> <span>1</span>:<span>100</span>){<br>   <span>#设定训练组和验证组</span><br>   train&lt;- rt[ folds[[i]],] <br>   test &lt;- rt[-folds[[i]],] <br>   x = as.matrix(train[,c(-<span>1</span>)])<br>   y = train[,c(<span>1</span>)]<br>   <span>#训练组建模</span><br>   fitCV &lt;- cv.glmnet(x, y, family = <span>"binomial"</span>,<br>                    type.measure = <span>"class"</span>,<br>                    nfolds = <span>5</span>)<br>   fit &lt;- glmnet(x, y, family = <span>"binomial"</span>, alpha = <span>1</span>) <span># make sure alpha = 1</span><br>   <span># get the coef</span><br>   coef.min = coef(fitCV, s = <span>"lambda.min"</span>) <br>   <span># coef.min</span><br>   cv_coef = coef.min %&gt;% as.matrix() %&gt;% as.data.frame %&gt;% filter(abs(.)&gt;<span>0</span>)<br>   gene = c(gene,row.names(cv_coef))<br> }<br><br>sort_gene = data.frame(table(gene)) %&gt;% <br>  arrange(desc(Freq)) %&gt;% <br>  filter(Freq&gt;<span>10</span>)<br><br></code></pre><p><img data-ratio="2.200534759358289" data-src="https://mmbiz.qpic.cn/mmbiz_png/mo60jlFOtaA0djOxNySVMwclcjhicSYr2jfZCRrb7PUDcFtNXZsu9wbOcQ4vy4yp7dRswv5j2jWC2GBvicKUuFzg/640?wx_fmt=png" data-type="png" data-w="374" src="https://mmbiz.qpic.cn/mmbiz_png/mo60jlFOtaA0djOxNySVMwclcjhicSYr2jfZCRrb7PUDcFtNXZsu9wbOcQ4vy4yp7dRswv5j2jWC2GBvicKUuFzg/640?wx_fmt=png"></p></section><section><h3><span>后记</span></h3><p>如上述我们可以挑取出现频率较高的纳入，例如ACY1,CSTP2等每一次回归都出现，这样可以避免偶然一次出现的基因。当然也可以通过bootstrap的方式实现上述的抽样。</p><p>交流更多，加交流群 </p><p><img data-ratio="1" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/mo60jlFOtaB9Vq4TQbMtR81HOfuhy7jkZsUypgwNYHTiaEFuvXNqI8z2nlDYc7tbrJ4o7W7dAgqRQPp2lDqfLbA/640?wx_fmt=png" data-type="png" data-w="512" src="https://mmbiz.qpic.cn/mmbiz_png/mo60jlFOtaB9Vq4TQbMtR81HOfuhy7jkZsUypgwNYHTiaEFuvXNqI8z2nlDYc7tbrJ4o7W7dAgqRQPp2lDqfLbA/640?wx_fmt=png"></p><p><br></p></section><section><br></section><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/Bsmrdce4oWB5OhfcupkluA",target="_blank" rel="noopener noreferrer">原文链接</a>
