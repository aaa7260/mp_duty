---
title: "R tips：topptx为何无法导出ggsurvplot图片"
date: 2023-06-10T10:38:47Z
draft: ["false"]
tags: [
  "fetched",
  "生信菜鸟团"
]
categories: ["Acdemic"]
---
R tips：topptx为何无法导出ggsurvplot图片 by 生信菜鸟团
------
<div><p>生存分析中常常使用R包survminer用于可视化生存分析的结果，比如只需要ggsurvplot函数就可以非常简单的绘制生存分析的KM曲线。</p><p>比如如下代码所示：</p><pre><code><span>library</span>(survival)<br><span>library</span>(survminer)<br><span>library</span>(eoffice)<br><span>library</span>(magrittr)<br><br><br>fit &lt;- survfit(Surv(time, status) ~ sex, data = lung)<br><br>p &lt;- <br>  ggsurvplot(<br>    fit,<br>    data = lung,<br>    risk.table = <span>T</span>,<br>    pval = <span>TRUE</span><br>  )<br></code></pre><p>图示如下：</p><figure><p><img data-ratio="0.7132701421800948" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Losic2ibsmCtU3Jvl2bM5Ho1my6owaRFuvEYB8HTib1IS40I2eBdJbT4AHGGUzSaZqYnsn7Z7Fe81icxY3Q/640?wx_fmt=png" data-type="png" data-w="844" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Losic2ibsmCtU3Jvl2bM5Ho1my6owaRFuvEYB8HTib1IS40I2eBdJbT4AHGGUzSaZqYnsn7Z7Fe81icxY3Q/640?wx_fmt=png"></p></figure><p>但是如果我们尝试将这张图片保存到文件中的时候就会发现一个现象，它总是先打印一个空白页，可以尝试一下如下代码：</p><pre><code>pdf(<span>"survival.pdf"</span>)<br>print(p)<br>dev.off()<br></code></pre><h3><span>ggsurvplot默认先打印一个空白页</span></h3><p>ggsurvplot绘制的图形对象是一个基于list封装的 ggsurvplot对象。</p><pre><code>class(p)<br><span># [1] "ggsurvplot" "ggsurv"     "list"      </span><br></code></pre><p>而R中显示图片的函数很多都是通过print泛型函数实现的，所以我们可以查看一下ggsurvplot对象真正源码，根据泛型函数的规则：“泛型.类名”，可以知道我们应该去找print.ggsurvplot函数。</p><p>这个函数在survminer包中，注意由于这个函数不是survminer包的导出函数，所以一定要使用:::运算符而不是::运算符才能从survminer包拿到这个函数。</p><blockquote><p>分清楚函数对象与函数调用的区别</p><p>在R中拿到函数源码非常简单，只需要在R键入函数名确定即可（S4类方法源码稍微麻烦一些，但是也是麻烦一点点）。其实这时是获得的函数对象本身，只不过在R console中键入一个变量，默认就是打印它。</p><p>而调用一个函数则需要在一个函数名后面加上小括号，括号内的参数根据情况是可选的，但是只要加了小括号就是调用。</p><p>例如：</p><pre><code><span># mean不加括号，则是函数对象本身，它可以继续复制给其他变量</span><br>self_func &lt;- mean<br><br><span># 加括号则是调用，self_func也可以被调用，其结果和mean没有区别</span><br>val &lt;- mean(<span>1</span>:<span>5</span>)<br>self_val &lt;- self_func(<span>1</span>:<span>5</span>)<br><br><span># self_func是一个函数，而slef_val是一个值</span><br>class(self_func)<br>class(self_val)<br></code></pre></blockquote><p>可以发现ggsurvplot先打印一个空白页是它定义好的一个操作，而且可以关闭。</p><pre><code>survminer:::print.ggsurvplot<br><span># function (x, surv.plot.height = NULL, risk.table.height = NULL, </span><br><span>#     ncensor.plot.height = NULL, newpage = TRUE, ...) </span><br><span># {</span><br><span>#     res &lt;- .build_ggsurvplot(x = x, surv.plot.height = surv.plot.height, </span><br><span>#         risk.table.height = risk.table.height, ncensor.plot.height = ncensor.plot.height)</span><br><span>#     if (newpage) </span><br><span>#         grid::grid.newpage() # &lt;---- newpage默认是TRUE，所以会先打印一个空白页 ----</span><br><span>#     grid::grid.draw(res)</span><br><span># }</span><br></code></pre><p>比如再测试一下如下代码，可以发现空白页就消失了：</p><pre><code>pdf(<span>"survival.pdf"</span>)<br>print(p, newpage = <span>FALSE</span>)<br>dev.off()<br></code></pre><h3><span>topptx无法导出ggsurvplot绘制的图片</span></h3><blockquote><p>topptx可以将图片导出为可编辑的ppt格式，非常便于后续调整图片格式。</p></blockquote><p>所以也就不难理解，为什么使用topptx导出ggsurvplot总会报错如下错误了：</p><pre><code>topptx(p, filename = <span>"survival.pptx"</span>) <br><span># Error in grid::grid.newpage() : pptx device only supports one page</span><br></code></pre><p>可是如何解决呢？</p><p>第一个想法就是先看看topptx是如何保存图片的，是否可以把newpage参数传进去。老办法先看源码：</p><pre><code>topptx<br><span># function (figure = NULL, filename = NULL, nr = 1, nc = 1, irow = 1, </span><br><span>#           icol = 1, onsame = FALSE, title = "", left = 0.15, </span><br><span>#           top = 0.15, width = 6, height = 6, append = FALSE, devsize = FALSE, </span><br><span>#           units = "in") </span><br><span># {</span><br><span>#   toffice(figure = figure, filename = filename, format = "pptx", </span><br><span>#           nr = nr, nc = nc, irow = irow, icol = icol, onsame = onsame, </span><br><span>#           title = title, left = left, top = top, width = width, </span><br><span>#           height = height, append = append, devsize = devsize, </span><br><span>#           units = units)</span><br><span># }</span><br></code></pre><p>topptx只是简单的封装了toffice函数，继续查看它的源码。这个函数较长，我们主要关心topptx为何是失败，因此只关心<code>if (format == "ppt") {</code>这句代码之后的内容：</p><p>然后就可以知道toffice的源码中是直接调用的print(p)，已经将打印p的方法写死了，因此除了修改源码外，我们就没有办法再传newpage参数到这里了。</p><pre><code><span># 查看源码在R中键入toffice即可</span><br><br><span># ...部分代码省略...</span><br><span>if</span> (format == <span>"ppt"</span>) {<br><span># ...部分代码省略...</span><br>  doc &lt;- ph_with(<br>    doc,<br>    dml(code = print(p)), <span># &lt;--- 直接打印图形对象 -------</span><br>    location = ph_location(<br>      left = (icol - <span>1</span>) * ws + (icol - <span>1</span>) * margins[<span>"left"</span>] + offl,<br>      top = (irow - <span>1</span>) * hs + (irow - <span>1</span>) * margins[<span>"top"</span>] + offt,<br>      width = w,<br>      height = h<br>    )<br>  )<br><span># ...部分代码省略...</span><br></code></pre><p>既然上面的思路不好用，那可以尝试我们自己封装一个newpage默认为FALSE的print.ggsurvplot函数。</p><p>当然如果直接这样处理的话，那么这个函数就是定义在R的全局命名空间（.GlobalEnv）。而由于R中函数调用时是会把相关包的命名空间重新载入，导致我们自定义的函数的优先级没有二次导入的包函数的优先级高，因此仍然是优先调用的survminer包里面的print.ggsurvplot函数。</p><p>不过既然print是一个S3泛型方法，我们可以利用R中S3类的分发优先级提高我们的自定义函数级别。</p><p>具体操作就是先把ggsurvplot改为ggsurvplot2类，然后我们定义print.ggsurvplot2函数，这样由于survminer中就不存在print.ggsurvplot2函数，R会依次往上寻找这个函数，最终就可以在全局命名空间中找到它，这样就会调用我们自定义的函数：</p><pre><code><span># 将ggsurvplot改为ggsurvplot2，这样就可以调用我们自己定义的print函数</span><br>change_to_ggsurvplot2 &lt;- <span>function</span>(x) {<br>  stopifnot(<span>"ggsurvplot"</span> %<span>in</span>% class(x))<br><br>  class(x) &lt;- c(<span>"ggsurvplot2"</span>, class(x))<br>  x<br>} <br><br><span># 封装print.ggsurvplot，默认newpage为FALSE</span><br>print.ggsurvplot2 &lt;- <span>function</span>(x, newpage = <span>FALSE</span>, <span>...</span>) {<br>  survminer:::print.ggsurvplot(x, newpage = newpage, <span>...</span>)<br>}<br></code></pre><p><strong>使用起来非常简单</strong>：</p><pre><code>p %&gt;% change_to_ggsurvplot2() %&gt;% topptx(filename = <span>"survival.pptx"</span>)<br></code></pre><p>这个时候的类名如下，ggsurvplot2的优先级高于ggsurvplot：</p><pre><code>p %&gt;% change_to_ggsurvplot2() %&gt;% class<br><span># [1] "ggsurvplot2" "ggsurvplot"  "ggsurv"      "list" </span><br></code></pre><h3><span>为什么不传入ggsurvplot对象反而可以成功</span></h3><p>但是如果先打印这个图片，然后不传给topptx函数图形对象直接保存文件，反而可以成功保存：</p><pre><code>print(p)<br>topptx(filename = <span>"survival2.pptx"</span>)<br></code></pre><p>原因自然还是在toffice的源码里面：</p><pre><code><span># ...部分代码省略...</span><br><span>if</span> (is.null(figure)) {<br>  <span>if</span> (dev.cur() == <span>1</span>)<br>    <span>stop</span>(<span>"No graphics device found"</span>)<br>  p &lt;- recordPlot() <span># &lt;------------</span><br>}e<br>lse {<br>  <span>if</span> (is.function(figure)) {<br>    p &lt;- figure()<br>  }e<br>  lse {<br>    p &lt;- figure<br>  }<br>}<br><span># ...部分代码省略...</span><br></code></pre><p>而recordPlot函数返回的对象就不再是ggsurvplot对象了：</p><pre><code>print(p)<br>class(recordPlot())<br><span># [1] "recordedplot"</span></code></pre><p><br></p><p><mp-style-type data-value="10000"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/8sOwl0CcxETca07Yy9EjyQ",target="_blank" rel="noopener noreferrer">原文链接</a>
