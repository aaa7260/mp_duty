---
title: "批量抠取Seurat中Dotplot的作图数据"
date: 2024-02-24T10:36:12Z
draft: ["false"]
tags: [
  "fetched",
  "生信小博士"
]
categories: ["Acdemic"]
---
批量抠取Seurat中Dotplot的作图数据 by 生信小博士
------
<div><h3><span><strong><span>本文分为三部分</span></strong></span></h3><ul><li><p><strong><span>1.问题来源<br></span></strong></p></li><li><p><strong><span>2.代码实操</span></strong></p></li><li><p><strong><span>3.这么做的意义</span></strong></p></li></ul><h3><span>问题来源<span></span></span></h3><p><strong><span>我们经常能看到这种气泡图，但是如何取出该基因的画图数据呢?你可能已经想到解决办法了：<a target="_blank" href="http://mp.weixin.qq.com/s?__biz=Mzg2NDcxMzYwNg==&amp;mid=2247485564&amp;idx=1&amp;sn=bb9760a377acd1a36b8f586c2baeb655&amp;chksm=ce646695f913ef83d4c1cf78366dcac42812d3d7e817dcfc714f85360b3cb7b90dcb87a6413d&amp;scene=21#wechat_redirect" textvalue="VlnPlot画的其实不是原始数据" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">VlnPlot画的其实不是原始数据</a></span></strong></p><p><strong><span>单个基因的值比较好取，但是如何取出全部基因的</span></strong><strong><span>Average Expression和 Percent Expressed值？</span></strong></p><p><img data-galleryid="" data-imgfileid="100002399" data-ratio="0.9449664429530201" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkspSCn1cEwzvv1xAOJe0oQlNqJoF43dhJBH6RBDQK6LvXYdF0BTT3wl6YXV3wM9pEdwWPeUucJsGA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="745" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkspSCn1cEwzvv1xAOJe0oQlNqJoF43dhJBH6RBDQK6LvXYdF0BTT3wl6YXV3wM9pEdwWPeUucJsGA/640?wx_fmt=png&amp;from=appmsg"></p><h3><span>代码实操<span></span></span></h3><p><span><strong><span>解决这个问题可以根据Dotplot这个函数来看，毕竟Average Expression和 Percent Expressed值都</span></strong></span><span><strong><span>是通过这个函数画出来的，这里我直接给出代码</span></strong></span></p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="http"><code><span><br></span></code><code><span><br></span></code><code><span>#########################设置我自己的r包加载路径，通常你不需要运行这段代码-----</span></code><code><span>.libPaths(c(</span></code><code><span>  <span>'/home/rootyll/seurat_v5/'</span>,</span></code><code><span>  <span>"/usr/local/lib/R/site-library"</span>, <span>"/usr/lib/R/site-library"</span>, <span>"/usr/lib/R/library"</span></span></code><code><span>))</span></code><code><span>###################################################################################<span>333</span></span></code><code><span>source(<span>'~/OLP_combine/scRNA_scripts/lib.R'</span>)</span></code><code><span>library(Seurat)</span></code><code><span>print(getwd())</span></code><code><span>print(.libPaths())</span></code><code><span><br></span></code><code><span><br></span></code><code><span>dir.create(<span>'~/gzh/20240220_获取表达marker基因的百分比pct'</span>)</span></code><code><span>setwd(<span>'~/gzh/20240220_获取表达marker基因的百分比pct'</span>)</span></code><code><span><br></span></code><code><span>sce.all.int=readRDS(<span>"~/gzh/pbmc3k_final.rds"</span>)</span></code><code><span><br></span></code><code><span>sce.all.<span>int@</span>assays$<span>RNA@</span><span>data</span></span></code><code><span>DimPlot(sce.all.int)</span></code><code><span>head(sce.all.<span>int@</span>meta.<span>data</span>)</span></code><code><span><br></span></code><code><span>sce.all.int$labels=Idents(sce.all.int)</span></code><code><span>sce.all.int$group=ifelse( sce.all.int$nFeature_RNA&gt;<span>800</span>,<span>'Healthy'</span>,<span>'OLP'</span>)</span></code><code><span>All.merge=sce.all.int</span></code><code><span>table(All.merge$group)</span></code><code><span>DimPlot(All.merge,label = TRUE)</span></code><code><span><br></span></code><code><span>head(sce.all.<span>int@</span>meta.<span>data</span>)</span></code><code><span><br></span></code><code><span><span>markers_croase=FindAllMarkers(All.merge,only.pos = TRUE)</span></span></code><code><span>head(markers_croase);print(getwd())</span></code><code><span>#write.csv(markers_croase,file = <span>'markers_croase.csv'</span>)</span></code><code><span>markers_croase=read.csv(<span>'./markers_croase.csv'</span>)</span></code><code><span>head(markers_croase);dim(markers_croase)</span></code><code><span><br></span></code><code><span>head(sce.all.<span>int@</span>meta.<span>data</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code></pre></section><p><br></p><p><span><strong><span>上述准备好之后，就可以按照下面的代码走</span></strong></span><br></p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="kotlin"><code><span>DotPlot(sce.all.int,features = <span>"CD3E"</span>)</span></code><code><span><br></span></code><code><span>#计算每个基因的pct和avg.exp,以细胞类型为细胞类型分组信息,信息在meta下面的labels----</span></code><code><span><br></span></code><code><span><span>object</span>=sce.all.int</span></code><code><span>features= markers_croase$gene</span></code><code><span>assay = NULL;cols = c(<span>"lightgrey"</span>,</span></code><code><span>                      <span>"blue"</span>);</span></code><code><span>col.min = -<span>2.5</span>; col.max = <span>2.5</span>; dot.min = <span>0</span>; dot.scale = <span>6</span>;</span></code><code><span>idents =   Idents(sce.all.int)       ; group.<span>by</span> = <span>"labels"</span>;</span></code><code><span><br></span></code><code><span>split.<span>by</span> = NULL; cluster.idents = FALSE;</span></code><code><span>scale = TRUE;</span></code><code><span>scale.<span>by</span> = <span>"radius"</span>; scale.min = NA; scale.max = NA</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>assay &lt;- assay %||% DefaultAssay(<span>object</span> = <span>object</span>) ;assay</span></code><code><span>DefaultAssay(<span>object</span> = <span>object</span>) &lt;- assay</span></code><code><span>split.colors &lt;- !<span>is</span>.<span>null</span>(x = split.<span>by</span>) &amp;&amp; !any(cols %<span>in</span>%</span></code><code><span>                                                 rownames(x = brewer.pal.info));split.colors</span></code><code><span><br></span></code><code><span>##SCALE------</span></code><code><span>scale.func &lt;- switch(EXPR = scale.<span>by</span>, size = scale_size,</span></code><code><span>                     radius = scale_radius, stop(<span>"'scale.by' must be either 'size' or 'radius'"</span>))</span></code><code><span><br></span></code><code><span>feature.groups &lt;- NULL</span></code><code><span><br></span></code><code><span><br></span></code><code><span>#features是否是list----</span></code><code><span><span>if</span> (<span>is</span>.list(features) | any(!<span>is</span>.na(names(features)))) {</span></code><code><span>  feature.groups &lt;- unlist(x = sapply(X = <span>1</span>:length(features),</span></code><code><span>                                      FUN = function(x) {</span></code><code><span>                                        <span>return</span>(rep(x = names(x = features)[x], each = length(features[[x]])))</span></code><code><span>                                      }))</span></code><code><span>  </span></code><code><span>  <span>if</span> (any(<span>is</span>.na(x = feature.groups))) {</span></code><code><span>    warning(<span>"Some feature groups are unnamed."</span>, call. = FALSE,</span></code><code><span>            immediate. = TRUE)</span></code><code><span>  }</span></code><code><span>  features &lt;- unlist(x = features)</span></code><code><span>  names(x = feature.groups) &lt;- features</span></code><code><span>}</span></code><code><span><br></span></code><code><span><br></span></code><code><span>cells &lt;- unlist(x = CellsByIdentities(<span>object</span> = <span>object</span>, cells = colnames(<span>object</span>[[assay]]),</span></code><code><span>                                      idents =Idents(<span>object</span>)   ));length(cells)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>#<span>3</span> 获取画图数据--------</span></code><code><span><span>data</span>.features &lt;- FetchData(<span>object</span> = <span>object</span>, vars = features,  #slot = <span>'data'</span>,</span></code><code><span>                           cells = cells);dim(<span>data</span>.features);</span></code><code><span>head(<span>data</span>.features[,<span>1</span>:<span>10</span>])</span></code><code><span>dim(<span>data</span>.features)</span></code><code><span>length(features)</span></code><code><span>unique(features) |&gt;length()</span></code><code><span># mydata=FetchData(sce.all.int,vars = features)</span></code><code><span># head(mydata[,<span>1</span>:<span>10</span>])</span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>data</span>.features$id &lt;- <span>if</span> ( <span>is</span>.<span>null</span>(x = group.<span>by</span>) ) {</span></code><code><span>  Idents(<span>object</span> = <span>object</span>)[cells, drop = TRUE]  #Drop unused levels</span></code><code><span>} <span>else</span> {</span></code><code><span>  <span>object</span>[[group.<span>by</span>, drop = TRUE]][cells, drop = TRUE]</span></code><code><span>}</span></code><code><span><br></span></code><code><span>head(<span>data</span>.features);dim(<span>data</span>.features)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>if</span> (!<span>is</span>.factor(x = <span>data</span>.features$id)) {</span></code><code><span>  <span>data</span>.features$id &lt;- factor(x = <span>data</span>.features$id)</span></code><code><span>}</span></code><code><span><br></span></code><code><span>id.levels &lt;- levels(x = <span>data</span>.features$id)</span></code><code><span><span>data</span>.features$id &lt;- <span>as</span>.vector(x = <span>data</span>.features$id)</span></code><code><span>head(<span>data</span>.features[,(ncol(<span>data</span>.features)-<span>1</span>):ncol(<span>data</span>.features)]);dim(<span>data</span>.features)</span></code><code><span><br></span></code><code><span>#<span>4</span>是否split------</span></code><code><span><span>if</span> (!<span>is</span>.<span>null</span>(x = split.<span>by</span>)) {</span></code><code><span>  splits &lt;- FetchData(<span>object</span> = <span>object</span>, vars = split.<span>by</span>)[cells,</span></code><code><span>                                                        split.<span>by</span>]</span></code><code><span>  <span>if</span> (split.colors) {</span></code><code><span>    <span>if</span> (length(x = unique(x = splits)) &gt; length(x = cols)) {</span></code><code><span>      stop(paste0(<span>"Need to specify at least "</span>, length(x = unique(x = splits)),</span></code><code><span>                  <span>" colors using the cols parameter"</span>))</span></code><code><span>    }</span></code><code><span>    cols &lt;- cols[<span>1</span>:length(x = unique(x = splits))]</span></code><code><span>    names(x = cols) &lt;- unique(x = splits)</span></code><code><span>  }</span></code><code><span>  <span>data</span>.features$id &lt;- paste(<span>data</span>.features$id, splits,</span></code><code><span>                            sep = <span>"_"</span>)</span></code><code><span>  unique.splits &lt;- unique(x = splits)</span></code><code><span>  id.levels &lt;- paste0(rep(x = id.levels, each = length(x = unique.splits)),</span></code><code><span>                      <span>"_"</span>, rep(x = unique(x = splits), times = length(x = id.levels)))</span></code><code><span>}</span></code><code><span><br></span></code><code><span>head(<span>data</span>.features);dim(<span>data</span>.features)</span></code><code><span><br></span></code><code><span><span>data</span>.plot &lt;- lapply(X = unique(x = <span>data</span>.features$id), FUN = function(ident) {</span></code><code><span>  </span></code><code><span>  #ident=<span>"Myofibroblasts"</span></span></code><code><span>  <span>data</span>.use &lt;- <span>data</span>.features[<span>data</span>.features$id == ident,</span></code><code><span>                            <span>1</span>:(ncol(x = <span>data</span>.features) - <span>1</span>), drop = FALSE]</span></code><code><span>  head(<span>data</span>.use);dim(<span>data</span>.use)</span></code><code><span>  </span></code><code><span>  </span></code><code><span>  #<span>5</span> 计算avg.exp和pct.exp----</span></code><code><span>  avg.exp &lt;- apply(X = <span>data</span>.use, MARGIN = <span>2</span>, FUN = function(x) {</span></code><code><span>    <span>return</span>(mean(x = expm1(x = x)))        #expm1() function <span>in</span> R Language <span>is</span> used to compute exponential minus <span>1</span> i.e, exp()-<span>1</span>.</span></code><code><span>  });head(avg.exp);expm1(<span>1</span>)</span></code><code><span>  </span></code><code><span>  pct.exp &lt;- apply(X = <span>data</span>.use, MARGIN = <span>2</span>, FUN = PercentAbove, #Calculate the percentage of a vector above some threshold   #表示要应用的函数是PercentAbove，这个函数会计算大于指定阈值的数值所占比例。</span></code><code><span>                   threshold = <span>0</span>);pct.exp</span></code><code><span>  <span>return</span>(list(avg.exp = avg.exp, pct.exp = pct.exp))</span></code><code><span>  </span></code><code><span>})</span></code><code><span>head(<span>data</span>.plot)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>names(x = <span>data</span>.plot) &lt;- unique(x = <span>data</span>.features$id) ;head(<span>data</span>.plot)</span></code><code><span><br></span></code><code><span><span>if</span> (cluster.idents) {</span></code><code><span>  mat &lt;- <span>do</span>.call(what = rbind, args = lapply(X = <span>data</span>.plot,</span></code><code><span>                                             FUN = unlist));mat</span></code><code><span>  mat &lt;- scale(x = mat);mat</span></code><code><span>  id.levels &lt;- id.levels[hclust(d = dist(x = mat))$order]</span></code><code><span>}</span></code><code><span><br></span></code><code><span><br></span></code><code><span>head(<span>data</span>.plot); #head(<span>data</span>.use)</span></code><code><span><br></span></code><code><span><span>data</span>.plot &lt;- lapply(X = names(x = <span>data</span>.plot), FUN = function(x) {</span></code><code><span>  <span>data</span>.use &lt;- <span>as</span>.<span>data</span>.frame(x = <span>data</span>.plot[[x]])</span></code><code><span>  <span>data</span>.use$features.plot &lt;- rownames(x = <span>data</span>.use)</span></code><code><span>  <span>data</span>.use$id &lt;- x</span></code><code><span>  <span>return</span>(<span>data</span>.use)</span></code><code><span>});head(<span>data</span>.plot)</span></code><code><span><br></span></code><code><span><span>data</span>.plot &lt;- <span>do</span>.call(what = <span>"rbind"</span>, args = <span>data</span>.plot);<span>data</span>.plot</span></code><code><span><br></span></code><code><span><span>if</span> ( !<span>is</span>.<span>null</span>(x = id.levels) ) {</span></code><code><span>  <span>data</span>.plot$id &lt;- factor(x = <span>data</span>.plot$id, levels = id.levels)</span></code><code><span>}</span></code><code><span>ngroup &lt;- length(x = levels(x = <span>data</span>.plot$id));ngroup</span></code><code><span><br></span></code><code><span><span>if</span> (ngroup == <span>1</span>) {</span></code><code><span>  scale &lt;- FALSE</span></code><code><span>  warning(<span>"Only one identity present, the expression values will be not scaled"</span>,</span></code><code><span>          call. = FALSE, immediate. = TRUE)</span></code><code><span>}<span>else</span> <span>if</span> (ngroup &lt; <span>5</span> &amp; scale) {</span></code><code><span>  warning(<span>"Scaling data with a low number of groups may produce misleading results"</span>,</span></code><code><span>          call. = FALSE, immediate. = TRUE)</span></code><code><span>}</span></code><code><span><br></span></code><code><span>head(<span>data</span>.plot)</span></code><code><span><br></span></code><code><span>avg.exp.scaled &lt;- sapply(X = unique(x = <span>data</span>.plot$features.plot),</span></code><code><span>                         FUN = function(x) {</span></code><code><span>                           <span>data</span>.use &lt;- <span>data</span>.plot[<span>data</span>.plot$features.plot ==</span></code><code><span>                                                   x, <span>"avg.exp"</span>]</span></code><code><span>                           <span>if</span> (scale) {</span></code><code><span>                             <span>data</span>.use &lt;- scale(x = log1p(<span>data</span>.use))</span></code><code><span>                             <span>data</span>.use &lt;- MinMax(<span>data</span> = <span>data</span>.use, min = col.min,</span></code><code><span>                                                max = col.max)</span></code><code><span>                           }</span></code><code><span>                           <span>else</span> {</span></code><code><span>                             <span>data</span>.use &lt;- log1p(x = <span>data</span>.use)</span></code><code><span>                           }</span></code><code><span>                           <span>return</span>(<span>data</span>.use)</span></code><code><span>                         });avg.exp.scaled</span></code><code><span><br></span></code><code><span>avg.exp.scaled &lt;- <span>as</span>.vector(x = t(x = avg.exp.scaled))</span></code><code><span><span>if</span> (split.colors) {</span></code><code><span>  avg.exp.scaled &lt;- <span>as</span>.numeric(x = cut(x = avg.exp.scaled,</span></code><code><span>                                       breaks = <span>20</span>))</span></code><code><span>}</span></code><code><span><span>data</span>.plot$avg.exp.scaled &lt;- avg.exp.scaled</span></code><code><span><br></span></code><code><span>head(<span>data</span>.plot);dim(<span>data</span>.plot)</span></code><code><span><br></span></code><code><span># <span>data</span>.plot$features.plot &lt;- factor(x = <span>data</span>.plot$features.plot,</span></code><code><span>#                                   levels = features);<span>data</span>.plot</span></code><code><span># <span>data</span>.plot$pct.exp[<span>data</span>.plot$pct.exp &lt; dot.min] &lt;- NA</span></code><code><span># <span>data</span>.plot$pct.exp &lt;- <span>data</span>.plot$pct.exp * <span>100</span> ;<span>data</span>.plot</span></code><code><span><span>data</span>.plot$gene=<span>data</span>.plot$features.plot</span></code><code><span><br></span></code><code><span>head(<span>data</span>.plot) </span></code><code><span><br></span></code><code><span>head(markers_croase)</span></code><code><span><br></span></code><code><span>merged_data &lt;- merge( markers_croase,<span>data</span>.plot, <span>by</span> = <span>"gene"</span>)</span></code><code><span>head(merged_data)</span></code><code><span><br></span></code><code><span>merged_data[merged_data$gene==<span>'CD3E'</span>,]</span></code><code><span>dim(merged_data)</span></code><code><span><br></span></code><code><span>merged_data$<span>'pct.exp*100'</span>=merged_data$pct.exp*<span>100</span></span></code><code><span><br></span></code><code><span>head(merged_data)</span></code></pre></section><p><strong>最终的部分结果</strong></p><p><img data-galleryid="" data-imgfileid="100002407" data-ratio="0.5851851851851851" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkspSCn1cEwzvv1xAOJe0oQlmylenMR1Yl8b9mCCRZDeZRrBrRuDmIKLyyLOKMqw3Y0NZsnoys31Ug/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkspSCn1cEwzvv1xAOJe0oQlmylenMR1Yl8b9mCCRZDeZRrBrRuDmIKLyyLOKMqw3Y0NZsnoys31Ug/640?wx_fmt=png&amp;from=appmsg"></p><h3><span>这么做有什么意义？<span></span></span></h3><ul><li><p><span><strong><span>我完成推文之后才意识到，这样做似乎并没有太大的价值。</span></strong><span>如果，为了筛选出特异性的标记基因，我们可以直接利用findallmarkers结果中的pct1和pct2之间的差值，结合avglog2FC和P_val来实现。这种方法完全足够了。</span><strong><span></span></strong></span></p><p><span><strong><span></span></strong></span></p></li><li><p><span><strong><span>不过，这个过程的一个小收获是，我对pct（百分比）和average Expression平均表达量等参数有了更深的理解。</span></strong><span>可能这些表面上看起来没什么用的努力，实际上是在悄悄推动我在单细胞分析技术上的进步。</span><strong><span></span></strong></span></p></li></ul><p><img data-imgfileid="100002409" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_gif/4TKeL1ZejtlKxOib5kmKX6ic6eX0w0WK5jvhtz9yBRsO3OI4yr6S5iaLNM7AbAeuPDHXMvDdur2DRz9wyiax4lEviag/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" data-type="gif" data-w="240" src="https://mmbiz.qpic.cn/mmbiz_gif/4TKeL1ZejtlKxOib5kmKX6ic6eX0w0WK5jvhtz9yBRsO3OI4yr6S5iaLNM7AbAeuPDHXMvDdur2DRz9wyiax4lEviag/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1"><br></p><p><img data-imgfileid="100002408" data-ratio="0.05278592375366569" data-src="https://mmbiz.qpic.cn/mmbiz/4TKeL1Zejtlq03ZOSZiaTlic1MxgdKiaxTbOZ7ZSe0Xx1Ca8xF3L6Nyj1FYUajtYrSmRIHyZVSsAve0EAvEicZONpg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="other" data-w="341" src="https://mmbiz.qpic.cn/mmbiz/4TKeL1Zejtlq03ZOSZiaTlic1MxgdKiaxTbOZ7ZSe0Xx1Ca8xF3L6Nyj1FYUajtYrSmRIHyZVSsAve0EAvEicZONpg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p><strong><span>看完记得顺手点个</span></strong><span><strong><span>“在看”</span></strong></span><strong><span>哦！</span></strong></p><p><br></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/Khc1Ae-WI_OtGEErqt2V4A",target="_blank" rel="noopener noreferrer">原文链接</a>
