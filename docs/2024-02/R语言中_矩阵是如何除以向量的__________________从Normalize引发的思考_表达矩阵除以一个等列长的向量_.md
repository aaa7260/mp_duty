---
title: "R语言中，矩阵是如何除以向量的？。。。。。。。。。。。。。。。。。从Normalize引发的思考（表达矩阵除以一个等列长的向量）"
date: 2024-02-28T00:45:41Z
draft: ["false"]
tags: [
  "fetched",
  "生信小博士"
]
categories: ["Acdemic"]
---
R语言中，矩阵是如何除以向量的？。。。。。。。。。。。。。。。。。从Normalize引发的思考（表达矩阵除以一个等列长的向量） by 生信小博士
------
<div><section><section powered-by="xiumi.us"><section><section><section><section powered-by="xiumi.us"><section><section><p><span><strong><span>“R语言中，</span></strong><strong><span> log1p（x） 表示log（x+1），底数为自然数e</span></strong><span><strong><span>”</span></strong></span></span></p></section></section></section></section></section></section></section></section><p><br></p><section><section powered-by="xiumi.us"><section><section><p><span>01</span></p><p><span>—</span></p></section></section></section></section><section><span>问题起源</span><br></section><section><section powered-by="xiumi.us"><section><section><p><br></p><p><br></p><p><strong><span>今天对单细胞矩阵进行Normalize时候，遇到一个小问题：<span>矩阵除以一个与矩阵列数相同长度的向量，计算过程是怎样的？</span></span></strong></p><p><span>为了便于手机观看，创建一个3*5的表达矩阵。</span><strong><span></span></strong></p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="php"><code><span><span># 创建一个3*5矩阵，填充有1到15的连续数值</span></span></code><code><span>my_matrix &lt;- matrix(<span>1</span>:<span>15</span>, nrow = <span>3</span>, ncol = <span>5</span>)</span></code><code><span><span># 确保矩阵中的数值为双精度浮点数</span></span></code><code><span>my_matrix &lt;- matrix(<span>as</span>.double(<span>1</span>:<span>15</span>), nrow = <span>3</span>, ncol = <span>5</span>)</span></code><code><span><br></span></code><code><span><span># 打印矩阵</span></span></code><code><span><span>print</span>(my_matrix)</span></code><code><span>norm1=log1p(my_matrix/colSums(my_matrix)*<span>10000</span>) ;norm1</span></code><code><span><br></span></code><code><span>norm2=base::apply(X = my_matrix,MARGIN = <span>2</span>,</span></code><code><span>FUN = <span><span>function</span><span>(x)</span>    </span>{log1p( x/sum(x)*<span>10000</span>)     });norm2</span></code><code><span><br></span></code></pre></section><p><strong><span></span></strong></p><p><img data-galleryid="" data-imgfileid="100002436" data-ratio="0.2966700302724521" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345Sks9naZQjI9cias6nicOxhPoZukibFNiaBmZqx6Af9X64fonhiay62bOhiaEn6dksZJl2p4icocrR4DmMw8ibw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="991" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345Sks9naZQjI9cias6nicOxhPoZukibFNiaBmZqx6Af9X64fonhiay62bOhiaEn6dksZJl2p4icocrR4DmMw8ibw/640?wx_fmt=png&amp;from=appmsg"></p><section><section powered-by="xiumi.us"><section><section><p><span>02</span></p><p><span>—</span></p></section></section></section></section><section><span><span>结果</span></span></section><p><br></p><p><span><span><strong>从上述结果发现：norm1和norm2不一样。据此，提出我的问题：<strong><span><span>矩阵除以一个与矩阵列数相同长度的向量，计算过程是怎样的？</span></span></strong></strong></span></span><br></p><p><br></p><p><span><span>   后续我又检查了一下，尤其关注最后行代码</span></span></p><p><img data-galleryid="" data-imgfileid="100002437" data-ratio="1.257936507936508" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345Sks9naZQjI9cias6nicOxhPoZuEDCic8wYLenyvubv0wAJJ2azu4L9VX3NsPp7yiawv5h2268NeUnbzuibQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="252" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345Sks9naZQjI9cias6nicOxhPoZuEDCic8wYLenyvubv0wAJJ2azu4L9VX3NsPp7yiawv5h2268NeUnbzuibQ/640?wx_fmt=png&amp;from=appmsg"></p><section><section powered-by="xiumi.us"><section><section><p><span>03</span></p><p><span>—</span></p></section></section></section></section><section><span><span>如果在python中运行呢</span></span></section><p><strong><span><br></span></strong></p><p><strong><span>********************************python*************************************</span></strong></p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="properties"><code><span><span>import</span> <span>numpy as np</span></span></code><code><span><br></span></code><code><span><span># 定义一个3x5的矩阵，填充有1到15的连续数值</span></span></code><code><span><span>my_matrix</span> = <span>np.array(range(1, 16)).reshape(3, 5)</span></span></code><code><span><br></span></code><code><span><span># 方法1: 使用矩阵操作进行归一化和对数变换</span></span></code><code><span><span>norm1</span> = <span>np.log1p(my_matrix / my_matrix.sum(axis=0) * 10000)</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># 方法2: 使用apply_along_axis确保与方法1相同的处理</span></span></code><code><span><span>def</span> <span>normalize_and_log_transform(x):</span></span></code><code><span>    <span>normalized_counts</span> = <span>x / x.sum() * 10000</span></span></code><code><span>    <span>log_transformed_counts</span> = <span>np.log1p(normalized_counts)</span></span></code><code><span>    <span>return</span> <span>log_transformed_counts</span></span></code><code><span><span>norm2</span> = <span>np.apply_along_axis(normalize_and_log_transform, 0, my_matrix)</span></span></code><code><span><br></span></code><code><span><span># 检查两种方法的结果是否一致</span></span></code><code><span><span>results_consistent</span> = <span>np.allclose(norm1, norm2)</span></span></code><code><span><br></span></code><code><span><span>results_consistent,</span> <span>norm1, norm2</span></span></code><code><span><br></span></code></pre></section><section><section powered-by="xiumi.us"><section><section><p><span>03</span></p><p><span>—</span></p></section></section></section></section><section><span><span>python中的结果</span></span></section><section><span><span><br></span></span></section><p><img data-galleryid="" data-imgfileid="100002435" data-ratio="0.2866043613707165" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345Sks9naZQjI9cias6nicOxhPoZuuODUUAGhDpCqy6jU3XHbZaYYH1KkI0esiaDhcnslZbg0X7Ykdt5UQ3g/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="321" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345Sks9naZQjI9cias6nicOxhPoZuuODUUAGhDpCqy6jU3XHbZaYYH1KkI0esiaDhcnslZbg0X7Ykdt5UQ3g/640?wx_fmt=png&amp;from=appmsg"></p><p><img data-galleryid="" data-imgfileid="100002434" data-ratio="0.3240371845949535" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345Sks9naZQjI9cias6nicOxhPoZu8H12c25JFnaemMrmnkiav7fjy55APUROUMia2SXJpH8cxwnbHCH0KpWQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="753" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345Sks9naZQjI9cias6nicOxhPoZu8H12c25JFnaemMrmnkiav7fjy55APUROUMia2SXJpH8cxwnbHCH0KpWQ/640?wx_fmt=png&amp;from=appmsg"></p><section><section powered-by="xiumi.us"><section><section><p><br></p><section><section powered-by="xiumi.us"><section><section><p><strong><span>norm1和norm2结果一样</span></strong></p><p><span><br></span></p><p><span>03</span></p><p><span>—</span></p></section></section></section></section><section><span>矩阵除以一个与矩阵列数相同长度的向量到底是怎么运算的？</span></section><p><strong><br></strong></p><p><br></p><p><strong>然后我问了一下gpt，但是</strong><span><strong>我感觉他说的不对：</strong></span></p><p><strong><br></strong></p><section>在R中，当你有<strong>一个矩阵除以一个与矩阵列数相同长度的向量时，这个操作是逐列进行的（对吗？）</strong>。也就是说，矩阵的每一列都会分别除以向量中相应位置的元素。这种操作反映了R的广播机制，允许你对矩阵的每一列应用不同的运算，而不需要编写显式的循环。</section><p><br></p><section><p>给定一个矩阵M和一个长度等于M的列数的向量v，表达式M / v将会产生一个新矩阵，其中的每一列i都是原矩阵的列i除以向量v中的第i个元素。<br></p><p>例如，如果矩阵M有3列，向量v也有3个元素，那么M / v的结果是一个新矩阵，其中：</p><ul><li><p>结果矩阵的第1列是M的第1列的所有元素分别除以v[1]。</p></li><li><p>结果矩阵的第2列是M的第2列的所有元素分别除以v[2]。</p></li><li><p>结果矩阵的第3列是M的第3列的所有元素分别除以v[3]。</p></li></ul><p>这种操作非常适合于需要对矩阵的每列进行缩放或归一化的情况。</p><p><strong><br></strong></p><p><strong><br></strong></p><p><strong>这个问题主要是我做单细胞时，无意间发现的问题</strong><br></p></section></section><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="makefile"><code><span><br></span></code><code><span><span>#2在seurat_v5文件夹下安装v5---</span></span></code><code><span>.libPaths(</span></code><code><span>  c(</span></code><code><span>    '/home/rootyll/seurat_v5/',</span></code><code><span>    <span>"/usr/local/lib/R/site-library"</span>,</span></code><code><span>    <span>"/usr/lib/R/site-library"</span>,</span></code><code><span>    <span>"/usr/lib/R/library"</span></span></code><code><span>  )</span></code><code><span>)</span></code><code><span>library(Seurat)</span></code><code><span>library(dplyr)</span></code><code><span>dir.create(<span>"~/gzh/20240220_seurat_python对比学习"</span>)</span></code><code><span>setwd('~/gzh/20240220_seurat_python对比学习')</span></code><code><span><br></span></code><code><span>pbmc = readRDS('~/gzh/pbmc3k_final.rds')</span></code><code><span>DimPlot(pbmc,label = TRUE)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>pbmc=CreateSeuratObject(counts = pbmc@assays$RNA@counts)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>#counts slot------</span></span></code><code><span>counts=GetAssayData(pbmc,slot = <span>"counts"</span>) ;tail(counts)[,1:9]</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>#1数据预处理-----</span></span></code><code><span><span># pbmc  =pbmc %&gt;% </span></span></code><code><span><span>#   NormalizeData()  %&gt;% #: 数据标准化。</span></span></code><code><span><span>#   FindVariableFeatures()   %&gt;%#: 识别高变异基因。</span></span></code><code><span><span>#   ScaleData( ) #: 数据缩放和中心化</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>#normalizedata--------</span></span></code><code><span>pbmc=NormalizeData(pbmc, normalization.method = <span>"LogNormalize"</span>,</span></code><code><span>                   scale.factor = 10000,</span></code><code><span>                   margin = 1  <span>#If performing CLR normalization, normalize across features (1) or cells (2)</span></span></code><code><span>                   )</span></code><code><span><br></span></code><code><span>ncol(pbmc);nrow(pbmc)</span></code><code><span>ncol(pbmc) * nrow(pbmc)</span></code><code><span><br></span></code><code><span><br></span></code><code><span>ncol(pbmc) * nrow(pbmc)- sum(pbmc@assays$RNA@layers$counts == 0) <span>#非0数值的个数</span></span></code><code><span>pbmc@assays$RNA@layers$counts@x <span>#长度表示counts矩阵中非0的个数</span></span></code><code><span>str(pbmc) </span></code><code><span><span>pbmc@assays$RNA@layers$data[1,28:30]</span></span></code><code><span><span>pbmc@assays$RNA@layers$data[28:30,1]</span></span></code><code><span><br></span></code><code><span>log1p(0)<span>#This is then natural-log transformed</span></span></code><code><span>2/1</span></code><code><span><span>#data slot-----</span></span></code><code><span>data=GetAssayData(pbmc,slot = <span>"data"</span>) ;tail(data)[,1:9] </span></code><code><span>data_lognorm=LogNormalize(counts);tail(data_lognorm)[,1:9]</span></code><code><span><br></span></code><code><span><span>View(Seurat:::LogNorm) </span></span></code><code><span><br></span></code><code><span>mydata= log( counts/colSums(counts) *10000 +1) ;tail(mydata)[,1:9] </span></code><code><span>mydata2=log1p(  counts/colSums(counts) *10000 ) ;tail(mydata2)[,1:9] </span></code><code><span><br></span></code><code><span>mydata1=log1p(  counts/colSums(counts) *10000 ) ;tail(mydata1)[,1:9] </span></code><code><span><br></span></code><code><span><br></span></code><code><span>mydata =apply(counts, 2, function(x){ log( x/sum(x)*1e4 +1) }) ;tail(mydata )[,1:9]   <span>#R语言实现该过程</span></span></code><code><span>mydata =apply(counts, 2, function(x){ log1p( x/sum(x) *10000) }) ;tail(mydata )[,1:9]   <span>#R语言实现该过程</span></span></code><code><span><br></span></code><code><span><span>tail(data)[,1:9]</span></span></code><code><span>如果正常运行下来，就会发现mydata和data不一样</span></code></pre></section><section><p><br></p><p><br></p><p><span>04</span></p><p><span>—</span></p></section></section></section></section><section><span><span>结论</span></span></section><h3 data-tool="mdnice编辑器"><strong><span><span></span></span></strong></h3><p><span><span><strong>今天的文章并未得出结论。有两个问题需要进一步探究：</strong></span></span></p><p><span><span><strong><br></strong></span></span></p><ol><li><p><span><span>如果将一个表达矩阵除以等列长的向量，结果是什么？这种情况在数学上该如何计算？</span></span></p></li><li><p><span><span>了解一下R和Python中的数据精度问题，因为在处理大量数据时，精度可能会受到影响。</span></span></p><p><span><span></span></span></p></li></ol><p><span><span>对于第一个问题，我们需要查看公式并了解其含义。在数学上，当一个矩阵除以一个等列长的向量时，到底是如何运算的，在R语言里应该如何表示。</span></span></p><p><br></p><p><span><span>对于第二个问题，我们需要了解R和Python中的数据类型和精度限制。在R中，一个数字可以使用double或integer类型表示，double类型有更高的精度，但在内存方面会更消耗。在Python中，浮点数默认使用float类型，但是可以使用numpy库中的float64类型来获得更高的精度。当处理大量数据时，可能需要考虑使用更高精度的数据类型来避免数据误差。</span></span></p><p><span><span><br></span></span></p><p><span><strong><span>如果你知道答案，欢迎留言！</span></strong></span></p><h3 data-tool="mdnice编辑器"><strong><span></span></strong></h3><p><img data-imgfileid="100002428" data-ratio="1" data-src="https://mmbiz.qpic.cn/mmbiz_gif/4TKeL1ZejtlKxOib5kmKX6ic6eX0w0WK5jvhtz9yBRsO3OI4yr6S5iaLNM7AbAeuPDHXMvDdur2DRz9wyiax4lEviag/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" data-type="gif" data-w="240" src="https://mmbiz.qpic.cn/mmbiz_gif/4TKeL1ZejtlKxOib5kmKX6ic6eX0w0WK5jvhtz9yBRsO3OI4yr6S5iaLNM7AbAeuPDHXMvDdur2DRz9wyiax4lEviag/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1"><br></p><p><img data-imgfileid="100002427" data-ratio="0.05278592375366569" data-src="https://mmbiz.qpic.cn/mmbiz/4TKeL1Zejtlq03ZOSZiaTlic1MxgdKiaxTbOZ7ZSe0Xx1Ca8xF3L6Nyj1FYUajtYrSmRIHyZVSsAve0EAvEicZONpg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="other" data-w="341" src="https://mmbiz.qpic.cn/mmbiz/4TKeL1Zejtlq03ZOSZiaTlic1MxgdKiaxTbOZ7ZSe0Xx1Ca8xF3L6Nyj1FYUajtYrSmRIHyZVSsAve0EAvEicZONpg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p><strong><span>看完记得顺手点个</span></strong><span><strong><span>“在看”</span></strong></span><strong><span>哦！</span></strong><strong><span></span></strong></p><p><br></p><p><br></p><p><br></p><p><span></span></p></section></section></section></section><p><br></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/SQwz1hzQg-6anBxVDEN2UA",target="_blank" rel="noopener noreferrer">原文链接</a>
