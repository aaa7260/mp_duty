---
title: "推荐4个Python时间序列分析库"
date: 2023-11-02T15:13:31Z
draft: ["false"]
tags: [
  "fetched",
  "Python大数据分析"
]
categories: ["Acdemic"]
---
推荐4个Python时间序列分析库 by Python大数据分析
------
<div><section data-mpa-powered-by="yiban.io"><mp-common-profile data-pluginname="mpprofile" data-id="MzA3ODYwNDkzOQ==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/g64sbb6Ffmdy60qjichn8Ge1FjIXGcVrluK19TtxE07UIn11WvicojXg1wsGBJWK7FjN0ABmXJSs3YteQOWy5iahw/0?wx_fmt=png" data-nickname="Python大数据分析" data-alias="pydatas" data-signature="分享python编程、Chatgpt 、文心一言、可视化设计、大数据分析、机器学习等技术，包括但不限于pandas、numpy、spark、matplotlib、sklearn、tensorflow、keras、tableau等" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p><span>来源：Deephub Imba</span></p><p cid="n2" mdtype="paragraph"><span md-inline="plain">时间序列分析在金融和医疗保健等领域至关重要，在这些领域，理解随时间变化的数据模式至关重要。在本文中，我们将介绍四个主要的Python库——statmodels、tslearn、tssearch和tsfresh——每个库都针对时间序列分析的不同方面进行了定制。这些库为从预测到模式识别的任务提供了强大的工具，使它们成为各种应用程序的宝贵资源。</span></p><p cid="n5" mdtype="paragraph"><span md-inline="plain">我们使用来自Kaggle的数据集，通过加速度计数为各种身体活动进行分析。这些活动被分为12个不同的类别，每个类别对应一个特定的身体动作，如站立、坐着、行走，或从事更有活力的活动，如慢跑和骑自行车。每个活动都记录了一分钟的持续时间，提供了丰富的时间序列数据源。</span></p><p cid="n6" mdtype="paragraph"><span md-inline="plain">用于此分析的库有:</span></p><pre spellcheck="false" lang="" cid="n8" mdtype="fences"> <span role="presentation"># statsmodels</span><br> <span role="presentation">from statsmodels.tsa.seasonal import seasonal_decompose</span><br> <span role="presentation">from statsmodels.tsa.stattools import adfuller</span><br> <span role="presentation">from statsmodels.graphics.tsaplots import plot_acf</span><br> <span role="presentation"><span cm-text="" cm-zwsp=""></span></span><br> <span role="presentation">#tslearn</span><br> <span role="presentation">from tslearn.barycenters import dtw_barycenter_averaging</span><br> <span role="presentation"><span cm-text="" cm-zwsp=""></span></span><br> <span role="presentation"># tssearch</span><br> <span role="presentation">from tssearch import get_distance_dict, time_series_segmentation, time_series_search, plot_search_distance_result</span><br> <span role="presentation"><span cm-text="" cm-zwsp=""></span></span><br> <span role="presentation"># tsfresh</span><br> <span role="presentation">from tsfresh import extract_features</span><br> <span role="presentation">from tsfresh.feature_selection.relevance import calculate_relevance_table</span><br> <span role="presentation">from tsfresh.feature_extraction import EfficientFCParameters</span><br> <span role="presentation">from tsfresh.utilities.dataframe_functions import impute</span></pre><h2 cid="n10" mdtype="heading"><span>Statsmodels</span></h2><p cid="n12" mdtype="paragraph"><span md-inline="plain">从statmodels库中，两个基本函数在理解从x, y和z方向收集的加速度数据的特征方面起着关键作用。</span></p><p cid="n13" mdtype="paragraph"><span md-inline="plain">adfuller函数是确定时间序列信号平稳性的有力工具。通过对我们的数据进行Augmented Dickey-Fuller检验，可以确定加速度信号是否表现出平稳的行为，这是许多时间序列分析技术的基本要求。这个测试帮助我们评估数据是否随时间而变化。</span></p><pre spellcheck="false" lang="" cid="n19" mdtype="fences"> <span role="presentation">def activity_stationary_test(dataframe, sensor, activity):</span><br> <span role="presentation">  dataframe.reset_index(drop=True)</span><br> <span role="presentation">  adft = adfuller(dataframe[(dataframe['Activity'] == activity)][sensor], autolag='AIC')</span><br> <span role="presentation">  output_df = pd.DataFrame({'Values':[adft[0], adft[1], adft[4]['1%']], 'Metric':['Test Statistics', 'p-value', 'critical value (1%)']})</span><br> <span role="presentation">  print('Statistics of {} sensor:\n'.format(sensor), output_df)</span><br> <span role="presentation">  print()</span><br> <span role="presentation">  if (adft[1] &lt; 0.05) &amp; (adft[0] &lt; adft[4]['1%']):</span><br> <span role="presentation">    print('The signal is stationary')</span><br> <span role="presentation">  else:</span><br> <span role="presentation">    print('The signal is non-stationary')</span></pre><p cid="n21" mdtype="paragraph"><span md-inline="plain">seasonal_decomposition函数提供了对时间序列数据结构的宝贵见解。它将时间序列分解为三个不同的组成部分:趋势、季节性和残差。这种分解使我们能够可视化和理解加速度数据中的潜在模式和异常。</span></p><pre spellcheck="false" lang="" cid="n23" mdtype="fences"> <span role="presentation">def activity_decomposition(dataframe, sensor, activity):</span><br> <span role="presentation">  </span><br> <span role="presentation">  dataframe.reset_index(drop=True)</span><br> <span role="presentation">  data = dataframe[(dataframe['Activity'] == activity)][sensor]</span><br> <span role="presentation">  decompose = seasonal_decompose(data, model='additive', extrapolate_trend='freq', period=50)</span><br> <span role="presentation">  fig = decompose.plot()</span><br> <span role="presentation">  fig.set_size_inches((12, 7))</span><br> <span role="presentation">  fig.axes[0].set_title('Seasonal Decomposition Plot')</span><br> <span role="presentation">  fig.axes[3].set_xlabel('Indices')</span><br> <span role="presentation">  plt.show()</span></pre><p><img data-ratio="0.6316287878787878" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepTdV718Le5toYrpf2IO873mmog95ictbbSqwxqrVcK8AVrjJibEScAXlQ/640?wx_fmt=png" data-type="png" data-w="1056" src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepTdV718Le5toYrpf2IO873mmog95ictbbSqwxqrVcK8AVrjJibEScAXlQ/640?wx_fmt=png"></p><h2 cid="n26" mdtype="heading"><span>Tslearn</span></h2><p cid="n28" mdtype="paragraph"><span md-inline="plain">如果使用tslearn库进行时间序列分析。可以采用分割方法，将连续的加速信号分解成特定长度的离散段或窗口(例如，150个数据点)。这些片段提供了行走过程中运动的颗粒视图，并成为进一步分析的基础。重要的是，我们在相邻部分之间使用了50个数据点的重叠，从而可以更全面地覆盖潜在的动态。</span></p><pre spellcheck="false" lang="" cid="n30" mdtype="fences"> <span role="presentation">template_length = 150</span><br> <span role="presentation">overlap = 50  # Adjust the overlap value as needed</span><br> <span role="presentation">segments = [signal[i:i + template_length] for i in range(0, len(signal) - template_length + 1, overlap)]</span></pre><p><img data-ratio="0.8052173913043478" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepgFQ2ZphseBW0VJPa3Z9fXeJDXchsaPeKTy4RQswDNDzjBXxfpcsYtQ/640?wx_fmt=png" data-type="png" data-w="575" src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepgFQ2ZphseBW0VJPa3Z9fXeJDXchsaPeKTy4RQswDNDzjBXxfpcsYtQ/640?wx_fmt=png"></p><p cid="n33" mdtype="paragraph"><span md-inline="plain">为了从这些片段中获得一个封装行走典型特征的代表性模板，我们使用了dtw_barycenter_averaging函数。该方法采用动态时间规整(Dynamic Time Warping, DTW)对分割的时间序列进行对齐和平均，有效地创建了一个捕捉步行运动中心趋势的模板。</span></p><pre spellcheck="false" lang="" cid="n35" mdtype="fences"> <span role="presentation">template_signal = dtw_barycenter_averaging(segments)</span><br> <span role="presentation">template_signal = template_signal.flatten()</span></pre><p cid="n37" mdtype="paragraph"><span md-inline="plain">生成的模板为后续的分类和比较任务提供了有价值的参考，有助于基于x轴加速度的步行活动识别和分析。</span></p><p><img data-ratio="0.8052173913043478" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepjhdKicYSVDnjsulB5X0hlhaCry8gdQJico9ia2aUofu2J4xcnfdhSbsYw/640?wx_fmt=png" data-type="png" data-w="575" src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepjhdKicYSVDnjsulB5X0hlhaCry8gdQJico9ia2aUofu2J4xcnfdhSbsYw/640?wx_fmt=png"></p><h2 cid="n39" mdtype="heading"><span>Tssearch</span></h2><p cid="n41" mdtype="paragraph"><span md-inline="plain">对于tssearch库使用time_series_segmentation函数，通过动态时间规整(DTW)或其他相似性度量来识别输入时间序列中与所提供的模板信号最相似的片段。</span></p><p cid="n42" mdtype="paragraph"><span md-inline="plain">该函数的主要目标是定位和提取与模板信号密切匹配的输入时间序列片段。通过将模板信号与输入时间序列进行比较，可以找到这些片段，该函数返回输入时间序列中这些片段开始的位置或索引。</span></p><pre spellcheck="false" lang="" cid="n44" mdtype="fences"> <span role="presentation">segment_distance = get_distance_dict(["Dynamic Time Warping"])</span><br> <span role="presentation"><span cm-text="" cm-zwsp=""></span></span><br> <span role="presentation">segment_results = time_series_segmentation(segment_distance, template_signal, signal_np)</span><br> <span role="presentation"><span cm-text="" cm-zwsp=""></span></span><br> <span role="presentation">for k in segment_results:</span><br> <span role="presentation">  plt.figure(figsize=(15, 3))</span><br> <span role="presentation">  plt.plot(signal_np, color='gray')</span><br> <span role="presentation">  plt.vlines(segment_results[k], np.min(signal_np)-1, np.max(signal_np) + 1, 'C1')</span><br> <span role="presentation">  plt.xlabel('Indices')</span><br> <span role="presentation">  plt.ylabel('Amplitude')</span><br> <span role="presentation">  plt.title(k)</span></pre><p><img data-galleryid="" data-ratio="0.262037037037037" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepxkUBLRJNz8JiaBzkj2IicNp6tIXLptQTXaUjBuiamWKs7O1J3zRErgnxA/640?wx_fmt=png" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepxkUBLRJNz8JiaBzkj2IicNp6tIXLptQTXaUjBuiamWKs7O1J3zRErgnxA/640?wx_fmt=png"></p><p cid="n47" mdtype="paragraph"><span md-inline="plain">tssearch库中还有另一个用于发现时间序列数据中的相似性和差异性的方法。首先，我们配置了一个字典dict_distances来指定搜索的距离度量。定义了两种不同的方法。第一个，标记为“elastic”，采用动态时间规整(DTW)作为相似性度量。使用特定的参数定制DTW，例如dtw_type设置为“sub-dtw”，alpha设置为0.5，允许灵活的时间序列对齐和比较。然后是“lockstep”，它利用欧几里得距离以一种更严格的方式来衡量相似性。有了这些距离配置，就可以使用time_series_search函数执行时间序列搜索，将模板信号与目标信号(signal_np)进行比较，并指定前30个匹配项的输出。</span></p><pre spellcheck="false" lang="" cid="n50" mdtype="fences"> <span role="presentation">dict_distances = {</span><br> <span role="presentation">    "elastic": {</span><br> <span role="presentation">        "Dynamic Time Warping": {</span><br> <span role="presentation">            "function": "dtw",</span><br> <span role="presentation">            "parameters": {"dtw_type": "sub-dtw", "alpha": 0.5},</span><br> <span role="presentation">        }</span><br> <span role="presentation">    },</span><br> <span role="presentation">    "lockstep": {</span><br> <span role="presentation">        "Euclidean Distance": {</span><br> <span role="presentation">            "function": "euclidean_distance",</span><br> <span role="presentation">            "parameters": "",</span><br> <span role="presentation">      }</span><br> <span role="presentation">    }</span><br> <span role="presentation">}</span><br> <span role="presentation"><span cm-text="" cm-zwsp=""></span></span><br> <span role="presentation">result = time_series_search(dict_distances, template_signal, signal_np, output=("number", 30))</span><br> <span role="presentation">plot_search_distance_result(result, signal_np)</span></pre><p><img data-ratio="0.33055555555555555" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepQHPUvhAGpEfLictyKhiacuNib44t4CWxQe669QBo2w7Tib0rdsIV0a0BFQ/640?wx_fmt=png" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNepQHPUvhAGpEfLictyKhiacuNib44t4CWxQe669QBo2w7Tib0rdsIV0a0BFQ/640?wx_fmt=png"></p><p><img data-ratio="0.33055555555555555" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNephcWZ2eS6peb0iaKA70icHkHrlqKoXicW2Y6CccO9KbgSLjOvhxy58Rvtg/640?wx_fmt=png" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNephcWZ2eS6peb0iaKA70icHkHrlqKoXicW2Y6CccO9KbgSLjOvhxy58Rvtg/640?wx_fmt=png"></p><p cid="n54" mdtype="paragraph"><span md-inline="plain">这是一种时间序列聚类的简单的方法，并且可解释性很强。</span></p><h2 cid="n55" mdtype="heading"><span>Tsfresh</span></h2><p cid="n57" mdtype="paragraph"><span md-inline="plain">tsfresh库则是一个很好的自动化特征提取过程的工具。effentfcparameters()定义了一组提取设置，它指定了特征提取参数和配置。这些设置可以控制在提取过程中计算哪些特征。然后就可以使用extract_features函数应用进行特征的提取。这里应该将“Activity”列作为标识符列，并提供了特征提取参数。重要的是，该库可以对缺失值(NaN)的特征进行自动删除，结果保存在x_extract中，是从时间序列数据中提取的大量特征集合。Tsfresh简化了通常复杂且耗时的特征工程过程，为时间序列分析提供了宝贵的资源。</span></p><pre spellcheck="false" lang="" cid="n59" mdtype="fences"> <span role="presentation">extraction_settings = EfficientFCParameters()</span><br> <span role="presentation">X_extracted = extract_features(final_df, column_id='Activity',</span><br> <span role="presentation">                      default_fc_parameters=extraction_settings,</span><br> <span role="presentation">                      # we impute = remove all NaN features automatically</span><br> <span role="presentation">                      impute_function=impute, show_warnings=False)</span><br> <span role="presentation"><span cm-text="" cm-zwsp=""></span></span><br> <span role="presentation">X_extracted= pd.DataFrame(X_extracted, index=X_extracted.index, columns=X_extracted.columns)</span><br> <span role="presentation"><span cm-text="" cm-zwsp=""></span></span><br> <span role="presentation">values = list(range(1, 13))</span><br> <span role="presentation">y = pd.Series(values, index=range(1, 13))</span><br> <span role="presentation"><span cm-text="" cm-zwsp=""></span></span><br> <span role="presentation">relevance_table_clf = calculate_relevance_table(X_extracted, y)</span><br> <span role="presentation">relevance_table_clf.sort_values("p_value", inplace=True)</span><br> <span role="presentation">relevance_table_clf.head(10)</span></pre><p><img data-ratio="0.6361111111111111" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNep4BBucibqrOiaXOjWvQa6Q8dia1uuSwbNhYXRyEjlceSTRhMcqJyiaZafpQ/640?wx_fmt=png" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNep4BBucibqrOiaXOjWvQa6Q8dia1uuSwbNhYXRyEjlceSTRhMcqJyiaZafpQ/640?wx_fmt=png"></p><pre spellcheck="false" lang="" cid="n63" mdtype="fences"> <span role="presentation">top_features = relevance_table_clf["feature"].head(10)</span><br> <span role="presentation">x_features = X_extracted[top_features]</span></pre><p><img data-ratio="0.3574074074074074" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNep0ibicMlavwuQmzWg6ic2OQHnibl6k3a1fLyzoHuwrSMbohoO4DZFLMvNgA/640?wx_fmt=webp" data-type="webp" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_jpg/6wQyVOrkRNKRzXuTLKvhjW9XZ4ENGNep0ibicMlavwuQmzWg6ic2OQHnibl6k3a1fLyzoHuwrSMbohoO4DZFLMvNgA/640?wx_fmt=webp"></p><h2 cid="n66" mdtype="heading"><span>总结</span></h2><p cid="n68" mdtype="paragraph"><span md-inline="plain">本文向您介绍了时间序列分析的四个基本Python库:statmodels、tslearn、tssearch和tsfresh。时间序列分析是金融和医疗保健等各个领域的重要工具，在这些领域，我们需要了解数据随时间的变化趋势，以便做出明智的决策和预测。</span></p><p cid="n69" mdtype="paragraph"><span md-inline="plain">每个库都专注于时间序列分析的不同方面，选择哪个库取决于具体问题。通过结合使用这些库，可以处理各种与时间相关的挑战，从预测财务趋势到对医疗保健中的活动进行分类。当要开始自己的时间序列分析项目时，请记住这些库，结合着使用它们可以帮助你解决很多的实际问题。</span></p><p cid="n69" mdtype="paragraph"><span md-inline="plain"><span md-inline="plain">kaggle数据集：</span><span md-inline="url" spellcheck="false">https://www.kaggle.com/datasets/gaurav2022/mobile-health/discussion/375938</span></span></p><p cid="n69" mdtype="paragraph"><span md-inline="plain"><span md-inline="url" spellcheck="false"><br></span></span></p><section><section data-tools="135编辑器" data-id="93761"><section><section><section><img data-ratio="1.5689655172413792" data-src="https://mmbiz.qpic.cn/mmbiz_gif/g64sbb6FfmeTia7KYOK2H3XYVtvxgzuuIurf4DfSrPHgzjGn6hA24I3pdHdSeZV1QsbrEPQic8icrjaxZoqpy8KxA/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" data-type="gif" data-w="116" data-width="100%" src="https://mmbiz.qpic.cn/mmbiz_gif/g64sbb6FfmeTia7KYOK2H3XYVtvxgzuuIurf4DfSrPHgzjGn6hA24I3pdHdSeZV1QsbrEPQic8icrjaxZoqpy8KxA/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1"><span></span></section></section></section></section></section><p><span>加入知识星球</span><span><strong>【我们谈论数据科学】</strong></span></p><p><strong><span>600+</span></strong><span>小伙伴一起学习！</span></p><hr><p><span></span><br></p><hr><p><a data-miniprogram-appid="wx4f706964b979122a" data-miniprogram-path="pages/topics/topics?group_id=554445522424&amp;appid=wx50f8fac4e717b640" data-miniprogram-nickname="知识星球" data-miniprogram-type="image" data-miniprogram-servicetype="" wah-hotarea="click" href=""><img data-ratio="0.44254835039817975" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/g64sbb6FfmcTFoXJyw5r6CSribEBGb6tBBDxMcYW0hQJ1CbJCIEKjoDqnOmEO8jqhMMQupTHPGjUiciana9LF3lVg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="png" data-w="879" src="https://mmbiz.qpic.cn/mmbiz_png/g64sbb6FfmcTFoXJyw5r6CSribEBGb6tBBDxMcYW0hQJ1CbJCIEKjoDqnOmEO8jqhMMQupTHPGjUiciana9LF3lVg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></a></p><p><br></p><p><img data-ratio="0.7366548042704626" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/g64sbb6Ffmd04K7DNTzhoD8icSkkQUbXzByBXicMCibDSEbbja8ueRoh63YbbcJQSsE2tibyPgMg4KuQNkibfLKV9NA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-type="png" data-w="562" src="https://mmbiz.qpic.cn/mmbiz_png/g64sbb6Ffmd04K7DNTzhoD8icSkkQUbXzByBXicMCibDSEbbja8ueRoh63YbbcJQSsE2tibyPgMg4KuQNkibfLKV9NA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/uHO2K6oMAfeiVjy3ZAo4DA",target="_blank" rel="noopener noreferrer">原文链接</a>
