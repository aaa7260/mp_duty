---
title: "单细胞测序 空间转录组联合分析 -整合多个slide获取ps_integrated_slides"
date: 2023-11-24T07:27:20Z
draft: ["false"]
tags: [
  "fetched",
  "生信小博士"
]
categories: ["Acdemic"]
---
单细胞测序 空间转录组联合分析 -整合多个slide获取ps_integrated_slides by 生信小博士
------
<div><p><span>大家好，欢迎来的</span><span>单细胞空间转录组联合分析.续上期：</span><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=Mzg2NDcxMzYwNg==&amp;mid=2247484289&amp;idx=1&amp;sn=4a31cb4472cbbeebc2802f0ba8c7f568&amp;chksm=ce646d68f913e47ec80139ad1f10867059e21691cf1f5c8fc32bb25a6de91d154e0b90ea1073&amp;scene=21#wechat_redirect" textvalue="Spatial multi-omic map of human myocardial infarction" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2"><span>Spatial multi-omic map of human </span><span>myocardial infarction</span></a><span>.</span></p><p><span>本文代码：作者整合了空转的多个数据最终形成ps_integrated_slides,（<span>使用最终获取的</span><span>ps_integrated_slides文件，再结合细胞丰度文件，可以做  ILR transformation、findniches</span>），那么这个文件</span><span>是啥意思呢</span></p><p><span>作者在<strong>General differences in tissue organization部分</strong>，提到了pseudo-bulk profiles， <span>ps_integrated_slides中的ps就是<span>pseudo-bulk简写</span></span></span></p><p><span><span>Hierarchical clustering, with euclidean distances and Ward’s algorithm,</span><span>was used to cluster the <strong>pseudo-bulk profiles </strong>of the spatial transcriptomics datasets (replicates where merged, n = 27). Genes with less than 100 counts in 85% of the sample size were excluded for this analysis. Log normalization (scale factor = 10,000) was performed.</span></span></p><p><span><span>To visualize the general molecular differences between our samples,</span><span>log-normalized pseudo-bulk profiles of the spatial transcriptomics datasets were projected in an UMAP embedding.</span></span></p><p><br></p><p><span>这次整合的结果：1.所有空转的表达数据整合在一起，同时使用silhouette方法获取最优的聚类个数。2. 通过sumCountsAcrossCells函数获取各个细胞类型的pseudo-bulk counts。    （使用最终获取的<span>ps_integrated_slides文件，再结合细胞丰度文件，可以做  ILR transformation、find cell-type niches）</span></span></p><p><strong>整合的过程也是分为两步</strong></p><p><strong>第一步，获取i<span>ntegrated_slides rds文件 。方法：整合多个cellranger处理好的空转数据，即整合多个slides；使用harmony来去除批次效应；使用silhouette获得最优聚类</span></strong></p><p><strong><span><strong><span>文件部分截图如下：</span></strong></span></strong></p><p><img data-galleryid="" data-imgfileid="100000740" data-ratio="0.6558375634517767" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkvOupXjG7z1un2DkRoSaQttTV8sKCvmDsqGpkWibcQjWaktrBZ1TrFHIZO2O2c8IazicibSMucISxWEg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="985" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkvOupXjG7z1un2DkRoSaQttTV8sKCvmDsqGpkWibcQjWaktrBZ1TrFHIZO2O2c8IazicibSMucISxWEg/640?wx_fmt=png&amp;from=appmsg"></p><p><strong><span>详细代码：附在本文最后</span></strong></p><p><strong><span><img data-galleryid="" data-imgfileid="100000743" data-ratio="0.4361111111111111" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkvOupXjG7z1un2DkRoSaQttrL7Hh8ccLHHia8DtcoLia6oZ7iaPZ9a7BVHzoFBFp5wmJZhJCtTGDmPibQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkvOupXjG7z1un2DkRoSaQttrL7Hh8ccLHHia8DtcoLia6oZ7iaPZ9a7BVHzoFBFp5wmJZhJCtTGDmPibQ/640?wx_fmt=png&amp;from=appmsg"></span></strong></p><p><strong><span>这一步中作者的整合思路代码如下：</span></strong><br></p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="properties"><code><span><span>1 FindVariableFeatures     </span> <span>找到每个slide的高变基因</span></span></code><code><span><span>2 gene_selection_plt       把所有的高变基因整合在一个list内</span></span></code><code><span><span>3.使用merge函数，merge所有的slide</span> <span></span></span></code><code><span><span>4.harmony</span></span></code><code><span><span>slide_files</span> <span>&lt;- list.files("~/silicosis/spatial/prcessed_visum_for_progeny/data/",recursive = TRUE,</span></span></code><code><span>                                        <span>all.files</span> = <span>TRUE,full.names = TRUE,pattern = "_")</span></span></code><code><span><span> def_assay</span>=<span>"Spatial"</span></span></code><code><span><span>hvg_list &lt;- map(integrated_data, function(x) { </span></span></code><code><span><span>  DefaultAssay(x) &lt;- def_assay</span></span></code><code><span>  <span>x</span> <span>&lt;- FindVariableFeatures(x, selection.method = "vst", </span></span></code><code><span><span>                            nfeatures </span>=<span> 3000)</span></span></code><code><span><span>  x@assays[[def_assay]]@var.features</span></span></code><code><span><span>})</span> <span>%&gt;% unlist()</span></span></code><code><span><br></span></code><code><span><span>hvg_list</span> <span>&lt;- table(hvg_list) %&gt;%</span></span></code><code><span><span>  sort(decreasing </span>=<span> TRUE)</span></span></code><code><span><span>gene_selection_plt</span> <span>&lt;- hvg_list %&gt;% enframe() %&gt;% </span></span></code><code><span>  <span>group_by(value)</span> <span>%&gt;% </span></span></code><code><span>  <span>mutate(value</span> = <span>as.numeric(value)) %&gt;%</span></span></code><code><span>  <span>summarize(ngenes</span> = <span>length(name)) %&gt;% </span></span></code><code><span>  <span>ggplot(aes(x</span> = <span>value, y = ngenes)) + </span></span></code><code><span><span>  geom_bar(stat </span>=<span> "identity")</span></span></code><code><span><span>gene_selection</span> <span>&lt;- hvg_list[1:3000] %&gt;% names()                                       </span></span></code><code><span><span>integrated_data</span> <span>&lt;- purrr::reduce(integrated_data,</span></span></code><code><span>                          <span>merge,</span></span></code><code><span>                          <span>merge.data</span> = <span>TRUE)                                        </span></span></code><code><span><span>integrated_data</span> <span>&lt;- integrated_data %&gt;%</span></span></code><code><span>  <span>ScaleData(verbose</span> = <span>FALSE) %&gt;% </span></span></code><code><span>  <span>RunPCA(features</span> = <span>gene_selection, </span></span></code><code><span>         <span>npcs</span> = <span>30, </span></span></code><code><span>         <span>verbose</span> = <span>FALSE)                                       </span></span></code><code><span><span>integrated_data</span> <span>&lt;- RunHarmony(integrated_data, </span></span></code><code><span>                              <span>group.by.vars</span> =   <span>batch_covars, </span></span></code><code><span>                              <span>plot_convergence</span> = <span>TRUE,</span></span></code><code><span>                              <span>assay.use</span> = <span>def_assay,</span></span></code><code><span><span>                              max.iter.harmony </span>=<span> 20)</span></span></code></pre></section><p><strong><span><br></span></strong></p><p><strong><span><br></span></strong></p><p><strong><span>第二步，获取ps_integrated_slides和ps_integrated_slides_niches rds文件。这两个文件是通过第一步中的ps_integrated_slides_niches.rds最终获得的。  方法:使用sumCountsAcrossCells函数</span></strong></p><p><strong><span>文件如下：</span></strong></p><p><img data-galleryid="" data-imgfileid="100000739" data-ratio="0.6826222684703434" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkvOupXjG7z1un2DkRoSaQttG2gyXYsGzeca2StlchkXFsap7mynegPVf99QT5hrCQJJFH9aon63fQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="961" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkvOupXjG7z1un2DkRoSaQttG2gyXYsGzeca2StlchkXFsap7mynegPVf99QT5hrCQJJFH9aon63fQ/640?wx_fmt=png&amp;from=appmsg"></p><p><img data-galleryid="" data-imgfileid="100000742" data-ratio="0.2939110070257611" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkvOupXjG7z1un2DkRoSaQtticlpFDQoz1UgqgBXQcjROfpNAvgvht6JekAPdSiasWcliaicxTVmgz2V5w/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="854" src="https://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345SkvOupXjG7z1un2DkRoSaQtticlpFDQoz1UgqgBXQcjROfpNAvgvht6JekAPdSiasWcliaicxTVmgz2V5w/640?wx_fmt=png&amp;from=appmsg"></p><p><strong><span><strong><span>详细代码：附在本文最后</span></strong></span></strong></p><p><strong><span><br></span></strong></p><p>第一步代码:</p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="http"><code><span><br></span></code><code><span><br></span></code><code><span><span>#####安装archr包##别处复制</span></span></code><code><span>.libPaths(c(<span>"/home/data/t040413/R/x86_64-pc-linux-gnu-library/4.2"</span>,</span></code><code><span>            <span>"/home/data/t040413/R/yll/usr/local/lib/R/site-library"</span>, </span></code><code><span>            <span>"/usr/local/lib/R/library"</span>,</span></code><code><span>            <span>"/home/data/refdir/Rlib/"</span>))</span></code><code><span><br></span></code><code><span>.libPaths()</span></code><code><span>library(tidyverse)</span></code><code><span>library(Seurat)</span></code><code><span>library(optparse)</span></code><code><span>library(scater)</span></code><code><span>library(harmony)</span></code><code><span>library(dplyr)</span></code><code><span>library(optparse)</span></code><code><span>library(tidyverse)</span></code><code><span>library(Seurat)</span></code><code><span>library(harmony)</span></code><code><span>library(cluster)</span></code><code><span>library(clustree)</span></code><code><span><span>#https://github.com/saezlab/visium_heart/blob/5b30c7e497e06688a8448afd8d069d2fa70ebcd2/st_snRNAseq/02_snuc_integration_harmony/integrate_objects.R#L194</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>slide_files &lt;- list.files(<span>"~/silicosis/spatial/prcessed_visum_for_progeny/data/"</span>,recursive = TRUE,</span></code><code><span>                                        all.files = TRUE,full.names = TRUE,pattern = <span>"_"</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>integrated_data &lt;- <span>map</span>(slide_files, readRDS)</span></code><code><span><span>print</span>(<span>"You managed to load everything"</span>)</span></code><code><span><span>print</span>(<span>"Object size"</span>)</span></code><code><span><span>print</span>(object.size(integrated_data))</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># Calculate HVG per sample - Here we assume that batch and patient effects aren't as strong</span></span></code><code><span><span># since cell-types and niches should be greater than the number of batches</span></span></code><code><span><br></span></code><code><span>Assays(integrated_data [[<span>1</span>]])</span></code><code><span>str(integrated_data [[<span>1</span>]])</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>def_assay=<span>"Spatial"</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span>hvg_list &lt;- <span>map</span>(integrated_data, function(<span>x</span>) {</span></code><code><span>  </span></code><code><span>  DefaultAssay(<span>x</span>) &lt;- def_assay</span></code><code><span>  </span></code><code><span>  <span>x</span> &lt;- FindVariableFeatures(<span>x</span>, selection.method = <span>"vst"</span>, </span></code><code><span>                            nfeatures = <span>3000</span>)</span></code><code><span>  </span></code><code><span>  <span>x</span>@assays[[def_assay]]@var.features</span></code><code><span>  </span></code><code><span>}) %&gt;% unlist()</span></code><code><span><br></span></code><code><span>hvg_list &lt;- table(hvg_list) %&gt;%</span></code><code><span>  <span>sort</span>(decreasing = TRUE)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>gene_selection_plt &lt;- hvg_list %&gt;% enframe() %&gt;% </span></code><code><span>  group_by(value) %&gt;% </span></code><code><span>  mutate(value = as.numeric(value)) %&gt;%</span></code><code><span>  summarize(ngenes = <span>length</span>(name)) %&gt;% </span></code><code><span>  ggplot(aes(<span>x</span> = value, <span>y</span> = ngenes)) + </span></code><code><span>  geom_bar(<span>stat</span> = <span>"identity"</span>)</span></code><code><span><br></span></code><code><span>gene_selection &lt;- hvg_list[<span>1</span>:<span>3000</span>] %&gt;% names()</span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>#########</span></span></code><code><span><span># Create merged object ---------------------------------</span></span></code><code><span>integrated_data &lt;- purrr::reduce(integrated_data,</span></code><code><span>                          merge,</span></code><code><span>                          merge.data = TRUE)</span></code><code><span><br></span></code><code><span><span>print</span>(<span>"You managed to merge everything"</span>)</span></code><code><span><span>print</span>(<span>"Object size"</span>)</span></code><code><span><span>print</span>(object.size(integrated_data))</span></code><code><span><br></span></code><code><span><span># Default assay ---------------------------------------</span></span></code><code><span><span>#DefaultAssay(integrated_data) &lt;- def_assay</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># Process it before integration -----------------------</span></span></code><code><span>integrated_data &lt;- integrated_data %&gt;%</span></code><code><span>  ScaleData(verbose = FALSE) %&gt;% </span></code><code><span>  RunPCA(features = gene_selection, </span></code><code><span>         npcs = <span>30</span>, </span></code><code><span>         verbose = FALSE) </span></code><code><span><br></span></code><code><span>original_pca_plt &lt;- DimPlot(object = integrated_data, </span></code><code><span>                            reduction = <span>"pca"</span>, </span></code><code><span>                            pt.size = .<span>1</span>, </span></code><code><span>                            group.by = <span>"orig.ident"</span>)</span></code><code><span><br></span></code><code><span>head(integrated_data@meta.data)</span></code><code><span><br></span></code><code><span>batch_covars=<span>"orig.ident"</span></span></code><code><span><span># Integrate the data -----------------------</span></span></code><code><span>integrated_data &lt;- RunHarmony(integrated_data, </span></code><code><span>                              group.by.vars =   batch_covars, </span></code><code><span>                              plot_convergence = TRUE,</span></code><code><span>                              assay.use = def_assay,</span></code><code><span>                              max.iter.harmony = <span>20</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># Corrected dimensions -----------------------</span></span></code><code><span>corrected_pca_plt &lt;- DimPlot(object = integrated_data, </span></code><code><span>                             reduction = <span>"harmony"</span>, </span></code><code><span>                             pt.size = .<span>1</span>, </span></code><code><span>                             group.by = <span>"orig.ident"</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># Create the UMAP with new reduction -----------</span></span></code><code><span>integrated_data &lt;- integrated_data %&gt;% </span></code><code><span>  RunUMAP(reduction = <span>"harmony"</span>, dims = <span>1</span>:<span>30</span>,</span></code><code><span>          reduction.name = <span>"umap_harmony"</span>) %&gt;%</span></code><code><span>  RunUMAP(reduction = <span>"pca"</span>, dims = <span>1</span>:<span>30</span>,</span></code><code><span>          reduction.name = <span>"umap_original"</span>)</span></code><code><span><br></span></code><code><span>integrated_data &lt;- FindNeighbors(integrated_data, </span></code><code><span>                                 reduction = <span>"harmony"</span>, </span></code><code><span>                                 dims = <span>1</span>:<span>30</span>)</span></code><code><span><br></span></code><code><span>head(integrated_data@meta.data)</span></code><code><span><br></span></code><code><span>colnames(integrated_data@meta.data)=gsub(pattern =<span>"_snn_res."</span>,replacement = <span>"_before"</span>,<span>x</span> = colnames(integrated_data@meta.data) ) </span></code><code><span><br></span></code><code><span>DefaultAssay(integrated_data)</span></code><code><span>integrated_data@meta.data %&gt;%head()</span></code><code><span><br></span></code><code><span><br></span></code><code><span>optimize=TRUE</span></code><code><span><span>################opt cluster--------------</span></span></code><code><span><span>if</span>(optimize) { </span></code><code><span>  </span></code><code><span>  <span># Clustering and optimization -------------------------</span></span></code><code><span>  <span>print</span>(<span>"Optimizing clustering"</span>)</span></code><code><span>  </span></code><code><span>  seq_res &lt;- se<span>q(0.5, 1.5, 0.1)</span></span></code><code><span>  </span></code><code><span><span># seq_res=1</span></span></code><code><span>  integrated_data &lt;- FindClusters(integrated_data,</span></code><code><span>                                  resolution = seq_res,</span></code><code><span>                                  verbose = F)</span></code><code><span>  </span></code><code><span>  clustree_plt &lt;- clustree::clustree(integrated_data, </span></code><code><span>                           prefix = paste<span>0</span>(DefaultAssay(integrated_data), <span>"_snn_res."</span>))</span></code><code><span>  </span></code><code><span>  <span># Optimize clustering ------------------------------------------------------</span></span></code><code><span>  cell_dists &lt;- dist(integrated_data@reductions$harmony@cell.embeddings,</span></code><code><span>                     method = <span>"euclidean"</span>)</span></code><code><span>  head(cell_dists)</span></code><code><span> </span></code><code><span>  </span></code><code><span>  cluster_info &lt;- integrated_data@meta.data[,grepl(paste<span>0</span>(DefaultAssay(integrated_data),<span>"_snn_res"</span>),</span></code><code><span>                                                   colnames(integrated_data@meta.data))] %&gt;%</span></code><code><span>    dplyr::mutate_all(as.character) %&gt;%</span></code><code><span>    dplyr::mutate_all(as.numeric)</span></code><code><span>  </span></code><code><span>  head(cluster_info)[,<span>1</span>:<span>9</span>]</span></code><code><span><span>#  head(cell_dists)[,1:9]</span></span></code><code><span>  si= silhouette(cluster_info[,<span>1</span>], cell_dists) %&gt;%head()</span></code><code><span>  si</span></code><code><span>   </span></code><code><span>  silhouette_res &lt;- apply(cluster_info, <span>2</span>, function(<span>x</span>){</span></code><code><span>    si &lt;- silhouette(<span>x</span>, cell_dists)</span></code><code><span>   </span></code><code><span>     <span>if</span>(!any(is.na(si))) {</span></code><code><span>      mean(si[, <span>'sil_width'</span>])</span></code><code><span>    } <span>else</span> {</span></code><code><span>      NA</span></code><code><span>    }</span></code><code><span>  })</span></code><code><span>  head(silhouette_res)</span></code><code><span>  </span></code><code><span>  integrated_data[[<span>"opt_clust_integrated"</span>]] &lt;- integrated_data[[names(which.max(silhouette_res))]]</span></code><code><span>  </span></code><code><span>  Idents(integrated_data) = <span>"opt_clust_integrated"</span></span></code><code><span>  </span></code><code><span>  <span># Reduce meta-data -------------------------------------------------------------------------</span></span></code><code><span>  spam_cols &lt;- grepl(paste<span>0</span>(DefaultAssay(integrated_data), <span>"_snn_res"</span>),</span></code><code><span>                     colnames(integrated_data@meta.data)) |</span></code><code><span>    grepl(<span>"seurat_clusters"</span>,colnames(integrated_data@meta.data))</span></code><code><span>  </span></code><code><span>  integrated_data@meta.data &lt;- integrated_data@meta.data[,!spam_cols]</span></code><code><span>  </span></code><code><span>} <span>else</span> {</span></code><code><span>  </span></code><code><span>  <span>print</span>(<span>"Not Optimizing clustering"</span>)</span></code><code><span>  </span></code><code><span>  seq_res &lt;- se<span>q(0.2, 1.6, 0.2)</span></span></code><code><span>  </span></code><code><span>  integrated_data &lt;- FindClusters(integrated_data,</span></code><code><span>                                  resolution = seq_res,</span></code><code><span>                                  verbose = F)</span></code><code><span>  </span></code><code><span>  clustree_plt &lt;- clustree(integrated_data, </span></code><code><span>                           prefix = paste<span>0</span>(DefaultAssay(integrated_data), </span></code><code><span>                                           <span>"_snn_res."</span>))</span></code><code><span>  </span></code><code><span>  integrated_data &lt;- FindClusters(integrated_data,</span></code><code><span>                                  resolution = default_resolution,</span></code><code><span>                                  verbose = F)</span></code><code><span>  </span></code><code><span>  integrated_data[[<span>"opt_clust_integrated"</span>]] &lt;- integrated_data[[<span>"seurat_clusters"</span>]]</span></code><code><span>  </span></code><code><span>  spam_cols &lt;- grepl(paste<span>0</span>(DefaultAssay(integrated_data), <span>"_snn_res"</span>),</span></code><code><span>                     colnames(integrated_data@meta.data)) |</span></code><code><span>    grepl(<span>"seurat_clusters"</span>,colnames(integrated_data@meta.data))</span></code><code><span>  </span></code><code><span>  integrated_data@meta.data &lt;- integrated_data@meta.data[,!spam_cols]</span></code><code><span>  </span></code><code><span>}</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># Save object ------------------------------------------------------</span></span></code><code><span>saveRDS(integrated_data, file =<span>"~/silicosis/spatial/integrated_slides/integrated_slides.rds"</span> )</span></code><code><span><span># integrated_data=readRDS("~/silicosis/spatial/integrated_slides/integrated_slides.rds")</span></span></code><code><span><span># head(integrated_data@meta.data)</span></span></code><code><span><span># </span></span></code><code><span><span># ps_integrated_slides=readRDS("~/silicosis/spatial/integrated_slides/ps_integrated_slides.rds")</span></span></code><code><span><span># </span></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># Print QC file ------------------------------------------------------</span></span></code><code><span><br></span></code><code><span>umap_corrected_sample &lt;- DimPlot(object = integrated_data, </span></code><code><span>                                 reduction = <span>"umap_harmony"</span>, </span></code><code><span>                                 pt.size = .<span>1</span>, </span></code><code><span>                                 group.by = <span>"orig.ident"</span>)</span></code><code><span><br></span></code><code><span>umap_corrected_clustering &lt;- DimPlot(object = integrated_data, </span></code><code><span>                                     reduction = <span>"umap_harmony"</span>, </span></code><code><span>                                     pt.size = .<span>1</span>, </span></code><code><span>                                     group.by = <span>"opt_clust_integrated"</span>)</span></code><code><span><br></span></code><code><span>umap_sample &lt;- DimPlot(object = integrated_data, </span></code><code><span>                       reduction = <span>"umap_original"</span>, </span></code><code><span>                       pt.size = .<span>1</span>, </span></code><code><span>                       group.by = <span>"orig.ident"</span>)</span></code><code><span><br></span></code><code><span>umap_clustering &lt;- DimPlot(object = integrated_data, </span></code><code><span>                           reduction = <span>"umap_original"</span>, </span></code><code><span>                           pt.size = .<span>1</span>, </span></code><code><span>                           group.by = <span>"opt_clust_integrated"</span>)</span></code><code><span><br></span></code><code><span>getwd()</span></code><code><span><br></span></code><code><span><br></span></code><code><span>head(integrated_data@meta.data)</span></code><code><span>Reductions(integrated_data)</span></code><code><span>DimPlot(integrated_data,label = TRUE,reduction = <span>"umap_harmony"</span>  )</span></code><code><span><br></span></code><code><span>pdf(file = <span>"~/silicosis/spatial/integrated_slides/ump.pdf"</span>, height = <span>10</span>, width = <span>12</span>)</span></code><code><span><br></span></code><code><span><span>print</span>(gene_selection_plt)</span></code><code><span><span>print</span>(original_pca_plt)</span></code><code><span><span>print</span>(corrected_pca_plt)</span></code><code><span><span>print</span>(umap_sample)</span></code><code><span><span>print</span>(umap_corrected_sample)</span></code><code><span><span>print</span>(clustree_plt)</span></code><code><span><span>print</span>(umap_clustering)</span></code><code><span><span>print</span>(umap_corrected_clustering)</span></code><code><span><br></span></code><code><span>dev.off()</span></code><code><span><br></span></code></pre></section><p><br></p><p>第二步代码：</p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="php"><code><span><br></span></code><code><span><span>#####安装archr包##别处复制</span></span></code><code><span>.libPaths(c(<span>"/home/data/t040413/R/x86_64-pc-linux-gnu-library/4.2"</span>,</span></code><code><span>            <span>"/home/data/t040413/R/yll/usr/local/lib/R/site-library"</span>, </span></code><code><span>            <span>"/usr/local/lib/R/library"</span>,</span></code><code><span>            <span>"/home/data/refdir/Rlib/"</span>))</span></code><code><span><br></span></code><code><span>.libPaths()</span></code><code><span>library(optparse)</span></code><code><span>library(tidyverse)</span></code><code><span>library(Seurat)</span></code><code><span>library(harmony)</span></code><code><span>library(cluster)</span></code><code><span>library(clustree)</span></code><code><span><br></span></code><code><span><span>#https://github.com/saezlab/visium_heart/blob/5b30c7e497e06688a8448afd8d069d2fa70ebcd2/st_snRNAseq/jobs/run_spatial_pseudobulk.sh#L25</span></span></code><code><span><span>#https://github.com/saezlab/visium_heart/blob/5b30c7e497e06688a8448afd8d069d2fa70ebcd2/st_snRNAseq/06_atlas_comparison/get_pseudobulk_profiles.R#L4</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>#1 ps_integrated_slides_niches---------</span></span></code><code><span>{</span></code><code><span>  </span></code><code><span>  <span># Evaluate parameters </span></span></code><code><span>  </span></code><code><span>  slide_files &lt;- <span>"/home/data/t040413/silicosis/spatial/integrated_slides/integrated_slides.rds"</span></span></code><code><span>  </span></code><code><span>  <span># Identify levels of pseudobulking</span></span></code><code><span>  vars=c(<span>"orig.ident"</span>,<span>"opt_clust_integrated"</span>)</span></code><code><span>  </span></code><code><span>  vars &lt;- set_names( unlist(strsplit(vars, <span>","</span>))  )  </span></code><code><span>  <span>print</span>(vars)</span></code><code><span>  </span></code><code><span>  <span># Read data and create pseudobulk profiles at two levels ----------------------------------</span></span></code><code><span>  </span></code><code><span>  get_sample_pseudo &lt;- <span><span>function</span><span>(slide_file, vars, group_vars = <span>"n"</span>)</span> </span>{</span></code><code><span>    </span></code><code><span>    slide &lt;- readRDS(slide_file)</span></code><code><span>    </span></code><code><span>    <span>if</span>(group_vars == <span>"n"</span>) {</span></code><code><span>      </span></code><code><span>      <span># Creates pseudobulk profile for each var</span></span></code><code><span>      bulk_p_data &lt;- map(vars, <span><span>function</span><span>(x)</span> </span>{ </span></code><code><span>        sumCountsAcrossCells(x = GetAssayData(slide, assay =<span>"Spatial"</span>, slot = <span>"counts"</span>),</span></code><code><span>                             ids = slide@meta.data[, x])</span></code><code><span>      })</span></code><code><span>      </span></code><code><span>    } <span>else</span> { </span></code><code><span>      </span></code><code><span>      bulk_p_data &lt;- <span>list</span>()</span></code><code><span>      bulk_p_data[[<span>"gex"</span>]] &lt;- sumCountsAcrossCells(x = GetAssayData(slide, assay = def_assay, slot = <span>"counts"</span>),</span></code><code><span>                                                   ids = DataFrame(slide@meta.data[, vars]))</span></code><code><span>      </span></code><code><span>    }</span></code><code><span>    </span></code><code><span>    bulk_p_data[[<span>"annotations"</span>]] &lt;- slide@meta.data</span></code><code><span>    </span></code><code><span>    <span>return</span>(bulk_p_data)</span></code><code><span>  }</span></code><code><span>  </span></code><code><span>  </span></code><code><span>  </span></code><code><span>  </span></code><code><span>  pseudobulk_profiles &lt;- map(set_names(slide_files), </span></code><code><span>                             get_sample_pseudo, </span></code><code><span>                             vars = vars,</span></code><code><span>                             group_vars = <span>"collapsed"</span>)</span></code><code><span>  </span></code><code><span>  </span></code><code><span>  pseudobulk_profiles[[<span>1</span>]][[<span>1</span>]]</span></code><code><span>  </span></code><code><span>  colData(pseudobulk_profiles[[<span>1</span>]][[<span>1</span>]])</span></code><code><span>  </span></code><code><span>  saveRDS(pseudobulk_profiles,file = <span>"~/silicosis/spatial/integrated_slides/ps_integrated_slides_niches.rds"</span>)</span></code><code><span>  </span></code><code><span>  </span></code><code><span>  </span></code><code><span>}</span></code><code><span>  </span></code><code><span> <span>####2 ps_integrated_slides.rds-----</span></span></code><code><span> {</span></code><code><span>   </span></code><code><span>   <span># Evaluate parameters </span></span></code><code><span>   slide_files &lt;- <span>"/home/data/t040413/silicosis/spatial/integrated_slides/integrated_slides.rds"</span></span></code><code><span>   </span></code><code><span>   <span># Identify levels of pseudobulking</span></span></code><code><span>   vars=c(<span>"orig.ident"</span>)</span></code><code><span>   </span></code><code><span>   vars &lt;- set_names( unlist(strsplit(vars, <span>","</span>))  )  </span></code><code><span>   <span>print</span>(vars)</span></code><code><span>   </span></code><code><span>   <span># Read data and create pseudobulk profiles at two levels --</span></span></code><code><span>   </span></code><code><span>   get_sample_pseudo &lt;- <span><span>function</span><span>(slide_file, vars, group_vars = <span>"n"</span>)</span> </span>{</span></code><code><span>     </span></code><code><span>     slide &lt;- readRDS(slide_file)</span></code><code><span>     </span></code><code><span>     <span>if</span>(group_vars == <span>"n"</span>) {</span></code><code><span>       </span></code><code><span>       <span># Creates pseudobulk profile for each var</span></span></code><code><span>       bulk_p_data &lt;- map(vars, <span><span>function</span><span>(x)</span> </span>{ </span></code><code><span>         sumCountsAcrossCells(x = GetAssayData(slide, assay =<span>"Spatial"</span>, slot = <span>"counts"</span>),</span></code><code><span>                              ids = slide@meta.data[, x])</span></code><code><span>       })</span></code><code><span>       </span></code><code><span>     } <span>else</span> { </span></code><code><span>       </span></code><code><span>       bulk_p_data &lt;- <span>list</span>()</span></code><code><span>       bulk_p_data[[<span>"gex"</span>]] &lt;- sumCountsAcrossCells(x = GetAssayData(slide, assay = def_assay, slot = <span>"counts"</span>),</span></code><code><span>                                                    ids = DataFrame(slide@meta.data[, vars]))</span></code><code><span>       </span></code><code><span>     }</span></code><code><span>     </span></code><code><span>     bulk_p_data[[<span>"annotations"</span>]] &lt;- slide@meta.data</span></code><code><span>     </span></code><code><span>     <span>return</span>(bulk_p_data)</span></code><code><span>   }</span></code><code><span>   </span></code><code><span>   </span></code><code><span>   </span></code><code><span>   </span></code><code><span>   pseudobulk_profiles &lt;- map(set_names(slide_files), </span></code><code><span>                              get_sample_pseudo, </span></code><code><span>                              vars = vars,</span></code><code><span>                              group_vars = <span>"n"</span>)</span></code><code><span>   </span></code><code><span>   </span></code><code><span>   pseudobulk_profiles[[<span>1</span>]][[<span>1</span>]]</span></code><code><span>   </span></code><code><span>   colData(pseudobulk_profiles[[<span>1</span>]][[<span>1</span>]])</span></code><code><span>   </span></code><code><span>   head(pseudobulk_profiles[[<span>1</span>]][[<span>2</span>]])</span></code><code><span>   </span></code><code><span> <span>#https://github.com/saezlab/visium_heart/blob/5b30c7e497e06688a8448afd8d069d2fa70ebcd2/st_snRNAseq/jobs/run_spatial_pseudobulk.sh#L25  </span></span></code><code><span>  </span></code><code><span>   </span></code><code><span>    saveRDS(pseudobulk_profiles,file = <span>"~/silicosis/spatial/integrated_slides/ps_integrated_slides.rds"</span>)</span></code><code><span>   </span></code><code><span>   </span></code><code><span> }</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code></pre></section><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/ZAgpFExgKY7Xj5Ich5NWCg",target="_blank" rel="noopener noreferrer">原文链接</a>
