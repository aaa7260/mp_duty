---
title: "ORA富集分析"
date: 2024-01-02T15:48:51Z
draft: ["false"]
tags: [
  "fetched",
  "生信菜鸟团"
]
categories: ["Acdemic"]
---
ORA富集分析 by 生信菜鸟团
------
<div><section data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><blockquote data-tool="mdnice编辑器"><span>❝</span><p>Over Representation Analysis</p><span>❞</span></blockquote><h3 data-tool="mdnice编辑器"><span></span><span>超几何分布</span><span></span></h3><p data-tool="mdnice编辑器">这部分内容摘自百度百科。超几何分布是统计学上一种离散概率分布。它描述了从有限N个物件（其中包含M个指定种类的物件）中抽出n个物件，成功抽出该指定种类的物件的次数（不放回）。超几何分布中的参数是N,n,M，上述超几何分布记作X~H(N,n,M)</p><p data-tool="mdnice编辑器">产品抽样检查中经常遇到一类实际问题，假定在N件产品中有M件不合格品，即不合格率：<img data-imgfileid="100035726" data-ratio="0.6385542168674698" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaJWagia2ia9jTbib5JBL0FRZTuOiarDlH1VFX0kXXJl99UjGU1A5iarSicibEA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="166" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaJWagia2ia9jTbib5JBL0FRZTuOiarDlH1VFX0kXXJl99UjGU1A5iarSicibEA/640?wx_fmt=png&amp;from=appmsg">在产品中随机抽n件做检查，发现k件不合格品的概率<sup>[1]</sup>为：<img data-imgfileid="100035724" data-ratio="0.2551440329218107" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swalgphzXCXId7NK8JTkicFQVwQdk586KNAXib4MeVpKeUq8r9SnicFEzjVQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="486" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swalgphzXCXId7NK8JTkicFQVwQdk586KNAXib4MeVpKeUq8r9SnicFEzjVQ/640?wx_fmt=png&amp;from=appmsg">k的取值范围：（k=t，t+1，…，s）</p><p data-tool="mdnice编辑器">其中s是M与n中的较小者，t在n不大于合格品数（即n≤N-M）时取0，否则t取n减合格品数之差（即t=n-(N-M)）亦可写作：<img data-imgfileid="100035725" data-ratio="0.39444444444444443" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swa7EfFKmgH4zhgB428mUxeNqxU2v2rqSweM9rPFrvlRamITbZpicbOYpw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="360" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swa7EfFKmgH4zhgB428mUxeNqxU2v2rqSweM9rPFrvlRamITbZpicbOYpw/640?wx_fmt=png&amp;from=appmsg">（与上式不同的是M可为任意实数，而C表示的组合数M为非负整数）<img data-imgfileid="100035723" data-ratio="0.75" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaewWpLv29RRHMz2arj42lDohpLibEGx2RTNnGUSIPJCp6sPmuwgCqd1Q/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="88" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaewWpLv29RRHMz2arj42lDohpLibEGx2RTNnGUSIPJCp6sPmuwgCqd1Q/640?wx_fmt=png&amp;from=appmsg">为古典概型的组合形式，a为下限，b为上限，此时我们称随机变量<sup>[2]</sup>X服从超几何分布（hypergeometric distribution）</p><p data-tool="mdnice编辑器">需要注意的是：</p><ul data-tool="mdnice编辑器"><li><section>（1）超几何分布的模型是不放回抽样。</section></li><li><section>（2）超几何分布中的参数是N,n,M，上述超几何分布记作X~H(N,n,M)。</section></li></ul><h3 data-tool="mdnice编辑器"><span></span><span>ORA过表达分析</span><span></span></h3><p data-tool="mdnice编辑器">富集分析的算法有很多，最常用是Over Representation Analysis，ORA过表达分析，其次是gene set enrichment analysis, GSEA基因集富集分析。</p><p data-tool="mdnice编辑器">具体区别详见这篇知乎文章：https://zhuanlan.zhihu.com/p/534016487<sup>[3]</sup></p><p data-tool="mdnice编辑器">本文讲更简单易懂的ORA过表达分析</p><p data-tool="mdnice编辑器">过表达分析(ORA)的输入需要数据：</p><ul data-tool="mdnice编辑器"><li><section>背景基因集：一个物种的某个数据库，包含多个子集。如GO数据库中,有三个ontology（本体），分别描述基因的细胞组分（cellular component，CC）、分子功能（molecular function，MF）、参与的生物过程（biological process，BP）。在R包GO.db，version=3.18中，BP、MF、CC分别包含了15709、1977、5055个通路。</section></li><li><section>特定基因集：常常是差异表达基因集(differentially expressed genes, DEGs)，也可以使用WGCNA识别到的模块中的基因等其他来源</section></li></ul><p data-tool="mdnice编辑器">ORA过表达分析实质上就是Fisher's 精确检验：</p><p data-tool="mdnice编辑器">我们可以形象的理解富集分析：</p><p data-tool="mdnice编辑器">例如GO数据库的1w8k个基因中，1000个基因在一个通路中，17000个基因在这个通路外，我们有2000个差异表达基因，其中在通路中为600个，不在通路外有1400个。就可以理解为从1w8k个球的桶中不放回的抽球，桶中有1000个黑球和17000个白球，我们进行2000次不放回的抽取，抽到了600个黑球和1400个白球。</p><p data-tool="mdnice编辑器">富集分析的P值：即计算出现抽中600个球（通路中富集到600个基因）及以上（更极端情况）概率之和。并与显著性系数0.05/0.01/0.001进行比较。</p><p data-tool="mdnice编辑器">推荐看这篇文章：https://zhuanlan.zhihu.com/p/110932405<sup>[4]</sup></p><p data-tool="mdnice编辑器">应用如下公式计算抽到k个球的概率：</p><figure data-tool="mdnice编辑器"><img data-imgfileid="100035722" data-ratio="0.1992619926199262" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swa2oiaQJBHiapQa9WDgH7mreUZvoJunD3tNo8Mm4Lvflf64UicrVO1I2IiaA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="542" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swa2oiaQJBHiapQa9WDgH7mreUZvoJunD3tNo8Mm4Lvflf64UicrVO1I2IiaA/640?wx_fmt=png&amp;from=appmsg"><figcaption><br></figcaption></figure><p data-tool="mdnice编辑器">其中n为差异表达基因数，k为差异表达基因中富集到通路（子集）中的基因（就是在通路中的差异表达基因），M是通路（子集）中基因数量，N为数据库中所有基因的基因数（在GO的BP，MF，CC中各约为1w8k个）。</p><p data-tool="mdnice编辑器">上式计算得到的是p为k个基因富集到通路中的概率，在富集分析中，我们要对k，k+1，k+2.......n或M（当差异表达基因数＜通路中基因数时，取n为最大，代表所有差异表达基因都富集在该通路下；</p><p data-tool="mdnice编辑器">当差异表达基因数＞通路中基因数时，取m为最大，代表该通路中全部基因都为差异表达基因）的概率进行求和。即代表有k及以上个差异表达基因富集到通路中的概率（极端情况），若这个概率p＜0.05/0.01。则认为其为小概率事件，在一次假设检验中不可能发生，拒绝原假设，接受备择假设，也就差异表达基因与该通路有比较强的联系。</p><h3 data-tool="mdnice编辑器"><span></span><span>代码实现</span><span></span></h3><p data-tool="mdnice编辑器">这里我们以GO数据库为例</p><p data-tool="mdnice编辑器">因为我是从写好的整个函数里摘出对应的代码的，所以先需要给一些参数赋值，同时我们取500个感兴趣（这里只是示例）的基因作为输入</p><pre data-tool="mdnice编辑器"><span></span><code><span>#注意在调试代码的时候不要与以下变量重名</span><br>min_gene=<span>10</span><br>max_gene=<span>500</span><br>org=<span>"org.Hs.eg.db"</span><br>method=<span>"BH"</span><br>pvalue_cutoff=<span>0.05</span><br>padjust_cutoff=<span>0.05</span><br><br><span>#这里我们随便取一些基因作为差异表达基因，可以使用自己找的</span><br><span>#我写的代码需要entrezid作为数据输入，所以</span><br><br><span>library</span>(dplyr)<br><span>library</span>(AnnotationDbi)<br><span>library</span>(org,character.only = <span>T</span>)<br><span>#随便取前500个id赋给向量gene</span><br>AnnotationDbi::keys(org.Hs.eg.db,keytype = <span>"ENTREZID"</span>) %&gt;% head(.,<span>2000</span>)-&gt;gene<br><br></code></pre><p data-tool="mdnice编辑器">现在向量gene里有500个基因的entrezid</p><p data-tool="mdnice编辑器"><img data-imgfileid="100035729" data-ratio="0.10318949343339587" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swa0cGiaYwjlZibgZeoxupIGMdxJMBiccZoNZnsqzNBkncRb80PoeRs4szdw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1066" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swa0cGiaYwjlZibgZeoxupIGMdxJMBiccZoNZnsqzNBkncRb80PoeRs4szdw/640?wx_fmt=png&amp;from=appmsg">因为BP，MF，CC中有注释的总的基因数不同，我们要对这三个ontology分别进行过表达分析，所以需要计算他们下面的所包含基因的数量</p><pre data-tool="mdnice编辑器"><span></span><code><span>#gs是该物种org.db中包含的通路，就是这个物种有的通路</span><br>gs&lt;-as.list(get(paste0(strsplit(org,<span>".db"</span>)[[<span>1</span>]],<span>"GO2ALLEGS"</span>)))<br><span>#去重复</span><br>gs = lapply(gs, unique)<br></code></pre><p data-tool="mdnice编辑器">gs是一个列表，其下面每一个元素包含一个向量，向量内容为该通路下的所有基因<img data-imgfileid="100035731" data-ratio="0.38943894389438943" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaVdf4y03cFMrIPKdTrSl9j0ZicTKRkawaQeXNDjulDwh0T4fmzMBJpJw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="606" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaVdf4y03cFMrIPKdTrSl9j0ZicTKRkawaQeXNDjulDwh0T4fmzMBJpJw/640?wx_fmt=png&amp;from=appmsg"></p><pre data-tool="mdnice编辑器"><span></span><code><span>#载入GO.db包</span><br><span>library</span>(GO.db)<br>as.list(GOTERM)-&gt;GO<br></code></pre><p data-tool="mdnice编辑器">GO也是一个列表，其每个元素下是一个S4类对象，包含信息有：</p><ul data-tool="mdnice编辑器"><li><section>GOID：该通路在GO数据库中的编号</section></li><li><section>Term：通路名称</section></li><li><section>Ontology：属于哪个“本体”，就是是BP，MF还是CC</section></li><li><section>Defination：详细描述</section></li><li><section>Synonym：同义词</section></li><li><section>Secondary：Alternate term identifier就是备用的通路识别号，就是搜这个编号也能出来这个通路</section></li></ul><p data-tool="mdnice编辑器"><img data-imgfileid="100035727" data-ratio="0.3535228677379481" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaLduV0ukNmnm0788BLSIv3adQSQFSAso0DUBs8icVBc28ZpFYaficmuNg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="809" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaLduV0ukNmnm0788BLSIv3adQSQFSAso0DUBs8icVBc28ZpFYaficmuNg/640?wx_fmt=png&amp;from=appmsg">其实这个列表就等于GO数据库搜索ontology的网页界面<img data-imgfileid="100035730" data-ratio="0.14537037037037037" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swamYibBCljWj5H3BiaQPJ3vIh73Ile86TGtz4xJvoEMkHlwCnOJ7oiaZQnA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swamYibBCljWj5H3BiaQPJ3vIh73Ile86TGtz4xJvoEMkHlwCnOJ7oiaZQnA/640?wx_fmt=png&amp;from=appmsg"></p><pre data-tool="mdnice编辑器"><span></span><code>  <span>#获取该物种有的GO_accession</span><br>  GO[names(gs)]-&gt;GO<br>  <span>#提取GO列表中的每一个元素下的GOID,Term,Ontology,Definition</span><br>  <span>#这里是写了一个函数，用lapply循环列表下的每一个元素，使用@提取其信息，以向量的形式返回赋给go_anno</span><br>  go_anno&lt;-lapply(GO,<span>function</span>(element){<br>    d&lt;-c(element@GOID,element@Term,element@Ontology,element@Definition)<br>    <span>return</span>(d)<br>  })<br>  t(as.data.frame(go_anno))-&gt;go_anno<br>  colnames(go_anno)&lt;-c(<span>"GOID"</span>,<span>"Term"</span>,<span>"Ontology"</span>,<span>"Definition"</span>)<br>  gsub(<span>"\\."</span>, <span>":"</span>, rownames(go_anno))-&gt;rownames(go_anno)<br>  <span>#这里有个小坑，GO数据库的编号都是GO:XXXXXXXX,而go_anno中的行名为GO.XXXXXXXX，用gsub函数替换一下</span><br></code></pre><p data-tool="mdnice编辑器">go_anno中的信息将用于我们最后输出的表格，毕竟我们也需要知道自己富集到了什么东西（生物学意义）<img data-imgfileid="100035728" data-ratio="0.39669421487603307" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaov8WxjepkCrrWzGMBee4rFomc0jEfia3ZGeLbVddyOg6FsbBIB5JLsQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="847" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaov8WxjepkCrrWzGMBee4rFomc0jEfia3ZGeLbVddyOg6FsbBIB5JLsQ/640?wx_fmt=png&amp;from=appmsg">上文说到BP，CC，MF中包含基因数量不同。所以我们富集分析时所有基因的数量N应该根据这三个ontology发生改变：</p><pre data-tool="mdnice编辑器"><span></span><code>  <span>#获取BP下包含的全部基因</span><br>  <span>#从go_anno信息中取出第三列为BP的GOid</span><br>  rownames(go_anno[go_anno[,<span>3</span>]==<span>"BP"</span>,])-&gt;GO_BP<br>  <span>#然后用unlist将gs列表中所有对应BP的元素（内容前文说到是包含基因entrezid的向量）从头到尾连成一个向量</span><br>  BP_gene&lt;-unlist(gs[GO_BP],use.names = <span>F</span>)<br>  <span>#然后进行去重，就得到ontology BP中的所有基因了</span><br>  unique(BP_gene)-&gt;BP_gene<br>  <br>  <span>#如法炮制，获取CC下包含的全部基因</span><br>  rownames(go_anno[go_anno[,<span>3</span>]==<span>"CC"</span>,])-&gt;GO_CC<br>  CC_gene&lt;-unlist(gs[GO_CC],use.names = <span>F</span>)<br>  unique(CC_gene)-&gt;CC_gene<br>  <span>#如法炮制，获取MF下包含的全部基因</span><br>  rownames(go_anno[go_anno[,<span>3</span>]==<span>"MF"</span>,])-&gt;GO_MF<br>  MF_gene&lt;-unlist(gs[GO_MF],use.names = <span>F</span>)<br>  unique(MF_gene)-&gt;MF_gene<br></code></pre><p data-tool="mdnice编辑器">富集分析的限速步骤是判断差异表达基因是否在通路中，由上文知道BP+MF+CC总共有2w多通路，R的intersect()函数过于低效，所以这里我们使用顾叔提速富集分析的方法:<a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjUzODM4Ng==&amp;mid=2247484287&amp;idx=1&amp;sn=2c8cc00888c559403f7ecabc298b6ef9&amp;scene=21#wechat_redirect" data-linktype="2">https://mp.weixin.qq.com/s/G1gFGgu0jPzXWE97nxW4Qw</a></p><pre data-tool="mdnice编辑器"><span></span><code>  <span>library</span>(Rcpp)<br>  sourceCpp(code = <span>'<br>// [[Rcpp::plugins(cpp11)]]<br><br>#include &lt;Rcpp.h&gt;<br>#include &lt;unordered_set&gt;<br>using namespace Rcpp;<br><br>// [[Rcpp::export]]<br>List intersectToList(List lt, StringVector x) {<br><br>    int n = lt.size();<br>    List out(n);<br><br>    std::unordered_set&lt;String&gt; seen;<br>    seen.insert(x.begin(), x.end());<br><br>    for(int i = 0; i &lt; n; i++) {<br><br>        StringVector v = as&lt;StringVector&gt;(lt[i]);<br>        LogicalVector l(v.size());<br><br>        std::unordered_set&lt;String&gt; seen2;<br><br>        for(int j = 0; j &lt; v.size(); j ++) {<br>            l[j] = seen.find(v[j]) != seen.end() &amp;&amp; seen2.insert(v[j]).second;<br>        }<br><br>        out[i] = v[l];<br>    }<br><br>    return out;<br>}<br>'</span>)<br></code></pre><p data-tool="mdnice编辑器">这里顾叔定义了一个函数intersectToList()，可以在R中使用。它接受两个参数。第一个是一个包含了若干向量的列表（lt），第二个参数是一个向量（x），其中x会和lt中的每一个向量进行intersection。在Cpp代码中，顾叔去掉了lt中每一个向量中重复的元素。</p><p data-tool="mdnice编辑器">虽然我们不会c++，但是我们只需要会用顾叔的代码就好了，这就是一名生（代）信（码）工（裁）程（缝）师应有的修养。</p><p data-tool="mdnice编辑器">以下是用于将entrezid转换成gene symbol，作为输出使结果可读性更高的代码</p><pre data-tool="mdnice编辑器"><span></span><code>  <span>#获取ENTREZID和symbol对应关系</span><br>  k&lt;-keys(org.Hs.eg.db,keytype = <span>"ENTREZID"</span>)<br>  e2s&lt;-AnnotationDbi::select(org.Hs.eg.db,keys=k,columns=<span>"SYMBOL"</span>,keytype = <span>"ENTREZID"</span>)<br>  symbol&lt;-e2s[,<span>2</span>];names(symbol)&lt;-e2s[,<span>1</span>]<br>  <br>  <span>#定义一个函数，其输入为entrezid的向量，转化成symbol的向量</span><br>  symboltrans&lt;-<span>function</span>(element,symbol) {<br>    element&lt;-paste(symbol[element],collapse = <span>"/"</span>)<br>    <span>return</span>(element)}<br></code></pre><p data-tool="mdnice编辑器">接下来就是计算富集分析的p value，adjust p value，generatio，bgratio，fold enrich，enrich factor了：</p><ul data-tool="mdnice编辑器"><li><section>GeneRatio：差异表达基因富集到目的通路基因数占差异表达基因数的比例</section></li><li><section>BgRatio：目标通路基因数占通路集总基因数的比例</section></li><li><section>pvalue：假设检验结果的显著性</section></li><li><section>p.adj：多重假设检验校正后p值，默认使用“BH”法</section></li><li><section>Fold_Enrichment：GeneRatio / BgRatioRich_Factor：富集到通路中的基因数/通路中基因数（即GeneRatio的分子除以BgRatio的分母）</section></li></ul><p data-tool="mdnice编辑器">我们定义一个函数ora_v3（函数名是沿用顾叔推文的取名），然后写一个循环调用函数进行富集分析</p><pre data-tool="mdnice编辑器"><span></span><code>  ora_v3 = <span>function</span>(genes, gene_sets, universe ,symbol ,min_gene , max_gene ,<br>                    method ,pvalue_cutoff ,padjust_cutoff) {<br>    <br>    <span>#m为基因集中每个通路包含的基因数量</span><br>    m = sapply(gene_sets, length)<br>    m &gt;= min_gene &amp; m &lt;= max_gene -&gt;keep<br>    m[keep]-&gt;m<br>    gene_sets[keep]-&gt;gene_sets<br>    <br>    <span>#基因集的名字</span><br>    gs_names = names(gene_sets)<br>    <span>#取基因集中在MF/BP/CC中的基因</span><br>    genes = intersect(genes, universe)<br>    <span>#函数intersectToList()可以在R中使用。它接受两个参数。</span><br>    <span>#第一个是一个包含了若干向量的列表（lt），第二个参数是一个向量（x）。</span><br>    <span>#其中x会和lt中的每一个向量进行intersection。在Cpp代码中，顾叔也去掉了lt中每一个向量中重复的元素</span><br>    n_universe = length(universe)<br>    n_genes = length(genes)<br>    <br>    <span>#对基因集列表每一个子列表进行循环，判断基因是否在通路中，返回在通路中的差异表达基因</span><br>    genes_in_set&lt;-intersectToList(gene_sets, genes)<br>    <span>#x为每个通路中富集到基因的数量</span><br>    x = sapply(genes_in_set, length)<br>    <br>    x!=<span>0</span> -&gt;keep<br>    x[keep]-&gt;x<br>    m[keep]-&gt;m<br>    gene_sets[keep]-&gt;gene_sets<br>    gs_names[keep]-&gt;gs_names<br>    genes_in_set[keep]-&gt;genes_in_set<br>    <br>    <span>#创建一个向量，其每一个元素对应富集到的通路中的所有基因的gene symbol，使用/作为分隔</span><br>    genesymbol&lt;-c()<br>    <span>for</span>(i <span>in</span> <span>1</span>:length(genes_in_set)){<br>      genesymbol[i]&lt;-paste(symboltrans(genes_in_set[[i]],symbol),collapse = <span>"/"</span>)<br>    }<br>    <span>#GeneRatio:x/k,BgRatio:m/n_universe</span><br>    <span>#包含在ontology中但不在m对应通路中的基因数量</span><br>    n = n_universe - m<br>    <span>#差异表达基因数量</span><br>    k = n_genes<br>    <br>    GeneRatio = paste(x,k,sep=<span>"/"</span>)<br>    BgRatio = paste(m,n_universe,sep=<span>"/"</span>)<br>    Fold_Enrichment=(x*n_universe)/(k*m)<br>    Rich_Factor=x/k<br>    <br>    <span>#可以尝试下不用phyer函数，自己写，phyer函数就是计算：</span><br>    <span>#通路中富集到基因的数量大于等于x的极端情况的概率，即富集分析的p值</span><br>    p = phyper(x - <span>1</span>, m, n, k, lower.tail = <span>FALSE</span>)<br>    <span>#method默认是BH法</span><br>    p.adjust=p.adjust(p,method = method)<br>    <br>    <span>#将结果输出为数据框</span><br>    output&lt;-data.frame(GeneRatio=GeneRatio,BgRatio=BgRatio,<br>                       gene_symbol=genesymbol,count=x,pvalue=p,p.adjust=p.adjust,<br>                       Fold_Enrichment=Fold_Enrichment,Rich_Factor=Rich_Factor)<br>    rownames(output)&lt;-gs_names<br>    <br>    <span>#这个判断是使用p value还是p adjust进行结果筛选，默认为p value&lt;0.05</span><br>    <span>if</span>(is.null(padjust_cutoff)){<br>      output[output$pvalue &lt;= pvalue_cutoff,]-&gt;output<br>    }<br>    <span>else</span>{<br>      output[output$p.adjust &lt;= padjust_cutoff,]-&gt;output<br>    }<br>    <br>    <span>return</span>(output)<br>  }<br><br><span>#这个for循环是对BP,MF,CC三个ontology分别进行过表达分析，结果赋给BP_Res,MF_Res,CC_Res</span><br>    <span>for</span> (k <span>in</span> c(<span>"BP"</span>,<span>"MF"</span>,<span>"CC"</span>)) {<br>      assign(paste0(k,<span>"_Res"</span>),ora_v3(gene,gs[get(paste0(<span>"GO_"</span>,k))],<br>                                    get(paste0(k,<span>"_gene"</span>)),<br>                                    symbol=symbol ,min_gene=min_gene ,max_gene=max_gene, method=method,<br>                                    pvalue_cutoff=pvalue_cutoff,padjust_cutoff=padjust_cutoff))<br>}<br></code></pre><p data-tool="mdnice编辑器">最后合并结果输出为一个表格</p><pre data-tool="mdnice编辑器"><span></span><code>  rbind(BP_Res,MF_Res,CC_Res)-&gt;Res<br>  cbind(go_anno[match(rownames(Res),rownames(go_anno)),],Res)-&gt;Res<br> write.csv(Res,file = <span>"ORA_res.csv"</span>)<br></code></pre><p data-tool="mdnice编辑器">我将上文所有内容封装成了一个函数，最简单的用法就是输入一个是基因entrezid的向量，返回结果就是过表达分析的表格，函数代码如下：</p><ul data-tool="mdnice编辑器"><li><section>参数gene就是输入的entrezid向量，</section></li><li><section>min_gene是默认过滤掉富集到基因数量＜10的通路，</section></li><li><section>org就是研究物种的org.db包，注意，只有在bioconductor上有才能做过表达分析，否则无法使用我的代码，</section></li><li><section>method是p值校正方法，默认BH法（其他可用方法详见stats包的p.adjust函数），</section></li><li><section>pvalue_cutoff是过滤掉p值＜0.05的结果，</section></li><li><section>padjust_cutoff是过滤掉p值校正值＜0.05的结果。（默认使用pvalue_cutoff过滤，当设置padjust_cutoff时，优先使用padjust_cutoff进行过滤）</section></li></ul><pre data-tool="mdnice编辑器"><span></span><code><span>#GO数据库ORA富集分析函数 enrichment function written by Xiao Chen</span><br><br><span>#输入为ENTREZID，通路中默认最少要包含10个基因，物种默认为人类</span><br><span>#p值校正方法BH法，结果显示阈值：p值小于0.05，padjust结果显示阈值为空</span><br>ORA_GO&lt;-<span>function</span>(gene,min_gene=<span>10</span>,max_gene=<span>500</span>,org=<span>"org.Hs.eg.db"</span>,method=<span>"BH"</span>,<br>            pvalue_cutoff=<span>0.05</span>,padjust_cutoff=<span>NULL</span>){<br>  <span>library</span>(AnnotationDbi)<br>  <span>library</span>(org,character.only = <span>T</span>)<br>  <br>  <span>#gs是该物种org.db中包含的通路，就是这个物种有的通路</span><br>  gs&lt;-as.list(get(paste0(strsplit(org,<span>".db"</span>)[[<span>1</span>]],<span>"GO2ALLEGS"</span>)))<br>  <span>#去重复</span><br>  gs = lapply(gs, unique)<br>  <br>  <span>#方法2.选择BP,MF,CC各自包含的基因分别作为背景基因</span><br>  <span>library</span>(GO.db)<br>  as.list(GOTERM)-&gt;GO<br>  <br>  <span>#取该物种有的GO_accession</span><br>  GO[names(gs)]-&gt;GO<br>  <span>#提取GO列表中的每一个元素下的GOID,Term,Ontology,Definition</span><br>  <span>#这里是写了一个函数，用lapply循环列表下的每一个元素，使用@提取其信息，以向量的形式返回赋给go_anno</span><br>  go_anno&lt;-lapply(GO,<span>function</span>(element){<br>    d&lt;-c(element@GOID,element@Term,element@Ontology,element@Definition)<br>    <span>return</span>(d)<br>  })<br>  t(as.data.frame(go_anno))-&gt;go_anno<br>  colnames(go_anno)&lt;-c(<span>"GOID"</span>,<span>"Term"</span>,<span>"Ontology"</span>,<span>"Definition"</span>)<br>  <span>#这里有个小坑，GO数据库的编号都是GO:XXXXXXXX,而go_anno中的行名为GO.XXXXXXXX，用gsub函数替换一下</span><br>  gsub(<span>"\\."</span>, <span>":"</span>, rownames(go_anno))-&gt;rownames(go_anno)<br>  <br>  <span>#获取BP下包含的全部基因</span><br>  <span>#从go_anno信息中取出第三列为BP的GOid</span><br>  rownames(go_anno[go_anno[,<span>3</span>]==<span>"BP"</span>,])-&gt;GO_BP<br>  <span>#然后用unlist将gs列表中所有对应BP的元素（内容前文说到是包含基因entrezid的向量）从头到尾连成一个向量</span><br>  BP_gene&lt;-unlist(gs[GO_BP],use.names = <span>F</span>)<br>  <span>#然后进行去重，就得到ontology BP中的所有基因了</span><br>  unique(BP_gene)-&gt;BP_gene<br>  <br>  <span>#如法炮制，获取CC下包含的全部基因</span><br>  rownames(go_anno[go_anno[,<span>3</span>]==<span>"CC"</span>,])-&gt;GO_CC<br>  CC_gene&lt;-unlist(gs[GO_CC],use.names = <span>F</span>)<br>  unique(CC_gene)-&gt;CC_gene<br>  <span>#如法炮制，获取MF下包含的全部基因</span><br>  rownames(go_anno[go_anno[,<span>3</span>]==<span>"MF"</span>,])-&gt;GO_MF<br>  MF_gene&lt;-unlist(gs[GO_MF],use.names = <span>F</span>)<br>  unique(MF_gene)-&gt;MF_gene<br>  <br>  <span>library</span>(Rcpp)<br>  sourceCpp(code = <span>'<br>// [[Rcpp::plugins(cpp11)]]<br><br>#include &lt;Rcpp.h&gt;<br>#include &lt;unordered_set&gt;<br>using namespace Rcpp;<br><br>// [[Rcpp::export]]<br>List intersectToList(List lt, StringVector x) {<br><br>    int n = lt.size();<br>    List out(n);<br><br>    std::unordered_set&lt;String&gt; seen;<br>    seen.insert(x.begin(), x.end());<br><br>    for(int i = 0; i &lt; n; i++) {<br><br>        StringVector v = as&lt;StringVector&gt;(lt[i]);<br>        LogicalVector l(v.size());<br><br>        std::unordered_set&lt;String&gt; seen2;<br><br>        for(int j = 0; j &lt; v.size(); j ++) {<br>            l[j] = seen.find(v[j]) != seen.end() &amp;&amp; seen2.insert(v[j]).second;<br>        }<br><br>        out[i] = v[l];<br>    }<br><br>    return out;<br>}<br>'</span>)<br>  <br>  <span>#获取ENTREZID和symbol对应关系</span><br>  k&lt;-keys(org.Hs.eg.db,keytype = <span>"ENTREZID"</span>)<br>  e2s&lt;-AnnotationDbi::select(org.Hs.eg.db,keys=k,columns=<span>"SYMBOL"</span>,keytype = <span>"ENTREZID"</span>)<br>  symbol&lt;-e2s[,<span>2</span>];names(symbol)&lt;-e2s[,<span>1</span>]<br>  <br>  <span>#定义一个函数，其输入为entrezid的向量，转化成symbol的向量</span><br>  symboltrans&lt;-<span>function</span>(element,symbol) {<br>    element&lt;-paste(symbol[element],collapse = <span>"/"</span>)<br>    <span>return</span>(element)}<br>  <br>  ora_v3 = <span>function</span>(genes, gene_sets, universe ,symbol ,min_gene , max_gene ,<br>                    method ,pvalue_cutoff ,padjust_cutoff) {<br>    <br>    <span>#m为基因集中每个通路包含的基因数量</span><br>    m = sapply(gene_sets, length)<br>    m &gt;= min_gene &amp; m &lt;= max_gene -&gt;keep<br>    m[keep]-&gt;m<br>    gene_sets[keep]-&gt;gene_sets<br>    <br>    <span>#基因集的名字</span><br>    gs_names = names(gene_sets)<br>    <span>#取差异表达基因中在MF/BP/CC中的基因</span><br>    genes = intersect(genes, universe)<br>    <span>#函数intersectToList()可以在R中使用。它接受两个参数。</span><br>    <span>#第一个是一个包含了若干向量的列表（lt），第二个参数是一个向量（x）。</span><br>    <span>#其中x会和lt中的每一个向量进行intersection。在Cpp代码中，顾叔也去掉了lt中每一个向量中重复的元素</span><br>    n_universe = length(universe)<br>    n_genes = length(genes)<br>    <br>    <span>#对基因集列表每一个子列表进行循环，判断基因是否在通路中，返回在通路中的差异表达基因</span><br>    genes_in_set&lt;-intersectToList(gene_sets, genes)<br>    <span>#x为每个通路中富集到基因的数量</span><br>    x = sapply(genes_in_set, length)<br>    <br>    x!=<span>0</span> -&gt;keep<br>    x[keep]-&gt;x<br>    m[keep]-&gt;m<br>    gene_sets[keep]-&gt;gene_sets<br>    gs_names[keep]-&gt;gs_names<br>    genes_in_set[keep]-&gt;genes_in_set<br>    <br>    <span>#创建一个向量，其每一个元素对应富集到的通路中的所有基因的gene symbol，使用/作为分隔</span><br>    genesymbol&lt;-c()<br>    <span>for</span>(i <span>in</span> <span>1</span>:length(genes_in_set)){<br>      genesymbol[i]&lt;-paste(symboltrans(genes_in_set[[i]],symbol),collapse = <span>"/"</span>)<br>    }<br>    <span>#GeneRatio:x/k,BgRatio:m/n_universe</span><br>    <span>#包含在ontology中但不在m对应通路中的基因数量</span><br>    n = n_universe - m<br>    <span>#差异表达基因数量</span><br>    k = n_genes<br>    <br>    GeneRatio = paste(x,k,sep=<span>"/"</span>)<br>    BgRatio = paste(m,n_universe,sep=<span>"/"</span>)<br>    Fold_Enrichment=(x*n_universe)/(k*m)<br>    Rich_Factor=x/k<br>    <br>    <span>#可以尝试下不用phyer函数，自己写</span><br>    p = phyper(x - <span>1</span>, m, n, k, lower.tail = <span>FALSE</span>)<br>    p.adjust=p.adjust(p,method = method)<br>    <br>    <span>#将结果输出为数据框</span><br>    output&lt;-data.frame(GeneRatio=GeneRatio,BgRatio=BgRatio,<br>                       gene_symbol=genesymbol,count=x,pvalue=p,p.adjust=p.adjust,<br>                       Fold_Enrichment=Fold_Enrichment,Rich_Factor=Rich_Factor)<br>    rownames(output)&lt;-gs_names<br>    <br>    <br>    <span>#这个判断是使用p value还是p adjust进行结果筛选，默认为p value&lt;0.05</span><br>    <br>    <span>if</span>(is.null(padjust_cutoff)){<br>      output[output$pvalue &lt;= pvalue_cutoff,]-&gt;output<br>    }<br>    <span>else</span>{<br>      output[output$p.adjust &lt;= padjust_cutoff,]-&gt;output<br>    }<br>    <br>    <br>    <br>    <span>return</span>(output)<br>  }<br>  <span>#这个for循环是对BP,MF,CC三个ontology分别进行过表达分析，结果赋给BP_Res,MF_Res,CC_Res</span><br>    <span>for</span> (k <span>in</span> c(<span>"BP"</span>,<span>"MF"</span>,<span>"CC"</span>)) {<br>      assign(paste0(k,<span>"_Res"</span>),ora_v3(gene,gs[get(paste0(<span>"GO_"</span>,k))],<br>                                    get(paste0(k,<span>"_gene"</span>)),<br>                                    symbol=symbol ,min_gene=min_gene ,<br>                                    max_gene=max_gene,method=method,<br>                                    pvalue_cutoff=pvalue_cutoff,padjust_cutoff=padjust_cutoff))<br>}<br>  <br>  rbind(BP_Res,MF_Res,CC_Res)-&gt;Res<br>  cbind(go_anno[match(rownames(Res),rownames(go_anno)),],Res)-&gt;Res<br>  <br>  <span>return</span>(Res)<br>}<br></code></pre><p data-tool="mdnice编辑器">现在调用我们的函数，查看富集分析结果，并使用system.time()记录运行时间</p><pre data-tool="mdnice编辑器"><span></span><code><span>#除了gene参数必须输入，其他参数都是可选或可缺省的</span><br>assign(<span>"Res1"</span>,ORA_GO(gene,padjust_cutoff=<span>0.05</span>)) %&gt;% system.time()<br>write.csv(Res1,file = <span>"ORA_res1.csv"</span>)<br></code></pre><p data-tool="mdnice编辑器"><img data-imgfileid="100035734" data-ratio="0.12618296529968454" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaZNAykPqlrcNGY7yUk8bAd5liaQD1zEuQgSvnB5RTuiapf2T05J394Eyg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="951" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaZNAykPqlrcNGY7yUk8bAd5liaQD1zEuQgSvnB5RTuiapf2T05J394Eyg/640?wx_fmt=png&amp;from=appmsg">y叔的clusterProfiler表现</p><pre data-tool="mdnice编辑器"><span></span><code><span>library</span>(clusterProfiler)<br><span>#因为我们的代码没有计算qvalue且没有设置maxGSSize，为了方便比对结果，设为最大不影响输出</span><br>assign(<span>"Res2"</span>,enrichGO(gene,<br>                       OrgDb = org.Hs.eg.db,<br>                       ont = <span>"ALL"</span>,<br>                       qvalueCutoff = <span>1</span>,<br>                       maxGSSize = <span>99999</span>,<br>                       readable = <span>T</span>)) %&gt;% system.time()<br>write.csv(Res2,file = <span>"ORA_res2.csv"</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-imgfileid="100035732" data-ratio="0.3317972350230415" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaiaF6vyOInDxIFJb6qwibIM0ukPyZI2yOqNTLI2icvUqCiafsZMoDOianMQA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="868" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaiaF6vyOInDxIFJb6qwibIM0ukPyZI2yOqNTLI2icvUqCiafsZMoDOianMQA/640?wx_fmt=png&amp;from=appmsg"><figcaption>image.png</figcaption></figure><pre data-tool="mdnice编辑器"><span></span><code><span>#检查两个函数富集到结果是否一致</span><br>Res1[order(Res1$p.adjust,Res1$GOID,decreasing = <span>F</span>),]-&gt;Res1<br>Res2[order(Res2$p.adjust,Res2$ID,decreasing = <span>F</span>),]-&gt;Res2<br>identical(Res1$GOID,Res2$ID)<br><span>#返回TRUE则一致</span><br></code></pre><p data-tool="mdnice编辑器">hh，之前还寻思着能不能不能做的比y叔快，结果越写越慢。相较于clusterprofiler我们的结果没有计算qvalue，但是提供了Fold_enrichment和Rich_Factor。</p><p data-tool="mdnice编辑器">ORA_res1.csv的内容如下：</p><figure data-tool="mdnice编辑器"><img data-imgfileid="100035733" data-ratio="0.22662889518413598" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaY0rBk86GtMzJCFKfkwjkHeTPUMs7aNibp38deDn0lkTPKR4dOyPyJhw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1059" src="https://mmbiz.qpic.cn/mmbiz_png/iaRJcrq2Los9tZDMjh5Uutkr2WR6ib4swaY0rBk86GtMzJCFKfkwjkHeTPUMs7aNibp38deDn0lkTPKR4dOyPyJhw/640?wx_fmt=png&amp;from=appmsg"><figcaption><br></figcaption></figure><p data-tool="mdnice编辑器">有了这样的富集分析结果，就可以使用ggplot2进行可视化了。这部分我们之前和中文互联网上内容比较多，篇幅问题不再详述。</p><h3 data-tool="mdnice编辑器"><span></span><span>总结：</span><span></span></h3><ol data-tool="mdnice编辑器"><li><section>富集分析可以简单的理解为不放回的抽球问题，其概率符合超几何分布。</section></li><li><section>富集分析p值为X个基因富集到通路中及大于X个基因富集到通路中（更极端的情况）的概率之和，p.adjust是对多重假设检验的校正，目的是减少假阳性率。</section></li><li><section>R语言中intersect函数在进行一万多次富集分析时明显较慢，我们可以使用顾叔用c++写的相同功能的函数可以提升一点富集分析的效率。</section></li></ol><h3 data-tool="mdnice编辑器"><span>Reference</span></h3><section data-tool="mdnice编辑器"><span><span>[1]</span><p>概率: <span>https://baike.baidu.com/item/%E6%A6%82%E7%8E%87/828845?fromModule=lemma_inlink</span></p></span><span><span>[2]</span><p>随机变量: <span>https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/828980?fromModule=lemma_inlink</span></p></span><span><span>[3]</span><p>https://zhuanlan.zhihu.com/p/534016487: <span>https://zhuanlan.zhihu.com/p/534016487</span></p></span><span><span>[4]</span><p>https://zhuanlan.zhihu.com/p/110932405: <span>https://zhuanlan.zhihu.com/p/110932405</span></p></span></section></section><p><br></p><h4 data-tool="mdnice编辑器">文末友情宣传</h4><p data-tool="mdnice编辑器">强烈建议你推荐给身边的<strong>博士后以及年轻生物学PI</strong>，多一点数据认知，让他们的科研上一个台阶：</p><ul data-tool="mdnice编辑器"><li><section><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247526014&amp;idx=1&amp;sn=44afb387fc49b89276386e5182db7bc9&amp;chksm=9b4b26c5ac3cafd35616b2fe9df7fea664e59d75e9970feb322a477beb222ac023f7daebb3dc&amp;scene=21#wechat_redirect" textvalue="生物信息学马拉松授课（买一得‍五）" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2" hasload="1">生物信息学马拉松授课（买一得五）</a> ，你的生物信息学入门课</section></li><li><section><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247524148&amp;idx=1&amp;sn=7806da6feb41a36493c519c1cfc1d3ac&amp;chksm=9b4bdf8fac3c569960369602f1ef26639cb366b250f233b2297d1f059471c0458335bfc0b829&amp;scene=21#wechat_redirect" textvalue="时隔5年，我们的生信技能树VIP学徒继续招生啦" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2" hasload="1">时隔5年，我们的生信技能树VIP学徒继续招生啦</a><br></section></li><li><section><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247525661&amp;idx=2&amp;sn=a0662fa3a9ebc7c840d45049eaca2c8c&amp;chksm=9b4b25a6ac3cacb0e9ba90eeb97452a9ee4eaed6bbbab1133f7a4836631047451c0cf295c93b&amp;scene=21#wechat_redirect" textvalue="搭配GPU服务再升级—256线程2Tb内存服务器共享一年仍然是仅需800" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2" hasload="1">搭配GPU服务再升级—256线程2Tb内存服务器共享一年仍然是仅需80</a>0</section></li></ul><p><mp-style-type data-value="10000"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/iy6sfrWJ8_HN9pm-eapGow",target="_blank" rel="noopener noreferrer">原文链接</a>
