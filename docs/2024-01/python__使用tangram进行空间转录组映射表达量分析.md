---
title: "python： 使用tangram进行空间转录组映射表达量分析"
date: 2024-01-20T04:53:35Z
draft: ["false"]
tags: [
  "fetched",
  "生信菜鸟团"
]
categories: ["Acdemic"]
---
python： 使用tangram进行空间转录组映射表达量分析 by 生信菜鸟团
------
<div><p>tangram是一种映射单细胞表达量数据到空间转录组数据的方法，它可以将单细胞中的表达量数据映射到空间转录组的每一个cell中。这对于一些gene panel数量较少的空间转录组技术如Xenium、CosMx等可以起到扩充基因数量的作用，因为tangram基因映射后的客观结果是使得每一个Xenium/CosMx数据集的细胞中的基因panel数量将和使用的单细胞数据集的panel数量保持一致，而单细胞数据集panel数量是可以轻松到2万+的。</p><p>tangram的官方教程可见GitHub - Tangram(https://github.com/broadinstitute/Tangram)。</p><p>本文的示例数据使用10x Genomics的Xenium官方数据，地址可见https://www.10xgenomics.com/products/xenium-in-situ/preview-dataset-human-breast。除了Xenium空间转录组数据，还附有连续切片来源的单细胞转录组数据。</p><p>所有数据如下：</p><blockquote><p>In Situ Sample 1, Replicate 1</p><p>In Situ Sample 1, Replicate 2</p><p>In Situ Sample 2</p><p>5’ Single Cell</p><p>3’ Single Cell</p><p>FRP</p><p>Visium Spatial</p></blockquote><h3><span>单步执行</span></h3><p>如上述，测试数据使用10x Genomics的Xenium官方数据。</p><pre><code><span>import</span> scanpy <span>as</span> sc<br><span>import</span> tangram <span>as</span> tg<br><br>xenium = sc.read_10x_mtx(<span>"data/Xenium_FFPE_Human_Cancer_Rep1_outs/cell_feature_matrix"</span>)<br>adata  = sc.read_10x_h5(<span>'data/SC3pv3_GEX_Breast_Cancer_DTC_Aggr_count_filtered_feature_bc_matrix.h5'</span>)<br><br>xenium.var_names_make_unique()<br>adata.var_names_make_unique()<br></code></pre><p>使用scanpy进行必要的预处理和降维聚类处理：</p><pre><code><span># filter</span><br>sc.pp.filter_cells(adata, min_genes=<span>3</span>)<br>sc.pp.filter_genes(adata, min_cells=<span>3</span>)<br><br>sc.pp.filter_cells(xenium, min_genes=<span>3</span>)<br>sc.pp.filter_genes(xenium, min_cells=<span>3</span>)<br><br><span># normalization</span><br>adata_raw = adata<br>sc.pp.normalize_total(adata, target_sum = <span>1e4</span>)<br>sc.pp.log1p(adata)<br>sc.pp.highly_variable_genes(adata)<br>adata = adata[:, adata.var.highly_variable]<br>sc.pp.scale(adata, max_value  =<span>10</span>)<br>sc.tl.pca(adata)<br>sc.pp.neighbors(adata)<br>sc.tl.leiden(adata, resolution = <span>0.5</span>)<br>adata_raw.obs[<span>'leiden'</span>] = adata.obs.leiden<br></code></pre><p>tangram的数据映射分为三步：</p><ol><li><p>pp_adatas</p><p>返回值是一个AnnData对象。寻找单细胞数据和空间转录组数据之间的共有基因，保存至结果对象uns中。另外，此函数有genes参数，可以接受用于训练的基因。</p></li><li><p>map_cells_to_space</p><p>返回的 AnnData，它是一个 cell-by-voxel 的结构，可以给出 cell i位于 voxel j 中的概率。voxel可以理解为是空间转录组数据中的细胞。</p></li><li><p>project_genes</p><p>project_genes可以进一步处理map_cells_to_space函数的计算结果，其结果是voxel-by-gene结构，类似于空间转录组数据，但是其基因panel和表达量是来源于单细胞数据集。</p></li></ol><p>另外，tangram支持两种模式：cell和cluster模式，cluster可以很大的节省计算时间和计算空间（内存）。他们的区别就是在map_cells_to_space和project_genes函数设置上，需要将mode和cluster_label设置好。</p><p><strong>cell模式</strong></p><pre><code>tg.pp_adatas(adata_raw, xenium, genes=<span>None</span>) <span># genes = None, using all genes</span><br>ad_map = tg.map_cells_to_space(adata_raw,xenium)<br>ad_ge = tg.project_genes(ad_map, adata_raw)<br></code></pre><p><strong>cluster模式</strong></p><pre><code>tg.pp_adatas(adata_raw, xenium, genes=<span>None</span>) <span># genes = None, using all genes</span><br>ad_map = tg.map_cells_to_space(<br>  adata_raw,<br>  xenium, <br>  device = <span>'cpu'</span>, <br>  mode   = <span>'clusters'</span>, <span># 'cell', 'clusters', 'constrained'</span><br>  cluster_label = <span>'leiden'</span>, <br>  density_prior = <span>'rna_count_based'</span> <span># 'rna_count_based' or 'uniform', can also be a ndarray</span><br>)<br>ad_ge = tg.project_genes(ad_map, adata_raw, cluster_label = <span>'leiden'</span>)<br></code></pre><p>ad_ge就是映射了单细胞转录数据的空间转录组数据。</p><h3><span>批量模式</span></h3><p>可以将各种需要的参数都设置好，并改写为python函数，以便于复用。</p><p>根据文献‘Benchmarking spatial and single-cell transcriptomics integration methods for transcript distribution prediction and cell type deconvolution’的描述，tangram适合raw-raw的模式：</p><blockquote><p>raw expression matrix of spatial data and raw expression matrix of scRNA-seq data (R-R);</p></blockquote><p>因此此函数除支持cluster模式之外，还支持是否对单细胞和空间转录组数据进行Normalize处理的选项，此外也可以自定义trainning gene。</p><p>函数run_tangram的定义如下：</p><pre><code><span>import</span> scanpy <span>as</span> sc<br><span>import</span> tangram <span>as</span> tg<br><span>import</span> pandas <span>as</span> pd<br><br><span># script to run tangram</span><br><span># according to paper of QUNKUNlab, raw-raw is recommended</span><br><span><span>def</span> <span>run_tangram</span><span>(<br>    singlecell: sc.AnnData,<br>    sp: sc.AnnData,<br>    trainning_gene=None,<br>    predicted_gene=None,<br>    do_norm: bool = False,<br>    do_log: bool = False,<br>    device: str = <span>"cpu"</span>,<br>    mode: str = <span>'clusters'</span>,<br>    cluster_label: str = <span>'leiden'</span>,<br>    resolution: int = <span>0.5</span>,<br>    density_prior: str = <span>'rna_count_based'</span><br>)</span>:</span><br>    <span>"""<br>    Function to run tangram.<br><br>    Args:<br>        do_norm: whether to do normalize, default is False<br>        do_log:  whether to do log1p, default is False<br>        trainning_gene: genes using to trainning model<br>        predicted_gene: genes to predict, if not none,  only return dataset of predicted_gene<br><br>    Returns:<br>        a pandas.DataFrame, row is cells and column is gene<br>    """</span><br><br>    singlecell = singlecell.copy()<br>    sp = sp.copy()<br><br>    <span># norm</span><br>    <span>if</span> do_norm:<br>        sc.pp.normalize_total(singlecell, target_sum=<span>1e4</span>)<br>        sc.pp.normalize_total(sp, target_sum=<span>1e4</span>)<br>    <span>if</span> do_log:<br>        sc.pp.log1p(singlecell)<br>        sc.pp.log1p(sp)<br><br>    <span># saving gene name, gene will changed to lower-case after running pp_adatas</span><br>    gene_name = singlecell.var_names<br><br>    <span># genes = None, using all genes</span><br>    tg.pp_adatas(singlecell, sp, genes=trainning_gene)<br><br>    <span>if</span> mode == <span>'clusters'</span>:<br>        sc_raw = singlecell<br>        sc.pp.normalize_total(singlecell, target_sum=<span>1e4</span>)<br>        sc.pp.log1p(singlecell)<br>        sc.pp.highly_variable_genes(singlecell)<br>        singlecell = singlecell[:, singlecell.var.highly_variable]<br>        sc.pp.scale(singlecell, max_value=<span>10</span>)<br>        sc.tl.pca(singlecell)<br>        sc.pp.neighbors(singlecell)<br>        sc.tl.leiden(singlecell, resolution=resolution)<br>        sc_raw.obs[cluster_label] = singlecell.obs.leiden<br><br>        ad_map = tg.map_cells_to_space(<br>            sc_raw,<br>            sp,<br>            device=device,<br>            mode=mode,  <span># 'cell', 'clusters', 'constrained'</span><br>            cluster_label=cluster_label,<br>            density_prior=density_prior  <span># 'rna_count_based' or 'uniform', can also be a ndarray</span><br>        )<br>        ad_ge = tg.project_genes(ad_map, sc_raw, cluster_label=cluster_label)<br>    <span>else</span>:<br>        ad_map = tg.map_cells_to_space(singlecell, sp, device=device)<br>        ad_ge = tg.project_genes(ad_map, singlecell)<br><br>    <span>assert</span> all(ad_ge.var_names.str.lower() == gene_name.str.lower())<br><br>    predicted_dat = pd.DataFrame(<br>        ad_ge.X, index=ad_ge.obs_names, columns=gene_name)<br><br><br>    <span>if</span> <span>not</span> predicted_gene <span>is</span> <span>None</span>:<br>        predicted_dat = predicted_dat.loc[:, predicted_gene]<br><br>    <span>return</span>(predicted_dat)<br></code></pre><p>使用示例：</p><pre><code><span># running analysis</span><br><span>import</span> os<br><span>import</span> random<br><span>import</span> numpy <span>as</span> np<br><span>import</span> pandas <span>as</span> pd<br><span>import</span> scanpy <span>as</span> sc<br><br><br>dir_name = <span>"geneImputation_output"</span><br><br><span>assert</span> os.path.exists(dir_name)<br><span>assert</span> os.path.exists(<span>'data'</span>)<br><br><br>xenium = sc.read_10x_mtx(<span>"data/Xenium_FFPE_Human_Cancer_Rep1_outs/cell_feature_matrix"</span>)<br>adata  = sc.read_10x_h5(<span>'data/SC3pv3_GEX_Breast_Cancer_DTC_Aggr_count_filtered_feature_bc_matrix.h5'</span>)<br><br>xenium.var_names_make_unique()<br>adata.var_names_make_unique()<br><br><br><span># filter</span><br>sc.pp.filter_cells(adata, min_genes=<span>10</span>)<br>sc.pp.filter_genes(adata, min_cells=<span>100</span>)<br><br>sc.pp.filter_cells(xenium, min_genes=<span>10</span>)  <span># cell count bigger than 250M</span><br>sc.pp.filter_genes(xenium, min_cells=<span>10</span>)  <span># only 280+ genes</span><br><br><br><span># trainning gene</span><br>all_common_genes = sorted(list(set(xenium.var_names) &amp; set(adata.var_names)))<br><span>assert</span> len(all_common_genes) &gt; <span>0</span><br><br>train_ratio = <span>2</span>/<span>3</span><br>train_genes_count = int(train_ratio * len(all_common_genes))<br><span>assert</span> train_genes_count &gt; <span>0</span><br><br>random.seed(<span>1234</span>)<br>trainning_gene = random.sample(all_common_genes, train_genes_count)<br>testing_gene = list(set(all_common_genes) - set(trainning_gene))<br><br><br><span># subset xenium</span><br><span>if</span> <span>not</span> all(xenium.var_names.isin(all_common_genes)):<br>    print(<span>f"Some genes (<span>{len(set(xenium.var_names) - set(all_common_genes))}</span>) not existed in singlecell, woule be discared!"</span>, flush=<span>True</span>)<br>    xenium = xenium[:, xenium.var_names.isin(all_common_genes)]<br><br><span># analysis</span><br><span>for</span> norm <span>in</span> [<span>'raw'</span>, <span>'norm'</span>]:<br>    <span># 是否norm</span><br>    <span>if</span> norm == <span>"raw"</span>:<br>        norm_used = <span>False</span><br>    <span>else</span>:<br>        norm_used = <span>True</span><br><br>    <span># testing_gene</span><br>    <span>if</span> <span>not</span> norm_used:<br>        testing_gene_used = <span>None</span><br>    <span>else</span>:<br>        testing_gene_used = testing_gene<br><br>    <span># run tangram</span><br>    dat_tg = run_tangram(<br>        adata,<br>        xenium, <br>        do_norm=norm_used,<br>        do_log=norm_used,<br>        mode=<span>'clusters'</span>,<br>        trainning_gene=trainning_gene, <br>        predicted_gene=testing_gene_used<br>    )<br>    <span>if</span> <span>not</span> norm_used:<br>        <span># 直接导出数据</span><br>        save_csv(dat_tg.loc[: , testing_gene] , <span>'tangram_in_'</span> + str(norm) + <span>'.csv'</span>, dir_name=dir_name)<br>   <span>else</span>:<br>        save_csv(dat_tg, <span>'tangram_in_'</span> + str(norm) + <span>'.csv'</span>, dir_name=dir_name)<br></code></pre><p>结果产出是一个只有测试基因的单细胞推断后的空间转录组矩阵数据，下游的预测和真实值的对比分析、可视化分析，个人的习惯还是在R里面进行，都是常规代码，这里就不再赘述了。</p><p><br></p><p><mp-style-type data-value="10000"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/hjFr_RWrTeXWAFtv-AGvjw",target="_blank" rel="noopener noreferrer">原文链接</a>
