---
title: "轨迹分析：在Python中使用CytoTRACE"
date: 2024-01-11T03:17:22Z
draft: ["false"]
tags: [
  "fetched",
  "TOP生物信息"
]
categories: ["Acdemic"]
---
轨迹分析：在Python中使用CytoTRACE by TOP生物信息
------
<div><section data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><h3 data-tool="mdnice编辑器"><span></span><span></span><span>1. 前言</span><span></span></h3><p data-tool="mdnice编辑器">之前我们为大家介绍过多种轨迹推断的方法：</p><pre data-tool="mdnice编辑器"><span></span><code>Slingshot: https://mp.weixin.qq.com/s/jqTrlM8C4DWURkiDpNhrIg<br>Palantir:  https://mp.weixin.qq.com/s/Gi8DfXBBkPgUdfoxpC9nHQ<br>Monocle2:  https://mp.weixin.qq.com/s/d5wiLsX4CjybmVzkYgJ_4g<br>Monocle3:  https://mp.weixin.qq.com/s/8Sb4q-moWFz7v_aMf4NiCA<br>CytoTRACE: https://mp.weixin.qq.com/s/W9et-yqqbMAPz3DjK6UJuA<br>Basic:     https://mp.weixin.qq.com/s/yok5jMW9lFwwiquPPJtfFw<br><br></code></pre><p data-tool="mdnice编辑器">除了<code>Palantir</code>外，大部分常用的算法都是基于R语言进行计算的。但是在单细胞数据快速膨胀的今天，R语言计算速度慢、效率低下等缺点越来越明显，已经远远不能胜任更多的工作了。Python以其在机器学习和深度学习等方面的优势，正在快速占领单细胞算法领域的高地，至少已经达到与R语言分庭抗礼的地位了。尽管Python并不是一门高效的计算语言，但是他的计算速度、内存管理等已经全方面碾压R了。说了这么多，就是提出这个观点：如果你需要深入学习单细胞，那就<strong>不得不学Python了</strong>！</p><p data-tool="mdnice编辑器">回到我们今天的主题“轨迹分析”。事实上在Python中已经诞生了许多轨迹推断的方法，除了上述的<code>Palantir</code>外，还包括<code>VIA</code>、<code>scvelo</code>等等。而今天要讲的<code>CytoTRACE</code>实际上就是一个Python包，只不过他被封装成了一个R包而被推广。</p><p data-tool="mdnice编辑器"><code>CytoTRACE</code>的使用方式被整合进了<code>cellrank</code>这个Python包，这个包集合了多种Python轨迹分析的方法。官方教程如下：</p><pre data-tool="mdnice编辑器"><span></span><code>https://cellrank.readthedocs.io/en/latest/index.html<br></code></pre><h3 data-tool="mdnice编辑器"><span></span><span></span><span>2. 环境配置</span><span></span></h3><pre data-tool="mdnice编辑器"><span></span><code><span># 创建新环境</span><br>mamba create -n scrna python=<span>3.8</span> -y<br>conda create scrna<br><br><span># 安装需要的包(这里是本次所用的版本)</span><br>pip install scanpy==<span>1.9</span><span>.6</span> <br>pip install cellrank==<span>2.0</span><span>.2</span><br>pip install numba==<span>0.58</span><span>.1</span><br>pip install numpy==<span>1.23</span><span>.5</span><br>pip install scipy==<span>1.10</span><span>.1</span><br>pip install pandas==<span>1.5</span><span>.3</span><br>pip install scvelo==<span>0.3</span><span>.1</span><br><br><span># 安装kernel</span><br>pip install ipykernel<br><span># 配置jupyterlab内核</span><br>python -m ipykernel install --user --name=scrna --display-name scrna<br><span># 查看当前配置的juypter内核</span><br>jupyter kernelspec list<br></code></pre><h3 data-tool="mdnice编辑器"><span></span><span></span><span>3. 载入包和数据</span><span></span></h3><pre data-tool="mdnice编辑器"><span></span><code><span>import</span> scanpy <span>as</span> sc<br><span>import</span> omicverse <span>as</span> ov<br><span>import</span> matplotlib.pyplot <span>as</span> plt<br><span>import</span> scvelo <span>as</span> scv<br><span>import</span> cellrank <span>as</span> cr<br><br>ov.ov_plot_set()<br></code></pre><p data-tool="mdnice编辑器">我们使用官方给的数据，这是一个包含斑马鱼发育不同阶段的单细胞数据，原始矩阵一共包含2434个细胞和23974个基因。</p><pre data-tool="mdnice编辑器"><span></span><code>adata = cr.datasets.zebrafish()<br>adata<br><span># AnnData object with n_obs × n_vars = 2434 × 23974</span><br><span>#     obs: 'Stage', 'gt_terminal_states', 'lineages'</span><br><span>#     uns: 'Stage_colors', 'gt_terminal_states_colors', 'lineages_colors'</span><br><span>#     obsm: 'X_force_directed'</span><br><br><span># 通常来说国内网络下载不太好，你可以通过提示的网址下载后再读入：</span><br><span># https://figshare.com/ndownloader/files/27265280</span><br><br></code></pre><p data-tool="mdnice编辑器">先观察一下数据。该斑马鱼数据集包含 12 个时间点，时间跨度为受精后 3.3 - 12 小时。我们可以使用数据提供的力导向图（Force directed graph）来绘制细胞图，并按发育阶段着色：</p><pre data-tool="mdnice编辑器"><span></span><code>adata.obs.head()<br><span>#                                 Stage  gt_terminal_states           lineages</span><br><span># ZFHIGH_WT_DS5_AAAAGTTGCCTC  03.3-HIGH                 NaN  Early Blastomeres</span><br><span># ZFHIGH_WT_DS5_AAACAAGTGTAT  03.3-HIGH                 NaN  Early Blastomeres</span><br><span># ZFHIGH_WT_DS5_AAACACCTCGTC  03.3-HIGH                 NaN  Early Blastomeres</span><br><span># ZFHIGH_WT_DS5_AACCCTCTCGAT  03.3-HIGH                 NaN  Early Blastomeres</span><br><span># ZFHIGH_WT_DS5_AACGAAAGGTAA  03.3-HIGH                 NaN  Early Blastomeres</span><br><br><br>ov.utils.embedding(adata, basis = <span>'force_directed'</span>, <br>                   color=<span>"Stage"</span>, frameon=<span>False</span>)<br><br></code></pre><figure data-tool="mdnice编辑器"><img data-imgfileid="100007443" data-ratio="0.7139272271016311" data-src="https://mmbiz.qpic.cn/mmbiz_png/WThoCmvVu2bdPvmA8GEK1unbcibgWFfs5MtDD0IRsRkqY0ab7ClADEnHoJuvDiakzqxpib22ehB4X0gWxZYOUPfUg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="797" src="https://mmbiz.qpic.cn/mmbiz_png/WThoCmvVu2bdPvmA8GEK1unbcibgWFfs5MtDD0IRsRkqY0ab7ClADEnHoJuvDiakzqxpib22ehB4X0gWxZYOUPfUg/640?wx_fmt=png&amp;from=appmsg"></figure><pre data-tool="mdnice编辑器"><span></span><code>ov.utils.embedding(adata, basis = <span>'force_directed'</span>, color=<span>"lineages"</span>, frameon=<span>False</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-imgfileid="100007441" data-ratio="0.64947245017585" data-src="https://mmbiz.qpic.cn/mmbiz_png/WThoCmvVu2bdPvmA8GEK1unbcibgWFfs5eM35WxuQ8CsbsLoBHtLaYnhO1Hg2DCaU98oJRgEHUBypTEPX7sqgKw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="853" src="https://mmbiz.qpic.cn/mmbiz_png/WThoCmvVu2bdPvmA8GEK1unbcibgWFfs5eM35WxuQ8CsbsLoBHtLaYnhO1Hg2DCaU98oJRgEHUBypTEPX7sqgKw/640?wx_fmt=png&amp;from=appmsg"></figure><h3 data-tool="mdnice编辑器"><span></span><span></span><span>4. 数据预处理</span><span></span></h3><p data-tool="mdnice编辑器">在开始分析前，我们需要对数据进行常规的预处理。</p><pre data-tool="mdnice编辑器"><span></span><code><span># filter, normalize total counts and log-transform</span><br>sc.pp.filter_genes(adata, min_cells=<span>10</span>)<br>scv.pp.normalize_per_cell(adata)<br>sc.pp.log1p(adata)<br><br><span># hvg annotation</span><br>sc.pp.highly_variable_genes(adata)<br>print(<span>f"This detected <span>{adata.var[<span>'highly_variable'</span>].sum()}</span> highly variable genes. "</span>)<br><br><span># filtered out 10284 genes that are detected in less than 10 cells</span><br><span># Normalized count data: X.</span><br><span># extracting highly variable genes</span><br><span>#     finished (0:00:00)</span><br><span># --&gt; added</span><br><span>#     'highly_variable', boolean vector (adata.var)</span><br><span>#     'means', float vector (adata.var)</span><br><span>#     'dispersions', float vector (adata.var)</span><br><span>#     'dispersions_norm', float vector (adata.var)</span><br><span># This detected 2392 highly variable genes. </span><br></code></pre><p data-tool="mdnice编辑器">在进行<code>CytoTRACE</code>分析之前，还需要做重要的一步：<strong>imputation</strong>。由于技术原因，单细胞存在大量的drop-out（零值），势必会导致原本应该表达的RNA没有被捕获到。研究者们提供了几种思路去解决这样的困局，最常见的就是pesudobulk（假bulk转录组）、imputation（插补）和metacell（元细胞）。在<code>cellrank</code>官方使用了<code>scvelo</code>提供的imputaion方法，实际上在palantir中也提供了类似的方案。实测下来<code>scvelo</code>会快很多，但是如果你跟我一样使用<code>omicverse</code>的话，他们俩会冲突。不过，如果你单纯只是使用imputaion的话是不会报错的。</p><pre data-tool="mdnice编辑器"><span></span><code>adata.layers[<span>"spliced"</span>] = adata.X<br>adata.layers[<span>"unspliced"</span>] = adata.X<br>scv.pp.moments(adata, n_pcs=<span>30</span>, n_neighbors=<span>30</span>)<br><span># computing PCA</span><br><span>#     on highly variable genes</span><br><span>#     with n_comps=30</span><br><span>#     finished (0:00:00)</span><br><span># computing neighbors</span><br><span>#     finished (0:00:09) --&gt; added </span><br><span>#     'distances' and 'connectivities', weighted adjacency matrices (adata.obsp)</span><br><span># computing moments based on connectivities</span><br><span>#     finished (0:00:01) --&gt; added </span><br><span>#     'Ms' and 'Mu', moments of un/spliced abundances (adata.layers)</span><br><br></code></pre><p data-tool="mdnice编辑器"><code>scvelo</code>基于<code>spliced</code>和<code>unspliced</code>矩阵进行矫正，如果你没有，且不要担心。按照官方给的建议，直接把<code>adata.X</code>存到<code>layers</code>中就可以。大概只需要几秒钟就完成了。</p><p data-tool="mdnice编辑器">这时候<code>adata.layers</code>中就会多了两个矩阵，如果你的数据很大，我建议你把<code>Ms</code>或<code>Mu</code>矩阵保留1个就可以了，其他删掉，因为会占据大量内存空间：</p><pre data-tool="mdnice编辑器"><span></span><code><span>del</span> adata.layers[<span>'spliced'</span>]<br><span>del</span> adata.layers[<span>'unspliced'</span>]<br><span>del</span> adata.layers[<span>'Mu'</span>]<br>adata<br><span># AnnData object with n_obs × n_vars = 2434 × 13690</span><br><span>#     obs: 'Stage', 'gt_terminal_states', 'lineages', 'n_counts'</span><br><span>#     var: 'n_cells', 'gene_count_corr', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'</span><br><span>#     uns: 'Stage_colors', 'gt_terminal_states_colors', 'lineages_colors', 'log1p', 'hvg', 'pca', 'neighbors'</span><br><span>#     obsm: 'X_force_directed', 'X_pca'</span><br><span>#     varm: 'PCs'</span><br><span>#     layers: 'Ms'</span><br><span>#     obsp: 'distances', 'connectivities'</span><br></code></pre><h3 data-tool="mdnice编辑器"><span></span><span></span><span>5. CytoTRACE分析</span><span></span></h3><p data-tool="mdnice编辑器">我们使用cellrank提供的CytoTRACEKernel进行计算，他的主要结果存在<code>adata.obs</code>的<code>'ct_score','ct_pseudotime'</code>中。<code>ct_score</code>大约就相当于Palantir的<code>entropy</code>。也可以理解为<code>CytoTRACE</code>推断的细胞干性或分化潜能。</p><p data-tool="mdnice编辑器">计算非常快，大约只花了2秒。</p><pre data-tool="mdnice编辑器"><span></span><code><span># 细胞干性推断</span><br><span>from</span> cellrank.kernels <span>import</span> CytoTRACEKernel<br>ctk = CytoTRACEKernel(adata).compute_cytotrace()<br><span># 可视化</span><br>sc.pl.embedding(<br>    adata,<br>    color=[<span>"ct_pseudotime"</span>, <span>"Stage"</span>],<br>    basis=<span>"force_directed"</span>,<br>    color_map=<span>"gnuplot2"</span>,<br>)<br><br></code></pre><figure data-tool="mdnice编辑器"><img data-imgfileid="100007444" data-ratio="0.39814814814814814" data-src="https://mmbiz.qpic.cn/mmbiz_png/WThoCmvVu2bdPvmA8GEK1unbcibgWFfs58CRxtSHsF8zTfAv3ny8ufsF2uPeictic6Eu2pGBEefWJUTa1j8TIicbXg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/WThoCmvVu2bdPvmA8GEK1unbcibgWFfs58CRxtSHsF8zTfAv3ny8ufsF2uPeictic6Eu2pGBEefWJUTa1j8TIicbXg/640?wx_fmt=png&amp;from=appmsg"></figure><p data-tool="mdnice编辑器">需要补充的是，跟Palantir等方法不一样，CytoTRACE是不指定起点或终点的。这会带来两个重要的问题：（1）对于希望研究某一段特定的轨迹来说，并不友好，所以酌情选择合适的工具；（2）有可能会变成轨迹相反的结果。</p><p data-tool="mdnice编辑器">轨迹相反（即<code>ct_pesudotime</code>和<code>ct_score</code>与实际情况相反）。这时候可以使用<code> 1- pseudotime</code>来实现矫正。例如：</p><pre data-tool="mdnice编辑器"><span></span><code>adata.obs[<span>"ct_pesudotime_corrected"</span>] = <span>1</span> - adata.obs[<span>"ct_pesudotime"</span>]<br>adata.obs[<span>"ct_score_corrected"</span>] = <span>1</span> - adata.obs[<span>"ct_score"</span>]<br><br></code></pre><p data-tool="mdnice编辑器">我们还可以可视化各个细胞状态的假时间：</p><pre data-tool="mdnice编辑器"><span></span><code>sc.pl.violin(adata, keys=[<span>"ct_pseudotime"</span>], groupby=<span>"Stage"</span>, rotation=<span>90</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-imgfileid="100007442" data-ratio="1.288888888888889" data-src="https://mmbiz.qpic.cn/mmbiz_png/WThoCmvVu2bdPvmA8GEK1unbcibgWFfs5aFOEjWeUTa3rIhmicLL0ItWHQ9iaN9ZtsXcict5IFNUSicUbMe6BCMDuCw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="585" src="https://mmbiz.qpic.cn/mmbiz_png/WThoCmvVu2bdPvmA8GEK1unbcibgWFfs5aFOEjWeUTa3rIhmicLL0ItWHQ9iaN9ZtsXcict5IFNUSicUbMe6BCMDuCw/640?wx_fmt=png&amp;from=appmsg"></figure><p data-tool="mdnice编辑器">实际上有了pseudotime和ct_score我们就可以增加一个维度进行更加深入的分析。比如推断起始和终点的细胞状态、评估细胞命运和驱动基因、可视化重要基因的表达量变化趋势等等。下次我们再找机会慢慢讲这些内容。</p><p data-tool="mdnice编辑器">这篇笔记也是最近做项目的时候遇到cellrank这个好用的工具，作为R出身的生信工作者，我对Python本身并不算熟悉，这些优秀的封装工具如cellrank、omicverse无疑会给我们这类研究者带来福音。希望以此篇抛砖引玉，大家对深入研究trajectory analysis有兴趣可以自行探索cellrank的下一步工具，我们未来也会写这些笔记与大家共同学习。</p><pre data-tool="mdnice编辑器"><span></span><code><span># cellrank-CytoTRACE 官方文档</span><br>https://cellrank.readthedocs.io/en/latest/notebooks/tutorials/kernels/<span>400</span>_cytotrace.html<br></code></pre></section><p><br></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/MCRHw644tF9HuXIzw83uxQ",target="_blank" rel="noopener noreferrer">原文链接</a>
