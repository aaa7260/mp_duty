---
title: "2024年了，高阶生存分析我强烈推荐你使用mlr3！遥遥领先！"
date: 2024-01-31T03:09:31Z
draft: ["false"]
tags: [
  "fetched",
  "医学和生信笔记"
]
categories: ["Acdemic"]
---
2024年了，高阶生存分析我强烈推荐你使用mlr3！遥遥领先！ by 医学和生信笔记
------
<div><section><span>关注公众号，发送</span><strong>R语言</strong><span>或</span><strong>python</strong><span>，可获取资料</span><span></span></section><section><mp-common-profile data-pluginname="mpprofile" data-id="MzUzOTQzNzU0NA==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/tpAC6lR84R9YDc8IDhqWAHTrZsMuhDpFlw4scqOl1ZVWpeY77cdibaSzPeGALfkEhdVpwHzVibHCRSYZg4csB43g/0?wx_fmt=png" data-nickname="医学和生信笔记" data-alias="yxhsxbj" data-signature="外科医生👨‍⚕️的R语言和生信学习🔖" data-from="2" data-weuitheme="light"></mp-common-profile></section><section data-role="outer" label="edit by 135editor"><section data-role="paragraph"><section data-role="outer" label="edit by 135editor"><section data-role="paragraph"><section data-role="outer" label="edit by 135editor"><section data-role="paragraph"><section data-role="outer"><section data-role="outer" label="edit by 135editor"><section data-tools="135编辑器" data-id="28"><p data-brushtype="text" hm_fix="440:185"><span>💡专注R语言在🩺生物医学中的使用</span></p></section></section></section></section></section><hr><section data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><p data-tool="mdnice编辑器"><span><span>设为“</span><strong><span>星标</span></strong><span>”，精彩不错过</span></span><br></p><hr><p data-tool="mdnice编辑器"><span><strong></strong></span></p><section data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><p data-tool="mdnice编辑器">2024年，如果你要做高阶生存分析，也就是各种机器学习算法相关的生存分析，我强烈推荐你学习<code>mlr3</code>。</p><p data-tool="mdnice编辑器">如果是1年前我是强烈不推荐的，因为那时的<code>mlr3</code>发展的还不够成熟，很多语法一直在修改，可能你的代码今天能用，明天就不能用了，而且小bug不断。</p><p data-tool="mdnice编辑器">但是它的发展非常快速，大家可以去看看我在2022年发的十几篇<code>mlr3</code>的古早教程，都是看着mlr3book写的，当时连各种语法糖都没有，还是完全的R6语法，每个函数都巨长而且不好理解。再看看现在的<code>mlr3</code>，真的是天差地别。它们的官方教程<code>mlr3book</code>我每隔几个月都会去看一看，每次都会发现有更新。从2020年到现在一直在快速更新中！</p><p data-tool="mdnice编辑器"><code>mlr3</code>发展到现在（现在是20240102）我个人认为基本很成熟了，应该不会再有大的改动了，各种方法的语法基本都非常完善了，不会再出现“今天的代码明天不能用”的情况。而且<strong>对各种生存分析的支持目前在R语言中没有对手！遥遥领先！</strong></p><p data-tool="mdnice编辑器">本来我是很看好<code>tidymodels</code>的，毕竟珠玉在前（经典R包<code>caret</code>），而且还有Rstudio这颗“大树”，但是目前看来它的发展已经远远落后于<code>mlr3</code>，落后太远了！</p><p data-tool="mdnice编辑器">所以，如果你要学习各种机器学习相关的生存分析，别再费劲去学各种单独的R包了，直接学习<code>mlr3</code>吧。（但是一些基础的知识还是要了解一下的，有些东西无法替代，最好是先学习单独的R包，再学习mlr3，这样有些细节你可以心中有数，出了问题方便溯源）</p><p data-tool="mdnice编辑器">下面我们详细介绍下如何在<code>mlr3</code>中实现生存分析。</p><h2 data-tool="mdnice编辑器"><span></span><span>安装和加载R包</span><span></span></h2><p data-tool="mdnice编辑器">在<code>mlr3</code>中实现生存分析需要额外安装<code>mlr3proba</code>和<code>mlr3extralearners</code>。由于一些原因这两个R包永远不会出现在CRAN中，所以安装方法略有不同，官方提供了多种安装方法，如下：</p><pre data-tool="mdnice编辑器"><code><span># 安装mlr3extralearners</span><br>remotes::install_github(<span>"mlr-org/mlr3extralearners"</span>)<br><br><span># 安装mlr3proba</span><br>options(repos=c(<br>  mlrorg = <span>'https://mlr-org.r-universe.dev'</span>,<br>  raphaels1 = <span>'https://raphaels1.r-universe.dev'</span>,<br>  CRAN = <span>'https://cloud.r-project.org'</span><br>))<br>install.packages(<span>"mlr3proba"</span>)<br><br><span># or </span><br>install.packages(<span>"mlr3proba"</span>, repos = <span>"https://mlr-org.r-universe.dev"</span>)<br></code></pre><p data-tool="mdnice编辑器">然后是加载R包：</p><pre data-tool="mdnice编辑器"><code><span>library</span>(mlr3verse)<br><span>library</span>(mlr3proba)<br><span>library</span>(survival)<br><span>library</span>(mlr3extralearners)<br><span>library</span>(dplyr)<br></code></pre><h2 data-tool="mdnice编辑器"><span></span><span>建立任务</span><span></span></h2><p data-tool="mdnice编辑器">在<code>mlr3</code>中实现生存分析和做回归分类任务一样，首先是建立任务（其实你也可以先进行一些预处理再建立任务），方法是一模一样的，只不过这里是<code>as_task_surv</code>而已：</p><pre data-tool="mdnice编辑器"><code>tsk_rats &lt;- as_task_surv(survival::rats, time = <span>"time"</span>, event = <span>"status"</span>, <br>                         type = <span>"right"</span>, id = <span>"rats"</span>)<br><br>tsk_rats<br><span>## &lt;TaskSurv:rats&gt; (300 x 5)</span><br><span>## * Target: time, status</span><br><span>## * Properties: -</span><br><span>## * Features (3):</span><br><span>##   - int (1): litter</span><br><span>##   - dbl (1): rx</span><br><span>##   - chr (1): sex</span><br>tsk_rats$head()<br><span>##    time status litter rx sex</span><br><span>## 1:  101      0      1  1   f</span><br><span>## 2:   49      1      1  0   f</span><br><span>## 3:  104      0      1  0   f</span><br><span>## 4:   91      0      2  1   m</span><br><span>## 5:  104      0      2  0   m</span><br><span>## 6:  102      0      2  0   m</span><br></code></pre><p data-tool="mdnice编辑器">注意这个task的Features中有个<code>chr</code>，这里是不支持的字符型的，你可以先变成因子型再建立任务。</p><p data-tool="mdnice编辑器">对于这个任务我们可以进行一些简单的可视化，比如生存曲线：</p><pre data-tool="mdnice编辑器"><code>autoplot(tsk_rats, type=<span>"target"</span>)<br></code></pre><figure data-tool="mdnice编辑器"><p><img data-galleryid="" data-imgfileid="100017241" data-ratio="0.7142857142857143" data-s="300,640" data-type="png" data-w="672" data-src="https://mmbiz.qpic.cn/mmbiz_png/tpAC6lR84RibiceEnMmmYiaMxrhvZBOx2bJ52Wk16Msda3WbibdISibXOMScbyHBiapO8LnZqgjadrAiamh90FG1kNsvg/640?wx_fmt=png&amp;from=appmsg" src="https://mmbiz.qpic.cn/mmbiz_png/tpAC6lR84RibiceEnMmmYiaMxrhvZBOx2bJ52Wk16Msda3WbibdISibXOMScbyHBiapO8LnZqgjadrAiamh90FG1kNsvg/640?wx_fmt=png&amp;from=appmsg"></p></figure><p data-tool="mdnice编辑器">分组也是可以的：</p><pre data-tool="mdnice编辑器"><code>autoplot(tsk_rats, rhs = <span>"sex"</span>)<br></code></pre><figure data-tool="mdnice编辑器"><p><img data-galleryid="" data-imgfileid="100017242" data-ratio="0.7142857142857143" data-s="300,640" data-type="png" data-w="672" data-src="https://mmbiz.qpic.cn/mmbiz_png/tpAC6lR84RibiceEnMmmYiaMxrhvZBOx2bJEmy8lia54Db2AEcbH40as5GZib2AFJbl2wIMEYyMfhyDah99W9rTuyPA/640?wx_fmt=png&amp;from=appmsg" src="https://mmbiz.qpic.cn/mmbiz_png/tpAC6lR84RibiceEnMmmYiaMxrhvZBOx2bJEmy8lia54Db2AEcbH40as5GZib2AFJbl2wIMEYyMfhyDah99W9rTuyPA/640?wx_fmt=png&amp;from=appmsg"></p></figure><p data-tool="mdnice编辑器">还可以更换画图类型等，更加详细的内容这里就不多说了，和分类/回归都是一样的用法，感兴趣的可参考之前的推文。</p><pre data-tool="mdnice编辑器"><code>autoplot(tsk_rats, type=<span>"duo"</span>)<br></code></pre><figure data-tool="mdnice编辑器"><p><img data-galleryid="" data-imgfileid="100017243" data-ratio="0.7142857142857143" data-s="300,640" data-type="png" data-w="672" data-src="https://mmbiz.qpic.cn/mmbiz_png/tpAC6lR84RibiceEnMmmYiaMxrhvZBOx2bJKiaicSLGqCZ0s6cFwicztFJI6DeJicpaPDZekbJyFGQaIMlBWXMjR8ZuqQ/640?wx_fmt=png&amp;from=appmsg" src="https://mmbiz.qpic.cn/mmbiz_png/tpAC6lR84RibiceEnMmmYiaMxrhvZBOx2bJKiaicSLGqCZ0s6cFwicztFJI6DeJicpaPDZekbJyFGQaIMlBWXMjR8ZuqQ/640?wx_fmt=png&amp;from=appmsg"></p></figure><h2 data-tool="mdnice编辑器"><span></span><span>支持的模型</span><span></span></h2><p data-tool="mdnice编辑器">建立好任务之后就是选择模型，目前<code>mlr3</code>支持的机器学习生存模型非常多、非常全，遥遥领先！</p><p data-tool="mdnice编辑器">先给大家展示下目前<code>mlr3</code>支持的生存分析模型，注意一定要先加载<code>mlr3proba</code>和<code>mlr3extralearners</code>：</p><pre data-tool="mdnice编辑器"><code><span># 目前（2024.1.2）已经支持33种生存分析模型</span><br><span># as.data.table(mlr_learners)[grepl("surv",mlr_learners$keys())][,c("key","label","predict_types")]</span><br><br>as.data.table(mlr_learners) %&gt;% <br>  filter(grepl(<span>"surv"</span>,mlr_learners$keys())) %&gt;% <br>  select(key,label,predict_types)<br><span>##                     key                                label  predict_types</span><br><span>##  1:        surv.akritas                    Akritas Estimator    crank,distr</span><br><span>##  2:          surv.aorsf                Oblique Random Forest    crank,distr</span><br><span>##  3:           surv.bart   Bayesian Additive Regression Trees    crank,distr</span><br><span>##  4:     surv.blackboost                    Gradient Boosting crank,distr,lp</span><br><span>##  5:        surv.cforest            Conditional Random Forest    crank,distr</span><br><span>##  6:       surv.coxboost            Likelihood-based Boosting crank,distr,lp</span><br><span>##  7:          surv.coxph             Cox Proportional Hazards crank,distr,lp</span><br><span>##  8:        surv.coxtime                   Cox-Time Estimator    crank,distr</span><br><span>##  9:          surv.ctree           Conditional Inference Tree    crank,distr</span><br><span>## 10:    surv.cv_coxboost            Likelihood-based Boosting crank,distr,lp</span><br><span>## 11:      surv.cv_glmnet Regularized Generalized Linear Model crank,distr,lp</span><br><span>## 12:        surv.deephit                       Neural Network    crank,distr</span><br><span>## 13:       surv.deepsurv                       Neural Network    crank,distr</span><br><span>## 14:        surv.dnnsurv                       Neural Network    crank,distr</span><br><span>## 15:       surv.flexible          Flexible Parametric Splines crank,distr,lp</span><br><span>## 16:       surv.gamboost   Boosted Generalized Additive Model crank,distr,lp</span><br><span>## 17:            surv.gbm                    Gradient Boosting       crank,lp</span><br><span>## 18:       surv.glmboost     Boosted Generalized Linear Model crank,distr,lp</span><br><span>## 19:         surv.glmnet Regularized Generalized Linear Model crank,distr,lp</span><br><span>## 20:         surv.kaplan               Kaplan-Meier Estimator    crank,distr</span><br><span>## 21:         surv.loghaz              Logistic-Hazard Learner    crank,distr</span><br><span>## 22:         surv.mboost   Boosted Generalized Additive Model crank,distr,lp</span><br><span>## 23:         surv.nelson               Nelson-Aalen Estimator    crank,distr</span><br><span>## 24:     surv.obliqueRSF                Oblique Random Forest    crank,distr</span><br><span>## 25:     surv.parametric             Fully Parametric Learner crank,distr,lp</span><br><span>## 26:       surv.pchazard                    PC-Hazard Learner    crank,distr</span><br><span>## 27:      surv.penalized                 Penalized Regression    crank,distr</span><br><span>## 28: surv.priority_lasso                       Priority Lasso    lp,response</span><br><span>## 29:         surv.ranger                        Random Forest    crank,distr</span><br><span>## 30:          surv.rfsrc                        Random Forest    crank,distr</span><br><span>## 31:          surv.rpart                        Survival Tree          crank</span><br><span>## 32:            surv.svm               Support Vector Machine crank,response</span><br><span>## 33:        surv.xgboost                    Gradient Boosting       crank,lp</span><br><span>##                     key                                label  predict_types</span><br></code></pre><p data-tool="mdnice编辑器">这个数量肯定会越来越多，但是目前来说肯定是够用了，常见的它都有，你没听说过的它也有！比如xgboost/随机生存森林/生存支持向量机（这个包本身有些小问题）/coxboost等。</p><p data-tool="mdnice编辑器">比如选择一个<code>xgboost</code>模型并查看它的帮助文档：</p><pre data-tool="mdnice编辑器"><code>lrn_surv &lt;- lrn(<span>"surv.xgboost"</span>)<br>lrn_surv$help()<br></code></pre><p data-tool="mdnice编辑器">这种查看帮助文档的方式是R6语法，大家一定要记住！</p><h2 data-tool="mdnice编辑器"><span></span><span>预测结果类型</span><span></span></h2><p data-tool="mdnice编辑器">这部分内容是<code>mlr3</code>中做生存分析的核心内容（官网也是近期才更新这么详细的解释…），非常重要。</p><p data-tool="mdnice编辑器"><code>mlr3</code>中的生存分析的预测结果可以有4种类型，分别是：</p><ul data-tool="mdnice编辑器"><li><section><code>response</code>: 预测的生存时间</section></li><li><section><code>distr</code>: 预测的生存概率分布，连续型或者离散型</section></li><li><section><code>lp</code>: 线性预测值</section></li><li><section><code>crank</code>: 连续型的风险分数</section></li></ul><p data-tool="mdnice编辑器"><code>mlr3</code>中的生存分析模型会直接返回所有模型支持的类型，比如，如果一个模型支持以上4种类型，那么结果会直接返回4种类型的预测结果，如果一个模型支持lp、crank、distr这3种类型，<code>mlr3</code>也会直接返回这3种类型，不会给你藏着掖着！</p><p data-tool="mdnice编辑器">比如cox模型，它支持3种类型（不支持生存时间），那么<code>mlr3</code>会直接返回3种：</p><pre data-tool="mdnice编辑器"><code><span># 这里用了自带的数据，和上面的任务有点不一样哦</span><br>tsk_rats &lt;- tsk(<span>"rats"</span>)<br><span>#tsk_rats</span><br>split &lt;- partition(tsk_rats)<br>prediction_cph &lt;- lrn(<span>"surv.coxph"</span>)$train(tsk_rats, split$train)$<br>  predict(tsk_rats, split$test)<br>head(as.data.table(prediction_cph))<br><span>##    row_ids time status      crank         lp     distr</span><br><span>## 1:       4   91  FALSE -2.5812496 -2.5812496 &lt;list[1]&gt;</span><br><span>## 2:       7  104  FALSE  0.6233550  0.6233550 &lt;list[1]&gt;</span><br><span>## 3:      13  104  FALSE  0.6336594  0.6336594 &lt;list[1]&gt;</span><br><span>## 4:      16   98  FALSE -2.5606407 -2.5606407 &lt;list[1]&gt;</span><br><span>## 5:      18   77  FALSE -3.4256114 -3.4256114 &lt;list[1]&gt;</span><br><span>## 6:      22   91  FALSE -2.5503363 -2.5503363 &lt;list[1]&gt;</span><br></code></pre><p data-tool="mdnice编辑器">可以看到结果中直接给出了<code>crank</code>、<code>lp</code>、<code>distr</code>这3种类型。</p><p data-tool="mdnice编辑器">下面详细介绍下这4种类型的预测结果。</p><ul data-tool="mdnice编辑器"><li><section><code>response</code></section></li></ul><p data-tool="mdnice编辑器">生存时间（response）在生存分析的预测结果中是最少见的，可能是因为删失的存在，导致很多观测的生存时间不可用。</p><p data-tool="mdnice编辑器">生存支持向量机是可以预测生存时间的，关于它的详情可参考付费合集；<a href="https://mp.weixin.qq.com/s?__biz=MzUzOTQzNzU0NA==&amp;mid=2247500886&amp;idx=1&amp;sn=9083d18666a376a68e5d6b2c67393163&amp;scene=21#wechat_redirect" data-linktype="2">生存支持向量机</a>，细节内容就不多说了，直接上代码：</p><pre data-tool="mdnice编辑器"><code>set.seed(<span>12358</span>)<br>prediction_svm &lt;- lrn(<span>"surv.svm"</span>, type = <span>"regression"</span>, gamma.mu = <span>1e-3</span>)$<br>  train(tsk_rats, split$train)$predict(tsk_rats, split$test)<br><br>data.frame(pred = prediction_svm$response[<span>1</span>:<span>3</span>],<br>  truth = prediction_svm$truth[<span>1</span>:<span>3</span>])<br><span>##       pred truth</span><br><span>## 1 91.13665   91+</span><br><span>## 2 90.92749  104+</span><br><span>## 3 90.51497  104+</span><br></code></pre><p data-tool="mdnice编辑器">结果中<code>pred</code>是预测的生存时间，<code>truth</code>是真实的生存时间，可以看到预测的时间基本上是小于真实时间的（你的结果可能和我不一样）。但是每个真实时间都是删失的，所以也不好判定这个预测结果的好坏。因此预测生存时间基本上很少用，因为无法判断结果的好坏。</p><ul data-tool="mdnice编辑器"><li><section><code>distr</code></section></li></ul><p data-tool="mdnice编辑器">与回归分析中常见的点预测（或者叫确定性预测）不同，生存分析更常见的是分布预测。<code>mlr3proba</code>中的大多数模型都会默认进行分布预测，这种预测时通过<code>distr</code>包实现的，并支持生存曲线的可视化。</p><p data-tool="mdnice编辑器">下面我们提取cox模型的前3个分布预测结果（时间t=77）:</p><pre data-tool="mdnice编辑器"><code>prediction_cph$distr[<span>1</span>:<span>3</span>]$survival(<span>77</span>)<br><span>##         [,1]     [,2]      [,3]</span><br><span>## 77 0.9947029 0.877308 0.8761194</span><br></code></pre><p data-tool="mdnice编辑器">结果表明前3个样本分别有92.89632%，99.48477%，99.48477%的概率在时间为77时存活。</p><ul data-tool="mdnice编辑器"><li><section><code>lp</code></section></li></ul><p data-tool="mdnice编辑器">线性预测值在普通线性回归中是非常好理解的，就是其中的线性部分，但是在各种高阶生存分析中，模型方程基本都不是线性的，所以计算起来也没有那么简单。所以<code>mlr3proba</code>中的线性预测值其实是风险分数（风险排名，下面要讲的crank）的近似值。</p><p data-tool="mdnice编辑器"><code>crank</code></p><p data-tool="mdnice编辑器"><code>crank</code>(ContinuousRANKing)是生存分析中非常常见的预测类型，这个通常也是生存分析中预测的风险分数。不同的模型对于这个风险分数的定义是不同的，有的时候crank越大发生终点事件的可能性越大，有的则刚好相反。为了避免混淆，<code>mlr3proba</code>对这个crank进行了统一，<code>mlr3proba</code>中的crank统一都是连续型的，而且<strong>这个值越大，发生终点事件的可能性越大（值越大风险越高）</strong>。</p><pre data-tool="mdnice编辑器"><code>prediction_cph$crank[<span>1</span>:<span>3</span>]<br><span>##          1          2          3 </span><br><span>## -2.5812496  0.6233550  0.6336594</span><br></code></pre><p data-tool="mdnice编辑器">这个结果说明第2个样本的风险最小（去掉负号比较）</p><p data-tool="mdnice编辑器">这个结果只能说明谁的风险大谁的风险小，但是这些数字其实是没有任何实际意义的，所以比较不同样本的crank也是没有任何意义的。</p><h2 data-tool="mdnice编辑器"><span></span><span>评价指标</span><span></span></h2><p data-tool="mdnice编辑器">目前对于生存分析，<code>mlr3</code>支持以下评价指标：</p><pre data-tool="mdnice编辑器"><code><span># 目前支持24种评价指标</span><br>as.data.table(mlr_measures)[grepl(<span>"surv"</span>,mlr_measures$keys())][,c(<span>1</span>,<span>5</span>)]<br><span>##                    key predict_type</span><br><span>##  1:         surv.brier        distr</span><br><span>##  2:   surv.calib_alpha        distr</span><br><span>##  3:    surv.calib_beta           lp</span><br><span>##  4: surv.chambless_auc           lp</span><br><span>##  5:        surv.cindex        crank</span><br><span>##  6:        surv.dcalib        distr</span><br><span>##  7:          surv.graf        distr</span><br><span>##  8:      surv.hung_auc           lp</span><br><span>##  9:    surv.intlogloss        distr</span><br><span>## 10:       surv.logloss        distr</span><br><span>## 11:           surv.mae     response</span><br><span>## 12:           surv.mse     response</span><br><span>## 13:     surv.nagelk_r2           lp</span><br><span>## 14:   surv.oquigley_r2           lp</span><br><span>## 15:          surv.rcll        distr</span><br><span>## 16:          surv.rmse     response</span><br><span>## 17:        surv.schmid        distr</span><br><span>## 18:      surv.song_auc           lp</span><br><span>## 19:      surv.song_tnr           lp</span><br><span>## 20:      surv.song_tpr           lp</span><br><span>## 21:       surv.uno_auc           lp</span><br><span>## 22:       surv.uno_tnr           lp</span><br><span>## 23:       surv.uno_tpr           lp</span><br><span>## 24:         surv.xu_r2           lp</span><br><span>##                    key predict_type</span><br></code></pre><p data-tool="mdnice编辑器">大家最常见的指标，比如brierscore（surv.graf）、auc、cindex等都是支持的，不同的指标需要不同的预测结果类型（如上所示）。</p><p data-tool="mdnice编辑器">目前对于指标的选择并没有金标准，<code>mlr3</code>官方推荐对于右删失数据使用right-censored-logloss（<code>msr("surv.rcll")</code>）评价<code>dsitr</code>型的预测结果，使用一致性指数（<code>msr("surv.cindex")</code>）评价模型的区分度，使用D-校准指数（<code>msr("surv.dcalib")</code>）评价的模型校准度。</p><p data-tool="mdnice编辑器">下面是使用3种指标评价我们的模型：</p><pre data-tool="mdnice编辑器"><code>prediction_cph$score(msrs(c(<span>"surv.rcll"</span>, <span>"surv.cindex"</span>, <span>"surv.dcalib"</span>)))<br><span>##   surv.rcll surv.cindex surv.dcalib </span><br><span>##   3.7365110   0.8191794   1.5182567</span><br></code></pre><p data-tool="mdnice编辑器">logloss越小越好，是评估模型拟合程度的，单看surv.rcll，这个模型还不错；cindex是越接近1越好，但看cindex，这个模型也是还挺不错的；单看dcalib感觉模型不太行。但是如果不和基线模型（通常是Kaplan-Meier法）比较的话很难说某个模型到底是好还是坏。</p><h2 data-tool="mdnice编辑器"><span></span><span>预测结果的转换</span><span></span></h2><p data-tool="mdnice编辑器"><code>mlr3proba</code>中的预测结果其实是分为<code>native</code>和<code>composed</code>的，native是模型本身的预测结果，composed是经过转换的，比如crank这个结果就是经过转换的（因为不同模型的crank代表的意思是不一样的，经过转换之后的意义就一样了，即crank越大风险越高），<code>mlr3proba</code>会自动进行这一步，具体细节我们就不说了。</p><p data-tool="mdnice编辑器">native和composed这两种预测结果是可以互相转换的，这个是通过<code>compositor</code>这类管道操作实现的，目前最常见的是以下两种：</p><ol data-tool="mdnice编辑器"><li><section><code>pipeline_crankcompositor()</code>：把<code>distr</code>转换为<code>crank</code></section></li><li><section><code>pipeline_distrcompositor()</code>：把<code>lp</code>转换为<code>distr</code></section></li></ol><p data-tool="mdnice编辑器">但是在实际使用时，第1种操作其实<code>mlr3</code>默认会自动为我们进行，无需手动实现（除非你想重新再转换一下）。第2种操作才是我们会经常用到的。</p><p data-tool="mdnice编辑器">比如<a href="https://mp.weixin.qq.com/s?__biz=MzUzOTQzNzU0NA==&amp;mid=2247500562&amp;idx=1&amp;sn=b4383f3c7ceb96edff5a070d13978bf6&amp;scene=21#wechat_redirect" data-linktype="2">梯度提升机GBM模型</a>只支持<code>lp</code>和<code>crank</code>这两种类型，我们需要得到<code>distr</code>这种类型的预测结果，就可以通过<code>distrcompositor</code>实现。</p><p data-tool="mdnice编辑器">首先看下默认的GBM模型是没有<code>distr</code>这种预测结果的（mlr3book官网用的例子是正则化COX回归，但是目前版本的正则化COX回归已经支持distr这种预测类型了）：</p><pre data-tool="mdnice编辑器"><code>tsk_rats &lt;- tsk(<span>"rats"</span>)$select(c(<span>"litter"</span>, <span>"rx"</span>))<br>split &lt;- partition(tsk_rats)<br><br>learner &lt;- lrn(<span>"surv.gbm"</span>)<br><br><span># 没有distr</span><br>learner$train(tsk_rats, split$train)$predict(tsk_rats, split$test)<br><span>## &lt;PredictionSurv&gt; for 99 observations:</span><br><span>##     row_ids time status      crank         lp</span><br><span>##           9  104  FALSE -1.3179129 -1.3179129</span><br><span>##          11  104  FALSE -1.3179129 -1.3179129</span><br><span>##          12  102  FALSE -1.3179129 -1.3179129</span><br><span>## ---                                          </span><br><span>##         249   66   TRUE -0.1916111 -0.1916111</span><br><span>##         253   92   TRUE  0.3756322  0.3756322</span><br><span>##         297   79   TRUE -0.7755802 -0.7755802</span><br></code></pre><p data-tool="mdnice编辑器">下面我们选择GBM模型，然后指定基线评估方法为Kaplan-Meier法，并且假设我们的预测分布是比例风险的形式，使用<code>distrcompositor</code>这个管道操作，即可让GBM模型支持<code>distr</code>类型的输出：</p><pre data-tool="mdnice编辑器"><code>graph_learner &lt;- as_learner(ppl(<br>  <span>"distrcompositor"</span>,<br>  learner = learner,<br>  estimator = <span>"kaplan"</span>,<br>  form = <span>"ph"</span><br>))<br><br><span># 现在有distr了</span><br>graph_learner$train(tsk_rats, split$train)$predict(tsk_rats, split$test)<br><span>## &lt;PredictionSurv&gt; for 99 observations:</span><br><span>##     row_ids time status      crank         lp     distr</span><br><span>##           9  104  FALSE -1.0502036 -1.0502036 &lt;list[1]&gt;</span><br><span>##          11  104  FALSE -1.0502036 -1.0502036 &lt;list[1]&gt;</span><br><span>##          12  102  FALSE -1.0502036 -1.0502036 &lt;list[1]&gt;</span><br><span>## ---                                                    </span><br><span>##         249   66   TRUE -0.2894398 -0.2894398 &lt;list[1]&gt;</span><br><span>##         253   92   TRUE  0.2619725  0.2619725 &lt;list[1]&gt;</span><br><span>##         297   79   TRUE -0.7371226 -0.7371226 &lt;list[1]&gt;</span><br></code></pre><p data-tool="mdnice编辑器">是不是很牛逼呢？</p><p data-tool="mdnice编辑器">各种转换都可以，这样就方便不同模型的比较了，不存在你有我没有的情况。</p><h2 data-tool="mdnice编辑器"><span></span><span>多模型比较</span><span></span></h2><p data-tool="mdnice编辑器">下面是一个多模型比较的例子，由于不同模型的预测类型可以互相转换，因此我们可以很方便的进行多模型的比较。</p><p data-tool="mdnice编辑器">我们选择GBM模型、Kaplan-Meier法、cox模型进行比较，使用3折交叉验证：</p><pre data-tool="mdnice编辑器"><code>tsk_grace &lt;- tsk(<span>"grace"</span>)<br>tsk_grace$filter(sample(tsk_grace$nrow, <span>500</span>))<br>msr_txt &lt;- c(<span>"surv.rcll"</span>, <span>"surv.cindex"</span>, <span>"surv.dcalib"</span>)<br>measures &lt;- msrs(msr_txt)<br><br><span># 图学习器</span><br>graph_learner &lt;- as_learner(ppl(<br>  <span>"distrcompositor"</span>,<br>  learner = lrn(<span>"surv.gbm"</span>),<br>  estimator = <span>"kaplan"</span>,<br>  form = <span>"ph"</span><br>))<br>graph_learner$id &lt;- <span>"gbm"</span><br>learners &lt;- c(lrns(c(<span>"surv.coxph"</span>, <span>"surv.kaplan"</span>)), graph_learner)<br><br>set.seed(<span>1258</span>)<br>bmr &lt;- benchmark(benchmark_grid(tsk_grace, learners,<br>  rsmp(<span>"cv"</span>, folds = <span>3</span>)))<br><span>## INFO  [13:55:07.774] [mlr3] Running benchmark with 9 resampling iterations</span><br><span>## INFO  [13:55:07.818] [mlr3] Applying learner 'surv.coxph' on task 'grace' (iter 1/3)</span><br><span>## INFO  [13:55:07.837] [mlr3] Applying learner 'surv.coxph' on task 'grace' (iter 2/3)</span><br><span>## INFO  [13:55:07.851] [mlr3] Applying learner 'surv.coxph' on task 'grace' (iter 3/3)</span><br><span>## INFO  [13:55:07.864] [mlr3] Applying learner 'surv.kaplan' on task 'grace' (iter 1/3)</span><br><span>## INFO  [13:55:07.877] [mlr3] Applying learner 'surv.kaplan' on task 'grace' (iter 2/3)</span><br><span>## INFO  [13:55:08.131] [mlr3] Applying learner 'surv.kaplan' on task 'grace' (iter 3/3)</span><br><span>## INFO  [13:55:08.145] [mlr3] Applying learner 'gbm' on task 'grace' (iter 1/3)</span><br><span>## INFO  [13:55:08.212] [mlr3] Applying learner 'gbm' on task 'grace' (iter 2/3)</span><br><span>## INFO  [13:55:08.278] [mlr3] Applying learner 'gbm' on task 'grace' (iter 3/3)</span><br><span>## INFO  [13:55:08.348] [mlr3] Finished benchmark</span><br>bmr$aggregate(measures)[, c(<span>"learner_id"</span>, ..msr_txt)]<br><span>##     learner_id surv.rcll surv.cindex surv.dcalib</span><br><span>## 1:  surv.coxph  5.075566   0.8409297    <span>7.071879</span></span><br><span>## 2: surv.kaplan  5.304874   0.5000000    4.431708</span><br><span>## 3:         gbm 10.263326   0.8560972   10.000000</span><br></code></pre><p data-tool="mdnice编辑器">结果表明，gbm模型的区分度最好（surv.rcll最高），Kaplan-Meier法的校准度最好（surv.dcalib最低），coxph和gbm的模型准确性（模型拟合程度）差不多（cindex差不多）。</p><p data-tool="mdnice编辑器">遥遥领先！强烈推荐，大家快去学！</p><p data-tool="mdnice编辑器">公众号后台回复<strong>mlr3</strong>即可获取相关推文合集。</p></section><p><span><br></span></p><hr><blockquote><p><span><strong>联系我们，关注我们</strong></span></p><ol><li><section>免费QQ交流群1：613637742</section></li><li><section>免费QQ交流群2：608720452</section></li><li><section>公众号消息界面关于作者获取联系方式</section></li><li><section>知乎、CSDN、简书同名账号</section></li><li><section>哔哩哔哩：阿越就是我</section></li></ol></blockquote></section></section></section></section></section><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/Js7_axZ3DIkHupoYpACZOA",target="_blank" rel="noopener noreferrer">原文链接</a>
