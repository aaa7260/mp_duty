---
title: "给你一份批量数据处理的学习笔记，感受一下编程的魅力！"
date: 2023-02-27T10:59:44Z
draft: ["false"]
tags: [
  "fetched",
  "果子学生信"
]
categories: ["Acdemic"]
---
给你一份批量数据处理的学习笔记，感受一下编程的魅力！ by 果子学生信
------
<div><section><h4><span>果子荐读</span></h4><p>编程带给我最大的震撼应该就是批量处理。他让一些数据分析从不能到能，从慢到快。这是我获益最多的技能。<br>有了这个技能，我才感到自己无可替代。因为批量是个通用技能，但是批量的那个动作是个性化需求。<br>而个性化的需求最终只能自己实现。<br>数据分析，数据挖掘没有尽头，第一，数据源源不断，第二，认知持续提升。在这其中，拥有一个傍身的技能是行走江湖的基本要求。<br>因此，我总结了常用的批量流程，写成了教程，也录制了视频。<br><a href="https://mp.weixin.qq.com/s?__biz=MzIyMzA2MTcwMg==&amp;mid=2650735312&amp;idx=1&amp;sn=f5112522e84e6ca17fb79cf5fbf5da22&amp;scene=21#wechat_redirect" data-linktype="2">视频课程: R语言中的批量操作，裂变你的技能。</a><br>教程发布后，很多朋友迅速学习，立马用到自己的课题中去。<br>我邀请了两位朋友，给大家分享一下学习感受。</p><blockquote><p>听讲座，看分享，并不能立竿见影地提高技能，但他能够拓宽你的眼界，告诉你努力的底线和上限。</p></blockquote><p>今天是第一位，是Cloudy，2年的老朋友了。<br>使用幕布梳理思路，使用markdown写作，使用图床保存图片，这个习惯很有辨识度啊。<br>熊确实影响了不少人。</p><p>以下是正文</p><hr><p>最近学了果子老师推出的GZ07课程，略有所获，下面分享下自己的学习心得。</p><h4><span>一、课程框架与主要内容</span></h4><figure><img data-ratio="0.3356918238993711" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbELkL7PY39iaFRa6XcuP4Llrjg44raOoc99fVaor8cqpE0LO1COmxzCFg/640?wx_fmt=png" data-type="png" data-w="1272" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbELkL7PY39iaFRa6XcuP4Llrjg44raOoc99fVaor8cqpE0LO1COmxzCFg/640?wx_fmt=png"></figure><p>这个课程总共提供了10个脚本，学习视频时长约150min。课程的主体是关于R语言中批量操作的一些代码编写技巧，然后课程提供了丰富的例子对如何使用循环和函数批量操作数据进行了实践。</p><p>其实如果单从批量操作学习的角度，个人感觉到脚本07生存分析那里课程其实就挺完整的了，基本上多过几遍能学习到for循环到基本函数编写的基本技能。但是随着课程学习的循序渐进，我发现从脚本08、脚本09、脚本10及附加脚本<strong>pancorplot</strong>才是课程的精华所在。</p><p>这三个脚本使用XENA数据库的泛癌数据进行推演运算，里面涵盖的知识点包括且不限于：批量相关性分析、统计结果的提取、条件判断及<strong>ggplot2</strong>、for循环嵌套函数、函数嵌套函数、R语言控制结构、<strong>ggplot2</strong>的图形语法等。基本是课程前面课程讲述的所有知识点的一次总结和综合应用。</p><h4><span>二、课程中令我印象深刻的函数们</span></h4><p>数据库最后4个脚本里面几个重点的函数是十分值得学习的：</p><p><strong>函数1：pancor</strong></p><p><strong>功能：</strong> 计算任意两个基因在泛癌数据中的相关性</p><pre><code>pancor &lt;- <span><span>function</span><span>(gene1,gene2,data=splitdata)</span></span>{<br>      <span>do</span>.call(rbind,lapply(data, <span><span>function</span><span>(x)</span></span>{<br>    dd=cor.test(<span>as</span>.numeric(x[,gene1]),<span>as</span>.numeric(x[,gene2]),type=<span>"pearson"</span>) <br>    data.frame(type=x$type[<span>1</span>],cor=dd$estimate,p.value=dd$p.value )<br>    }))}<br></code></pre><p><strong>函数2：pancorBatch</strong></p><p><strong>功能：</strong> 批量计算两个基因在泛癌数据中的相关性并按相关性系数进行筛选相关的癌种</p><pre><code>pancorBatch &lt;- <span><span>function</span><span>(gene1,gene2,splitdata)</span></span>{<br>  <span>## 一对基因批量分析</span><br>  pancordata = <span>do</span>.call(rbind,lapply(splitdata, <span><span>function</span><span>(x)</span></span>{<br>    dd  &lt;- cor.test(<span>as</span>.numeric(x[,gene1]),<span>as</span>.numeric(x[,gene2]),type=<span>"pearson"</span>)<br>    data.frame(type=x$type[<span>1</span>],cor=dd$estimate,p.value=dd$p.value )<br>  }))<br>  <span>## 提取数据</span><br>  subdata = pancordata[pancordata$p.value &lt; <span>0.05</span> ,]<br>  <span>## 汇总数据</span><br>  data.frame(gene1=gene1,<br>             count= nrow(subdata),<br>             avercor= mean(subdata$cor),<br>             positive= sum(subdata$cor &gt; <span>0</span>),<br>             engitive= sum(subdata$cor &lt; <span>0</span>))<br>}<br></code></pre><p>这个函数初看还是有点高能的，因为里面是function+function的结构，但其实认真读进去会发现其实很好理解，<strong>splitdata</strong>是已知的泛癌数据使用<strong>split函数</strong>切割后的数据，下位的函数传递的每一个<strong>x</strong>都是泛癌数据的表达矩阵。</p><p>所以，其实只有两个参数是未知的，两个基因，gene1和gene2，只要设定好这两个实际的参数，整个函数就可以启动了。也因为泛癌数据涉及33种癌症，所以基本上，无论gene1和gene2输入了啥，出来的pancordata都是一个33行，3列的矩阵。大概长这样：</p><figure><img data-ratio="1.7252396166134185" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbEnqTERVzAqAtyNbu7dc94ML4dABlUUApbkNicnPjWOEicUJpiaUPpQeh3Q/640?wx_fmt=png" data-type="png" data-w="313" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbEnqTERVzAqAtyNbu7dc94ML4dABlUUApbkNicnPjWOEicUJpiaUPpQeh3Q/640?wx_fmt=png"></figure><p>后面，subdata是兴趣基因对在所有癌种中的相关性筛选出来的p值小于0.05的结果。实际上还是两个基因在泛癌中的相关性。因为输出结果是gene1，所以其实函数默认了我们的兴趣基因是gene2。举个例子，我设定gene1为ESR1，那么单次运算出来的结果就如下图：</p><figure><img data-ratio="0.11604584527220631" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbEibdXiciaicWB8cdmCo4MMqMarR6zJS7diar8ibDqMZ3yW5YibppEfsVkKJ4fQ/640?wx_fmt=png" data-type="png" data-w="698" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbEibdXiciaicWB8cdmCo4MMqMarR6zJS7diar8ibDqMZ3yW5YibppEfsVkKJ4fQ/640?wx_fmt=png"></figure><p>count是癌种的数目，avecor是平均的相关性系数，positive和engitive是正相关和负相关的个数。</p><p>注意这里是用相关性系数＞0或者＜0去筛选的，自己做的时候可以进一步筛选</p><p><strong>函数3：pancorplot</strong></p><pre><code><span>pancorplot <span>&lt;<span>-</span> <span>function</span>(<span>data</span>=<span>plotdf,anotate</span>=<span>"none"</span>){<br>  <span>require</span>(<span>ggplot2</span>)<br>  <span>require</span>(<span>ggrepel</span>)<br>  <span>options</span>(<span>scipen</span> = <span>2)</span><br>  <span>p</span>=<span>ggplot(plotdf,aes(-log10(p.value),cor))+</span><br>    <span>geom_point</span>(<span>data</span>=<span>subset(plotdf,</span> <span>plotdf</span>$<span>p.value</span> &gt;</span>= 0.05),size=6,fill="grey",alpha=0.6,shape = 21,colour="black",stroke = 1.5)+<br>    geom_point(data=subset(plotdf, plotdf$p.value <span>&lt; <span>0.05</span> &amp; <span>plotdf</span>$<span>cor</span>&gt;</span>=0),size=6,fill="red",alpha=0.6,shape = 21,colour="black",stroke = 1.5)+<br>    geom_point(data=subset(plotdf, plotdf$p.value <span>&lt; <span>0.05</span> &amp; <span>plotdf</span>$<span>cor</span>&lt; <span>0</span>),<span>size</span>=<span>6,fill</span>=<span>"blue"</span>,<span>alpha</span>=<span>0.6,shape</span> = <span>21,colour</span>=<span>"black"</span>,<span>stroke</span> = <span>1.5)+</span><br>    <span>scale_y_continuous</span>(<span>expand</span> = <span>c(0,0),limits</span> = <span>c(-1.1,1.1),breaks</span> = <span>seq(-1,1,0.2))+</span><br>    <span>scale_x_log10</span>(<span>limits</span> = <span>c(0.01,</span> <span>1000</span>),<span>breaks</span> = <span>c(0.01,0.1,10,1000))+</span><br>    <span>geom_hline</span>(<span>yintercept</span> = <span>0,size</span>=<span>1.5)+</span><br>    <span>geom_vline</span>(<span>xintercept</span> = <span>-log10(0.05),size</span>=<span>1.5)+</span><br>    <span>labs</span>(<span>x</span>=<span>bquote(-log[10]~italic(</span>"<span>P</span>")),<span>y</span>=<span>"Pearson correlation (r)"</span>)+<br>    <span>theme</span>(<span>axis.title</span>=<span>element_text(size</span>=<span>20),</span><br>          <span>axis.text</span> = <span>element_text(face</span> = <span>"bold"</span>,<span>size</span> = <span>16),</span><br>          <span>axis.ticks.length</span>=<span>unit(.4,</span> "<span>cm</span>"),<br>          <span>axis.ticks</span> = <span>element_line(colour</span> = <span>"black"</span>, <span>size</span> = <span>1),</span><br>          <span>panel.background</span> = <span>element_blank(),</span><br>          <span>panel.grid.major</span> = <span>element_blank(),</span> <br>          <span>panel.grid.minor</span> = <span>element_blank(),</span><br>          <span>axis.line</span> = <span>element_line(colour</span> = <span>"black"</span>),<br>          <span>panel.border</span> = <span>element_rect(colour</span> = <span>"black"</span>, <span>fill</span>=<span>NA,</span> <span>size</span>=<span>1.5),</span><br>          <span>plot.margin</span> = <span>margin(1,</span> <span>1</span>, <span>1</span>, <span>1</span>, "<span>cm</span>"))<br>  <span>index</span> = <span>anotate</span> == <span>"none"</span><br>  <span>index</span> = <span>index[1]</span><br>  <span>if</span>(<span>index</span>){<br>    <span>p</span><br>  }<span>else</span>{<br>    <span>p</span> +  <span>geom_point</span>(<span>data</span>=<span>subset(plotdf,</span> <span>plotdf</span>$<span>type</span>%<span>in</span>% <span>anotate</span>),<br>                    <span>size</span>=<span>6,shape</span> = <span>21,colour</span>=<span>"green"</span>,<span>stroke</span> = <span>2)+</span><br>      <span>geom_label_repel</span>(<span>data</span>=<span>subset(plotdf,</span> <span>plotdf</span>$<span>type</span> %<span>in</span>% <span>anotate</span>), <br>                       <span>aes</span>(<span>label</span>=<span>type),col</span>=<span>"black"</span>,<span>size</span>=<span>6,</span><br>                       <span>box.padding</span> = <span>10,</span><br>                       <span>arrow</span>=<span>arrow(angle</span> = <span>30,</span> <span>length</span> = <span>unit(0.25,</span> "<span>inches</span>"),<br>                                   <span>ends</span> = <span>"first"</span>, <span>type</span> = <span>"closed"</span>),<br>                       <span>segment.size</span>=<span>1,</span><br>                       <span>segment.color</span> = <span>"red"</span>)<br>  }<br>}<br></span></span></code></pre><p>出的图大概长这样：</p><figure><img data-ratio="0.8" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbE5cKLtF3tJ8fxA3j0uI9qbwMRic9WLTrkNbaAgNhI3xsY70yFbB5sZBg/640?wx_fmt=png" data-type="png" data-w="870" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbE5cKLtF3tJ8fxA3j0uI9qbwMRic9WLTrkNbaAgNhI3xsY70yFbB5sZBg/640?wx_fmt=png"></figure><p>这个函数本质上是点图，前面写的思路和ggplot2绘制火山图是如出一辙的（嗯，火山图本质上也是点图），就是不断在提取数据的子集，然后在画布上打点、上色，最后加上线条。</p><p>但是它的构建逻辑很好，后面那个标签部分是值得摸索和学习的。画出来的图打的标签都能令人基本满意，如果不满意，解决方法果子老师也提供了，在GZ01的更新课程中，使用export包导出成ppt自己改到满意为止。("▔□▔)/ 这个包的链接在这：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyMzA2MTcwMg==&amp;amp;mid=2650734209&amp;amp;idx=1&amp;amp;sn=88de6b7a7e0bf4a2ea43cf1cacc5d42b&amp;amp;chksm=f029ad28c75e243eeef218567b0ddde257307aef3d27bc143d68163dbdcb192a48ffe2773794&amp;amp;token=913097421&amp;amp;lang=zh_CN&amp;amp;scene=21&amp;key=&amp;ascene=1&amp;uin=&amp;devicetype=Windows%2010%20x64&amp;version=63030073&amp;lang=zh_CN&amp;wx_header=0&amp;fontgear=2#wechat_redirect" data-linktype="2">出图神器export目前不能用了，该如何是好？</a></p><p>当然，<strong>esquisse</strong>包也是个不错的选择，看个人喜好和习惯。</p><p>之后课程中脚本09和脚本10继续整活，前面我们已知:</p><p>①<strong>pancor函数</strong>：能让我们计算兴趣基因和任意一个其他基因在泛癌数据中的相关性</p><p>②<strong>pancorBatch函数</strong>：能够让我们获取任意兴趣基因和任意一个其他基因在33种癌症中的相关性情况。</p><p>③<strong>pancorplot函数</strong>：能够可视化<strong>pancorBatch 函数</strong>的结果进行可视化。</p><p>那么如果我们想知道兴趣基因和所有其他基因在泛癌数据中的整体相关性情况，怎么整？对，启动批量，lapply或者future.apply往上面一套就出来了。如果你想让lapply也带个进度条，那<strong>pblapply</strong>包了解下。</p><p>图一个一个画不过瘾，for循环+ggsave函数安排上，噌噌噌，你的文件夹里都是图。</p><figure><img data-ratio="0.5359223300970873" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbEQ6GyIYJSiaInic0m49eU54ePADBQ6ticPy8n6sjWbChQdpHfB1TjFNEeg/640?wx_fmt=png" data-type="png" data-w="515" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbEQ6GyIYJSiaInic0m49eU54ePADBQ6ticPy8n6sjWbChQdpHfB1TjFNEeg/640?wx_fmt=png"></figure><p>通常情况下，“套娃行为”会让人困惑，但是编程里面这样的套娃却让人感到十足的快乐，多少有一种不经意间就解放双手，做到超级多的事情满足感！</p><p>如果觉得这样的需求很需要，但是代码还是看的云里雾里，那么没有问题，课程里面果子老师授人以渔也授人以鱼了。直接套用脚本08/09后面现成脚本，把他们粘贴复制，创建个新脚本，导入自己的数据，以上的需求基本上也就分分钟解决了。什么叫用1%的时间，解决99%的问题呀（战术后仰）╮(╯▽╰)╭。</p><figure><img data-ratio="0.6598984771573604" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbEqhdQebHfPaQ7DpXqkIAStRkVRIXD3qvXfbPbdAexnFvQwmopkwYodA/640?wx_fmt=png" data-type="png" data-w="591" title="" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2jcdCKg8IGs5xBuBTzhAbEqhdQebHfPaQ7DpXqkIAStRkVRIXD3qvXfbPbdAexnFvQwmopkwYodA/640?wx_fmt=png"></figure><p>诚如果子老师最后总结，GZ07是可以和可以和GZ01课程对接的，先使用同样的方法，筛选在GETx数据库中和我们手头兴趣基因表达呈正相关的基因（或者负相关）。然后再泛癌数据中再操作一遍，筛选和我们兴趣基因表达呈负相关（或者正相关）的基因。这样的基因对可能因为癌症的发生表达调控发生改变，可以作为以后研究的idea。</p><h4><span>三、学完之后自己也整个函数玩一下</span></h4><p>GZ07可以当成需求的实现，也可以作为对R语言编程的一次系统入门或者复习回顾，学完之后我也尝试了整了个函数玩玩，代码如下：</p><pre><code>library(tidyverse)<br><span>##生成示例数据</span><br>set.seed(<span>3</span>)<br>data.frame(gene=letters[<span>1</span>:<span>10</span>],value1=<span>1</span>:<span>10</span>,<br>               value2=<span>1</span>:<span>10</span>,value3=<span>1</span>:<span>10</span>,<br>               value4=<span>1</span>:<span>10</span>,value5=<span>1</span>:<span>10</span>,<br>               value6=<span>1</span>:<span>10</span>) %&gt;% <br>  column_to_rownames(<span>"gene"</span>) %&gt;% <br>  t() %&gt;% <br>  as.data.frame() %&gt;% <br>  mutate(<span>group</span>=rep(LETTERS[<span>1</span>:<span>2</span>],<span>each</span>=<span>3</span>)) %&gt;% <br>  mutate(kt=rnorm(<span>6</span>),bt=<span>sample</span>(seq(<span>1</span>,<span>6</span>,<span>0.9</span>),<span>6</span>,T)) %&gt;% <br>  <span>select</span>(<span>group</span>,everything())-&gt;dat<br><br><span>###构建函数</span><br>Compare_means&lt;- <span>function</span>(gene, dat) {<br>  <span># 方差齐性检验</span><br>  var_check &lt;- var.test(dat[, gene] ~ <span>group</span>, <span>data</span> = dat)<br>  <span># 如果方差是0或者无法计算为缺失值时，数据会无法执行正态分布检验，所以直接设置返回缺失值</span><br>  <span>if</span> (var_check$estimate == <span>0</span> | is.na(var_check$estimate)) {<br>    <span>return</span>(data.frame(gene = gene, statistic = NA, pvalue = NA, method = NA))<br>  }<br>  <span># 正态性检验</span><br>  shap &lt;- tapply(dat[, gene], dat$<span>group</span>, shapiro.test)<br><br>  <span># 如果两组有任意一组数据符合正态分布且两组数据对比方差齐则执行t检验，否则执行 wilcox.test</span><br><br>  <span>#shapiro.test：p值大于0.05符合正态分布</span><br>  <span>#var.test：p值大于0.05符合方差齐性</span><br><br>  <span># 判断执行t检验还是秩和检验并返回统计量、p值</span><br>  <span>if</span> (all(c(shap[[<span>1</span>]]$p.value, shap[[<span>2</span>]]$p.value) &gt; <span>0.05</span> &amp;&amp; var_check$p.value &gt; <span>0.05</span>)) {<br>    <span>test</span> &lt;- t.test(dat[, gene] ~ <span>group</span>, <span>data</span> = dat)<br>    res &lt;- data.frame(gene = gene, statistic = <span>test</span>$statistic, pvalue = <span>test</span>$p.value, method = <span>"t.test"</span>)<br>  } <span>else</span> {<br>    <span>test</span> &lt;- wilcox.test(dat[, gene] ~ <span>group</span>, <span>data</span> = dat, exact = F)<br>    res &lt;- data.frame(gene = gene, statistic = <span>test</span>$statistic, pvalue = <span>test</span>$p.value, method = <span>"wilcox.test"</span>)<br>  }<br>  <span>return</span>(res)<br>}<br><br>do.call(rbind,lapply(<span>names</span>(dat)[<span>-1</span>], Compare_means,dat))<br></code></pre><p><strong>示例数据输出结果</strong></p><pre><code>   gene   statistic    pvalue      method<br><span>1</span>     a          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br><span>2</span>     b          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br><span>3</span>     c          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br><span>4</span>     d          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br><span>5</span>     e          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br><span>6</span>     f          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br><span>7</span>     g          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br><span>8</span>     h          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br><span>9</span>     i          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br><span>10</span>    j          <span>NA</span>        <span>NA</span>        &lt;<span>NA</span>&gt;<br>t    kt -<span>0.04193745</span> <span>0.9686219</span>      t.test<br>W    bt  <span>4.00000000</span> <span>1.0000000</span> wilcox.test<br></code></pre><p>我用这个小函数实现了在自己的数据中批量对基因进行t检验或者秩和检验，想看看这样分析基因在癌旁和肿瘤中的表达和差异分析结果会有什么不同，有没有哪些可以注意的地方。函数加上future.apply，5分钟不到在我的小电脑上2w+个基因就算完了，一和差异基因对比，还真是有一些不同的地方，也带来了一点新的启发。</p><p>当然在写的过程中其实也遭遇了一些列的报错和调试，其实也是挺麻烦的。报错的点出现在数据的第5000多个基因那里，因为表达量问题，无法执行正态检验。还有因为数据方差是0报错的，总之一个小小的函数也踩了不少坑。我后来是通过先将函数改写成for循环，让循环打印迭代次数才捕捉到这些个报错然后加判断语句绕过它们的。</p><p>哈哈，也期待果子老师在后续课程更新可以分享一些关于函数书写、调试、报错debug的经验和知识~("▔□▔)/</p><p>function的报错最终不会返回任何结果，只有控制台的ERROR。对比for循环，如果我们创建了容器，那么至少报错之前的结果也是可以存下来的。这大概也是两者的一个不同的点吧。</p><p>批量会为数据分析带来无限可能，for循环是基础，lapply的隐式循环+向量化编程会让操作提速提速再提速~</p><p>分享到这就告一段落吧，祝各位大佬眼明心亮，在GZ系列课程中都学有所获，早日走上数据分析的无忧之路~( ^_^ )/~~拜拜</p></section></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/OXiKZrpFyEchzsfcaP95jQ",target="_blank" rel="noopener noreferrer">原文链接</a>
