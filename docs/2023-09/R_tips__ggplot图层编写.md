---
title: "R tips: ggplot图层编写"
date: 2023-09-02T04:23:39Z
draft: ["false"]
tags: [
  "fetched",
  "生信菜鸟团"
]
categories: ["Acdemic"]
---
R tips: ggplot图层编写 by 生信菜鸟团
------
<div><p>在实际使用中，ggplot中使用的图层是以geom或者stat开头的函数创建的，但是如果查看一下这些图层函数的具体内容可以发现他们都是在封装一个layer函数。</p><pre><code><span># 点图层</span><br>geom_point &lt;- <span>function</span>(mapping = <span>NULL</span>, data = <span>NULL</span>,<br>                       stat = <span>"identity"</span>, position = <span>"identity"</span>,<br>                       <span>...</span>,<br>                       na.rm = <span>FALSE</span>,<br>                       show.legend = <span>NA</span>,<br>                       inherit.aes = <span>TRUE</span>) {<br>  layer(<br>    data = data,<br>    mapping = mapping,<br>    stat = stat,<br>    geom = GeomPoint,<br>    position = position,<br>    show.legend = show.legend,<br>    inherit.aes = inherit.aes,<br>    params = list(<br>      na.rm = na.rm,<br>      <span>...</span><br>    )<br>  )<br>}<br><br><span># chull图层</span><br><span>function</span>(mapping = <span>NULL</span>,<br>         data = <span>NULL</span>,<br>         geom = <span>"polygon"</span>,<br>         position = <span>"identity"</span>,<br>         na.rm = <span>FALSE</span>,<br>         show.legend = <span>FALSE</span>,<br>         inherit.aes = <span>TRUE</span>,<br>         fill = <span>"WhiteSmoke"</span>,<br>         color = <span>NA</span>,<br>         <span>...</span>) {<br>  layer(<br>    stat = StatChull,<br>    data = data,<br>    mapping = mapping,<br>    geom = geom,<br>    position = position,<br>    show.legend = show.legend,<br>    inherit.aes = inherit.aes,<br>    params = list(<br>      na.rm = na.rm,<br>      fill = fill,<br>      color = color,<br>      <span>...</span><br>    )<br>  )<br>}<br></code></pre><p>现在细究一下layer函数，代码如下所示。</p><p>可以发现layer函数先处理了一个图层 的geom和stat对象，然后解析出来各种美学和图层参数，最后返回一个ggproto对象用于描述图层的各种信息。</p><p><strong>因此可做如下总结</strong></p><p>一个图层的定义(geom或者stat开头的函数)必须同时包含一个geom和一个stat对象，通过layer函数将其串联在一起，返回一个ggproto对象。这个返回的ggproto对象是基于一个LAYER父类，这个LAYER是一个容器，里面有Geom和Stat对象。可以为默认的Stat和Geom，也可以是定制的Stat和Geom，比如GeomBoxplot、StatChull等对象。</p><pre><code>layer &lt;- <span>function</span>(geom = <span>NULL</span>, stat = <span>NULL</span>,<br>                  data = <span>NULL</span>, mapping = <span>NULL</span>,<br>                  position = <span>NULL</span>, params = list(),<br>                  inherit.aes = <span>TRUE</span>, check.aes = <span>TRUE</span>, check.param = <span>TRUE</span>,<br>                  show.legend = <span>NA</span>, key_glyph = <span>NULL</span>, layer_class = Layer) {<br><span># ...部分代码省略...</span><br><br>  data &lt;- fortify(data)<br><br>  geom &lt;- check_subclass(geom, <span>"Geom"</span>, env = parent.frame())<br>  stat &lt;- check_subclass(stat, <span>"Stat"</span>, env = parent.frame())<br>  position &lt;- check_subclass(position, <span>"Position"</span>, env = parent.frame())<br><br><span># ...部分代码省略...</span><br><br>  <span># Split up params between aesthetics, geom, and stat</span><br>  params &lt;- rename_aes(params)<br>  aes_params  &lt;- params[intersect(names(params), geom$aesthetics())]<br>  geom_params &lt;- params[intersect(names(params), geom$parameters(<span>TRUE</span>))]<br>  stat_params &lt;- params[intersect(names(params), stat$parameters(<span>TRUE</span>))]<br><br><span># ...部分代码省略...</span><br><br>  ggproto(<span>"LayerInstance"</span>, layer_class,<br>    geom = geom,<br>    geom_params = geom_params,<br>    stat = stat,<br>    stat_params = stat_params,<br>    data = data,<br>    mapping = mapping,<br>    aes_params = aes_params,<br>    position = position,<br>    inherit.aes = inherit.aes,<br>    show.legend = show.legend<br>  )<br>}<br></code></pre><blockquote><p>这里的ggproto函数的第二个参数代表一个ggproto类的父类，在这里是layer_class，它是layer函数的一个参数，其值是一个ggplot2预先定义的Layer类。</p></blockquote><h3><span>一个ggplot对象的渲染过程</span></h3><p>一个ggplot2的渲染过程分为两步：</p><p>（1）ggplot_build函数将ggplot对象进行各种数据和坐标变换，生成一个ggplot_build对象；</p><p>（2）ggplot_gtable函数以ggplot_build对象为输入进行下一步的绘图对象生成的工作，最后返回一个gtable对象。</p><p>gtable就是一个可以直接渲染的图形对象了。</p><p>ggplot_build函数的具体处理过程如下：</p><ul><li><p>layer: ggplot对象在绘制过程中，首先是使用Layer的setup_layer函数处理layer相关的数据处理，这里一般不处理数据，只是一个hook。</p></li><li><p>layout: 生成layout：layout调用facet的setup…, 调用coords的setup…</p></li><li><p>layer: layer的compute_aesthetics函数，在计算aes里面的变量，添加PANEL和使用add_group添加group信息</p></li><li><p>layout: layout相关调整 ：train_position and map_position</p></li><li><p><strong>Stat</strong>: layer的compute_statistic，调用了Stat类的相关数据信息， setup_params setup_data compute_layer</p></li><li><p>layer: layer的map_statistic，应用aesthetic相关的eval操作，比如color、fill等解析为具体的值</p></li><li><p><strong>Geom</strong>: layer的compute_geom1，调用了Geom子类的相关信息， setup_params setup_data</p></li><li><p>position: layer的compute_position，调用了position子类的相关信息 setup_params setup_data compute_layer</p></li><li><p>layout: 二次调整, reset_scales train_position and map_position</p></li><li><p><strong>Geom</strong>: layer的compute_geom_2，调用了Geom子类的相关信息， use_defaults，主要是添加了默认美学参数</p></li><li><p><strong>Stat</strong>: layer的finish_statistics，调用了Stat的finish_layer， 默认为不处理<br><strong>至此，一个ggplot_built对象完成创建。</strong></p></li><li><p><strong>Geom</strong>: 在ggplot_gtable的第一个环节就是调用layer的draw_geom函数，draw_geom调用每个layer的draw_layer函数完成grob对象创建、</p></li><li><p>其他从略</p></li></ul><p><strong>简单来说就是，一个图层的渲染是先生成一个layout布局，然后调用Stat的相关参数对数据进行变换，接着Geom使用变换后的数据进行绘制图形对象的数据准备工作。然后layout还会二次调整。最后Stat会有一个finish_layer函数在需要的情况下做进一步的数据变换。至此ggplot_built对此创建。</strong></p><p><strong>在ggplot_gtable的第一个环节就是调用Geom的图形对象绘制函数生成grob对象。</strong></p><p>所以一个图层的Stat和Geom其实是分别用于<strong>数据变换</strong>和<strong>图形绘制</strong>。</p><p>举个例子说明一下这两个对象的作用，绘制boxplot的时候，我们传入的数据是完整的数据，但是一个boxplot图上的图形元素却不是传入的数据的值，而是经过统计处理的值，比如Q1、中位数、Q3、最大值、最小值及异常值等等。</p><p>那么把传入的数据进行统计计算就是Stat的作用，根据Stat统计后的数据进行图形绘制（也就是点、线、面对象的生成）是Geom的作用。</p><p>所以为何geom_point是geom开头呢，因为它的stat是一个默认Stat对象，也就是不做数据变换的意思，而它的Geom对象是重写的GeomPoint对象，重点是Geom的作用，因此冠以geom开头。</p><p>而stat_chull图层的stat是StatChull对象，geom是多边形图形的绘制对象，这里它主要是为了强调数据变换，所以冠以stat开头。</p><p>但是必须强调的是geom开头还是stat开头只是一种命名的推荐范式，并不是强制的规范。</p><h3><span>一个图层的编写示例geom_whisker</span></h3><p>ggplot的boxplot图形的两侧须线没有横杠，可以编写一个图层添加两侧的须线，具体区别如图下：</p><figure><p><img data-ratio="0.36203703703703705" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/iaRJcrq2LosiciawXRVC4uZFSxJRphQlI9uEUvvaWKMxRwHQtrVDxhySliatsibIic3ZEIDxiaKez9hrtFp2Stz77T0yA/640?wx_fmt=jpeg" data-type="jpeg" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_jpg/iaRJcrq2LosiciawXRVC4uZFSxJRphQlI9uEUvvaWKMxRwHQtrVDxhySliatsibIic3ZEIDxiaKez9hrtFp2Stz77T0yA/640?wx_fmt=jpeg"></p><figcaption><br></figcaption></figure><p>先定义一个图层的框架，由于须线位置需要和boxplot的须线位置对应，因此Stat继续使用geom_boxplot的StatBoxplot对象即可，但是Geom对象需要重新定义，使用自己定义的GeomWhisker对象。</p><pre><code><span>library</span>(tidyverse)<br><br>geom_whisker &lt;-<br>  <span>function</span> (mapping = <span>NULL</span>,<br>            data = <span>NULL</span>,<br>            stat = <span>"boxplot"</span>, <span># &lt;--- stat保持默认 ---</span><br>            position = <span>"dodge2"</span>,<br>            whisker_width = <span>0.2</span>,<br>            <span>...</span>,<br>            na.rm = <span>FALSE</span>,<br>            orientation = <span>NA</span>,<br>            show.legend = <span>NA</span>,<br>            inherit.aes = <span>TRUE</span>){ <br>    <span>if</span> (is.character(position)) {<br>      position &lt;- position_dodge2(preserve = <span>"single"</span>)<br>    }<br><br>    layer(<br>      data = data,<br>      mapping = mapping,<br>      stat = stat,<br>      geom = GeomWhisker, <span># &lt;--- geom使用自定义的GeomWhisker ---</span><br>      position = position,<br>      show.legend = show.legend,<br>      inherit.aes = inherit.aes,<br>      params = list(<br>        na.rm = na.rm,<br>        orientation = orientation,<br>        whisker_width = whisker_width,<br>        <span>...</span><br>      )<br>    )<br>  }<br></code></pre><p>GeomWhisker对象的写法如下，绘制的图形对象是线段，主要的定义的是Geom对象的draw_group方法，返回值是使用grid::segmentsGrob函数生成的segmentsGrob绘图对象，绘制的线段的位置是由StatBoxplot变换而来的最大值和最大值决定的。在进行绘制前一定要使用coord的transform函数处理一下变换而来的data。</p><p>Geom的setup_data方法可以在绘制之前先处理一下数据，因为最大值和最小值只定义了线段的y坐标，没有定义线段的x坐标，所以x坐标可以根据width参数值在boxplot的x坐标两边均分，变为xmin和xmax用于segmentsGrob的绘制。</p><pre><code>GeomWhisker &lt;- ggproto(<br>  <span>"GeomWhisker"</span>,<br>  Geom,<br><br>  extra_params = c(<span>"na.rm"</span>, <span>"width"</span>, <span>"orientation"</span>),<br><br>  setup_params = <span>function</span>(data, params) {<br>    params$flipped_aes &lt;- has_flipped_aes(data, params)<br>    params$whisker_width &lt;- params$whisker_width/length(unique(data$group))<br><br>    params<br>  },<br>  setup_data = <span>function</span>(data, params){<br>    data$flipped_aes &lt;- params$flipped_aes<br><br>    data$xmin &lt;- data$x - data$width / <span>2</span><br>    data$xmax &lt;- data$x + data$width / <span>2</span><br><br>    flip_data(data, params$flipped_aes)<br>  },<br>  draw_group = <span>function</span>(data, panel_params, coord, whisker_width = <span>0.2</span>,  flipped_aes = <span>FALSE</span>) {<br>    data &lt;- flip_data(data, flipped_aes)<br>    <span>if</span> (nrow(data) != <span>1</span>) {<br>      abort(<span>"Can't draw more than one boxplot per group. Did you forget aes(group = ...)?"</span>)<br>    }<br>    coords &lt;-<br>      coord$transform(data, panel_params)<br>    common &lt;- list(<br>      colour = data$colour,<br>      size = data$size,<br>      linetype = data$linetype,<br>      fill = alpha(data$fill, data$alpha),<br>      group = data$group<br>    )<br><br>    new_data_frame &lt;- <span>function</span> (x = list(), n = <span>NULL</span>) {<br>      <span>if</span> (length(x) != <span>0</span> &amp;&amp; is.null(names(x))) {<br>        abort(<span>"Elements must be named"</span>)<br>      }<br>      lengths &lt;- vapply(x, length, integer(<span>1</span>))<br>      <span>if</span> (is.null(n)) {<br>        n &lt;- <span>if</span> (length(x) == <span>0</span> || min(lengths) == <span>0</span>) <span>0</span> <span>else</span> max(lengths)<br>      }<br>      <span>for</span> (i <span>in</span> seq_along(x)) {<br>        <span>if</span> (lengths[i] == n) <span>next</span><br>        <span>if</span> (lengths[i] != <span>1</span>) {<br>          abort(<span>"Elements must equal the number of rows or 1"</span>)<br>        }<br>        x[[i]] &lt;- rep(x[[i]], n)<br>      }<br>      class(x) &lt;- <span>"data.frame"</span><br>      attr(x, <span>"row.names"</span>) &lt;- .set_row_names(n)<br>      x<br>    }<br><br>    whiskers &lt;- new_data_frame(c(list(<br>      x = c(coords$x - whisker_width, coords$x - whisker_width),<br>      xend =  c(coords$x + whisker_width, coords$x + whisker_width),<br>      y = c(coords$ymin, coords$ymax),<br>      yend =  c(coords$ymin, coords$ymax),<br>      alpha = c(<span>NA_real_</span>, <span>NA_real_</span>)<br>    ),<br>    common), n = <span>2</span>)<br>    whiskers &lt;-<br>      flip_data(whiskers, flipped_aes)<br><br>    <span># print(whiskers)</span><br>    seg_grob &lt;-<br>      grid::segmentsGrob(<br>        x0 = whiskers$x,<br>        y0 = whiskers$y,<br>        x1 = whiskers$xend,<br>        y1 = whiskers$yend,<br>        default.units = <span>"npc"</span>,<br>        gp = grid::gpar(<br>          col = whiskers$colour,<br>          fill = alpha(whiskers$fill, whiskers$alpha),<br>          lwd = whiskers$size,<br>          lty = whiskers$linetype<br>        )<br>      )<br>    ggplot2:::ggname(<span>"geom_whisker"</span>, grid::grobTree(seg_grob))<br>  },<br><br>  default_aes = aes(<br>    colour = <span>"grey20"</span>,<br>    fill = <span>"white"</span>,<br>    size = <span>0.5</span>,<br>    alpha = <span>NA</span>,<br>    shape = <span>19</span>,<br>    linetype = <span>"solid"</span><br>  ),<br>  draw_key = draw_key_path,<br>  required_aes = c(<br>  )<br>)<br></code></pre><p>使用起来就比较简单了，它还可以支持自定义线宽、线性、左右宽度、颜色等参数。</p><pre><code>p &lt;-<br>  iris %&gt;%<br>  mutate(group = as.character(sample(<span>1</span>:<span>3</span>, <span>150</span>, replace = <span>TRUE</span>))) %&gt;%<br>  ggplot(aes(x = Species, y = Sepal.Width, fill = Species, color = group)) +<br>  geom_boxplot() +<br>  geom_whisker(<br>    aes(color = group),<br>    whisker_width = <span>0.3</span>, <br>    size = <span>5</span>, <br>    linetype = <span>1</span>, <br>    show.legend = <span>F</span><br>  )<br>p</code></pre><p><img data-ratio="0.7247863247863248" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/iaRJcrq2LosiciawXRVC4uZFSxJRphQlI9uYmrSZ8qjLSBjUefaMTdrJ7CcUTEqhaxuqJSFN27Ho6gJ9GI6wOx4jg/640?wx_fmt=jpeg" data-type="jpeg" data-w="585" src="https://mmbiz.qpic.cn/mmbiz_jpg/iaRJcrq2LosiciawXRVC4uZFSxJRphQlI9uYmrSZ8qjLSBjUefaMTdrJ7CcUTEqhaxuqJSFN27Ho6gJ9GI6wOx4jg/640?wx_fmt=jpeg"></p><p><br></p><h4 data-tool="mdnice编辑器"><span><strong>文末友情宣传</strong></span></h4><p data-tool="mdnice编辑器">强烈建议你推荐给身边的博士后以及年轻生物学PI，多一点数据认知，让他们的科研上一个台阶：</p><ul data-tool="mdnice编辑器"><li><section><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247524240&amp;idx=1&amp;sn=94c9ef8c3d8080c30c8372d4fb5999ab&amp;chksm=9b4bdf2bac3c563def9232bb78f43bcaa13d7c3442b00cf83aaa32ae98f4500883fa8803fb98&amp;scene=21#wechat_redirect" textvalue="生物信息学马拉松授课（买一‍得五）" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2" hasload="1"><span>生物信息学马拉松授课（买一得五）</span></a><span> ，你的生物信息学入门课</span></section></li><li><section><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247524148&amp;idx=1&amp;sn=7806da6feb41a36493c519c1cfc1d3ac&amp;chksm=9b4bdf8fac3c569960369602f1ef26639cb366b250f233b2297d1f059471c0458335bfc0b829&amp;scene=21#wechat_redirect" textvalue="时隔5年，我们的生信技能树VIP学徒继续招生啦" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2" hasload="1"><span>时隔5年，我们的生信技能树VIP学徒继续招生啦</span></a><br></section></li><li><section><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247522831&amp;idx=2&amp;sn=1744efdf428465425a145ff3a982198b&amp;chksm=9b4bdab4ac3c53a28fbecbbff4f254f470b54a7a20468bb753b295b930315e1ec45bcbabc10b&amp;scene=21#wechat_redirect" textvalue="144线程640Gb内存服务器共享一年‍仍然是仅需800" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2" hasload="1"><span>144线程640Gb内存服务器共享一年仍然是仅需800</span></a></section></li><li><section><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247519765&amp;idx=1&amp;sn=ce5a8c8182f854c88043059f8c2cb9ff&amp;chksm=9b4bceaeac3c47b88c19941d43dbb1401f3a92206481a0afc41159927868199643f795d62a7e&amp;scene=21#wechat_redirect" textvalue="千呼万唤始出来的独享生物信息学云服务器" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2" hasload="1"><span>千呼万唤始出来的独享生物信息学云服务器</span></a></section></li><li><section><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247519765&amp;idx=1&amp;sn=ce5a8c8182f854c88043059f8c2cb9ff&amp;chksm=9b4bceaeac3c47b88c19941d43dbb1401f3a92206481a0afc41159927868199643f795d62a7e&amp;scene=21#wechat_redirect" textvalue="千呼万唤始出来的独享生物信息学云服务器" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2" hasload="1"></a><a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247524275&amp;idx=1&amp;sn=fa592ee29f636f34387491d0fceadd8e&amp;chksm=9b4bdf08ac3c561e0881974b3817beb0a0e514dc1a8df4c34c2b6653da6fa78e09acb03c70c2&amp;scene=21#wechat_redirect" textvalue="生信技能树知识整理实习生又又又开放申请啦" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2" hasload="1"><span>生信技能树知识整理实习生又又又开放申请啦</span><span></span></a></section></li></ul><p><mp-style-type data-value="10000"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/Ny-Z0pFNaXbaKtnFAQZ-ew",target="_blank" rel="noopener noreferrer">原文链接</a>
