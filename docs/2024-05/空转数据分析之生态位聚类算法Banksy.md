---
title: "空转数据分析之生态位聚类算法Banksy"
date: 2024-05-05T01:09:01Z
draft: ["false"]
tags: [
  "fetched",
  "生信随笔"
]
categories: ["Acdemic"]
---
空转数据分析之生态位聚类算法Banksy by 生信随笔
------
<div><section data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><p data-tool="mdnice编辑器">传统的单细胞聚类算法，例如Seurat和Scanpy Pipeline中的Louvain和Leiden等聚类算法，通常在处理空间数据时忽略了空间信息。然而，由于细胞状态受其周围细胞的影响，将转录组数据与细胞的空间信息结合起来进行聚类分析，将更有助于揭示细胞在组织中的分布和相互作用。</p><p data-tool="mdnice编辑器">2024年2月，来自Shyam Prabhakar 和Kok Hao Chen研究团队的Vipul Singhal、Nigel Chou和Joseph Lee等人在<em><strong>Nature Genetics</strong></em>上发表了一篇题为《BANKSY unifies cell typing and tissue domain segmentation for scalable spatial omics data analysis》（https://www.nature.com/articles/s41588-024-01664-3）的研究文章。这项工作开发了一种名为<strong>BANKSY</strong>的空间聚类算法。BANKSY可通过结合细胞/Spots的转录组信息和其局部微环境信息，显著提升空间组学数据分析的准确性和效率。BANKSY算法不仅能够处理大规模数据集，提高细胞类型聚类和组织域分割的性能，还展现了在多种RNA和蛋白质数据集上的广泛适用性。</p><p data-tool="mdnice编辑器">具体来说，BANKSY是一种聚类空间组学数据的方法，通过将每个细胞的特征与其空间近邻特征的平均值以及邻域特征梯度相结合来增强。通过将邻域信息纳入聚类中，BANKSY能够：</p><ul data-tool="mdnice编辑器"><li><section>在嘈杂的数据中改善细胞/Spots类型分配；</section></li><li><section>区分微环境分层的微妙不同细胞/Spots类型；</section></li><li><section>确定共享相同微环境的空间域。</section></li></ul><p data-tool="mdnice编辑器">BANKSY官方教程详见：</p><ul data-tool="mdnice编辑器"><li><section>github：https://github.com/prabhakarlab/Banksy/</section></li><li><section>R语言版本：https://prabhakarlab.github.io/Banksy/</section></li><li><section>Python版本：https://github.com/prabhakarlab/Banksy_py</section></li></ul><h3 data-tool="mdnice编辑器"><span>一. BANKSY算法的工作流程</span></h3><figure data-tool="mdnice编辑器"><img data-imgfileid="100004541" data-ratio="0.9462962962962963" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTr38nyia7E2uV7f0GphVh5Ol75dL7S9YdfREEiaQ89kHMpJNgOLJ9CLMLw/640?wx_fmt=other&amp;from=appmsg" data-type="other" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTr38nyia7E2uV7f0GphVh5Ol75dL7S9YdfREEiaQ89kHMpJNgOLJ9CLMLw/640?wx_fmt=other&amp;from=appmsg"><figcaption>Fig. 1</figcaption></figure><p data-tool="mdnice编辑器">图例：<strong>a</strong>, The original gene–cell expression matrix (purple) was augmented with neighborhood-averaged expression matrices corresponding to the mean local expression (dark pink) and the AGF (light pink). Here, <em>λ</em> is a mixing parameter that controls the importance of cells’ own expression and neighborhood expression effects, <em>G</em>(<em>r</em>) is a radially symmetric Gaussian kernel that decays from magnitude 1 at <em>r</em> = 0, ‘expression’ refers to each gene’s expression level in each cell, the mean is taken over cells in the respective index cell’s neighborhood and the <em>e<strong>i</strong>ϕ**G</em>(<em>r</em>) term confers gradient sensitivity to the AGF. <strong>b</strong>, Heatmap of the real and imaginary components of a gradient-sensitive AGF kernel. The plots show an unnormalized AGF kernel: the real part (cos⁡(𝜙)) senses the gradient along the <em>x</em> axis and the imaginary part (sin⁡(𝜙)) senses the gradient along the <em>y</em> axis. <strong>c</strong>, Simplified schematic of two distinct cell types in the neighbor-augmented space. The neighbor expression features, representing the local microenvironment, help to separate two clusters that would be difficult to separate based on the cells’ own expression alone. For simplicity, we show ‘pure’ microenvironments containing only a single cell type (cell type 1 in zone A and cell type 2 in zone B), although BANKSY is equally applicable to heterogeneous microenvironments containing mixtures of cell types (Extended Data Fig. 1).</p><p data-tool="mdnice编辑器"><strong>一种空间聚类的策略是将细胞的空间坐标附加到它们的基因表达向量中</strong>。然而，这会导致空间上相距较远的细胞分入不同的聚类中，即使它们具有相同的转录组。<strong>一种更直观的方法是附加某种表示细胞微环境的表示</strong>。<strong>BANKSY算法</strong>采用平均邻域表达和AGF<strong>（图1a,1b）</strong>来代表每个细胞周围的转录组微环境<strong>。</strong>重要的是，AGF（图1b）可以被视为衡量每个细胞邻域内基因表达梯度，对样本旋转是不变的。接下来，这些<strong>额外的特征</strong>被用来将细胞嵌入到一个邻域增强的乘积空间中（图1c）。经过降维处理，然后在结果嵌入空间中构建图形，可以使用任何图划分算法进行聚类。默认情况下，BANKSY使用Leiden社区检测算法，因为其速度和可扩展性，虽然也提供了其他方法（Louvain、基于模型的聚类和k-means）作为选项。</p><p data-tool="mdnice编辑器"><strong>为了控制细胞自身和邻域特征对嵌入中细胞-细胞距离的相对贡献</strong>，BANKSY使用一个混合参数，<strong>λ</strong>∈ [0, 1]，来权衡细胞转录组矩阵和邻域表达矩阵（平均值和AGF；图1）的贡献。较小的λ设置强调细胞自身的转录组，因此导致细胞根据细胞类型进行聚类。在极限情况下，当λ = 0时，BANKSY简化为传统的非空间聚类。通过增加λ，增加邻域签名的影响，可以将BANKSY从细胞类型聚类模式切换到组织域分割模式，导致细胞根据组织域进行聚类。</p><blockquote data-tool="mdnice编辑器"><p>引用自【<a href="https://mp.weixin.qq.com/s?__biz=MzkwOTQwOTE4OA==&amp;mid=2247486914&amp;idx=1&amp;sn=98e4409fb89ebc8642f27d63e97a0ca0&amp;scene=21#wechat_redirect" data-linktype="2">Nat.Genet. | BANKSY：基于邻域核和空间组学的可扩展分析算法统一细胞分型和组织域分割，解析局部微环境</a>】</p><p>详见NG文章的结果和方法部分：https://www.nature.com/articles/s41588-024-01664-3</p></blockquote><h3 data-tool="mdnice编辑器"><span>二. BANKSY的R代码实现</span></h3><h4 data-tool="mdnice编辑器"><span>Step0. R包安装</span></h4><p data-tool="mdnice编辑器">BANKSY对R语言版本要求比较高：</p><ul data-tool="mdnice编辑器"><li><section>教程要求R语言版本 <code>&gt;= 4.4.0</code></section></li></ul><pre data-tool="mdnice编辑器"><span></span><code><span>#BiocManager::install("SpatialExperiment")</span><br>BiocManager::install(<span>'Banksy'</span>)<br></code></pre><ul data-tool="mdnice编辑器"><li><section>如果R版本是<code>4.3.0</code>的可以通过github安装（https://github.com/prabhakarlab/Banksy/issues/13）</section></li></ul><pre data-tool="mdnice编辑器"><span></span><code><span>#BiocManager::install("SpatialExperiment")</span><br>remotes::install_github(<span>"prabhakarlab/Banksy"</span>)<br></code></pre><p data-tool="mdnice编辑器">官方教程提供了快速测试的代码（https://prabhakarlab.github.io/Banksy/index.html）：</p><h4 data-tool="mdnice编辑器"><span>Step1. 加载R包和示例数据</span></h4><pre data-tool="mdnice编辑器"><span></span><code><span>library</span>(Banksy)<br><br><span>library</span>(SummarizedExperiment)<br><span>library</span>(SpatialExperiment)<br><span>library</span>(scuttle)<br><br><span>library</span>(scater)<br><span>library</span>(cowplot)<br><span>library</span>(ggplot2)<br></code></pre><p data-tool="mdnice编辑器">测试数据是经典的小鼠海马10X visium空转数据。</p><pre data-tool="mdnice编辑器"><span></span><code>data(hippocampus)<br>gcm &lt;- hippocampus$expression<br>gcm[<span>1</span>:<span>10</span>, <span>1</span>:<span>10</span>]<br>locs &lt;- as.matrix(hippocampus$locations)<br></code></pre><p data-tool="mdnice编辑器">Banksy需要用户将数据转化为SpatialExperiment对象：</p><pre data-tool="mdnice编辑器"><span></span><code>se &lt;- SpatialExperiment(assay = list(counts = gcm), <br>                        spatialCoords = locs)<br></code></pre><h4 data-tool="mdnice编辑器"><span>Step2. 质控和标准化分析</span></h4><blockquote data-tool="mdnice编辑器"><p>这里如果已经走过Seurat的质控流程，可以跳过QC部分。</p></blockquote><pre data-tool="mdnice编辑器"><span></span><code><span># QC based on total counts</span><br>qcstats &lt;- perCellQCMetrics(se)<br>thres &lt;- quantile(qcstats$total, c(<span>0.05</span>, <span>0.98</span>))<br>keep &lt;- (qcstats$total &gt; thres[<span>1</span>]) &amp; (qcstats$total &lt; thres[<span>2</span>])<br>se &lt;- se[, keep]<br><br><span># Normalization to mean library size</span><br>se &lt;- computeLibraryFactors(se)<br>aname &lt;- <span>"normcounts"</span><br>assay(se, aname) &lt;- normalizeCounts(se, log = <span>FALSE</span>)<br></code></pre><h4 data-tool="mdnice编辑器"><span>Step3. 计算BANKSY的邻域矩阵</span></h4><p data-tool="mdnice编辑器">设置<code>compute_agf=TRUE</code>计算加权邻域平均值（ℳ）和方位Gabor滤波器（𝒢）。用于计算ℳ和𝒢的空间近邻个数分别为<code>k_geom[1]=15</code>和<code>k_geom[2]=30</code>。我们在<code>lambda=0</code>处运行BANKSY，对应于非空间聚类;<code>lambda=0.2</code>对应于BANKSY空间细胞聚类。</p><pre data-tool="mdnice编辑器"><span></span><code>lambda &lt;- c(<span>0</span>, <span>0.2</span>)<br>k_geom &lt;- c(<span>15</span>, <span>30</span>)<br><br>se &lt;- Banksy::computeBanksy(se, assay_name = aname, compute_agf = <span>TRUE</span>, k_geom = k_geom)<br></code></pre><h4 data-tool="mdnice编辑器"><span>Step4. PCA、降维和聚类</span></h4><p data-tool="mdnice编辑器">接下来，在BANKSY矩阵上运行PCA并运行聚类。设置<code>use_agf=TRUE</code>使用ℳ和𝒢构建BANKSY矩阵。</p><pre data-tool="mdnice编辑器"><span></span><code>set.seed(<span>1000</span>)<br>se &lt;- Banksy::runBanksyPCA(se, use_agf = <span>TRUE</span>, lambda = lambda)<br>se &lt;- Banksy::runBanksyUMAP(se, use_agf = <span>TRUE</span>, lambda = lambda)<br>se &lt;- Banksy::clusterBanksy(se, use_agf = <span>TRUE</span>, lambda = lambda, resolution = <span>1.2</span>)<br></code></pre><p data-tool="mdnice编辑器">可以使用<code>connectClusters</code>函数将不同的聚类结果重新标记，以最小化它们之间的差异。</p><pre data-tool="mdnice编辑器"><span></span><code>se &lt;- Banksy::connectClusters(se)<br><span>#&gt; clust_M1_lam0.2_k50_res1.2 --&gt; clust_M1_lam0_k50_res1.2</span><br></code></pre><h4 data-tool="mdnice编辑器"><span>Step5. 可视化</span></h4><p data-tool="mdnice编辑器">可视化非空间聚类<code>(lambda=0)</code>和BANKSY聚类<code>(lambda=0.2)</code>的聚类结果：</p><pre data-tool="mdnice编辑器"><span></span><code>cnames &lt;- colnames(colData(se))<br>cnames &lt;- cnames[grep(<span>"^clust"</span>, cnames)]<br>colData(se) &lt;- cbind(colData(se), spatialCoords(se))<br><br>plot_nsp &lt;- plotColData(se,<br>    x = <span>"sdimx"</span>, y = <span>"sdimy"</span>,<br>    point_size = <span>0.6</span>, colour_by = cnames[<span>1</span>]<br>)<br>plot_bank &lt;- plotColData(se,<br>    x = <span>"sdimx"</span>, y = <span>"sdimy"</span>,<br>    point_size = <span>0.6</span>, colour_by = cnames[<span>2</span>]<br>)<br><br><br>plot_grid(plot_nsp + coord_equal(), plot_bank + coord_equal(), ncol = <span>2</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-imgfileid="100004539" data-ratio="0.35714285714285715" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTrJkmvwkjjWHPTRUcqK1VWIialnPlgpHQCOkECp64HASHVl1HEtUIcexA/640?wx_fmt=other&amp;from=appmsg" data-type="other" data-w="980" src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTrJkmvwkjjWHPTRUcqK1VWIialnPlgpHQCOkECp64HASHVl1HEtUIcexA/640?wx_fmt=other&amp;from=appmsg"></figure><p data-tool="mdnice编辑器">我们还可以分别可视化每个亚群：</p><pre data-tool="mdnice编辑器"><span></span><code>plot_grid(<br>    plot_nsp + facet_wrap(~colour_by),<br>    plot_bank + facet_wrap(~colour_by),<br>    ncol = <span>2</span><br>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-imgfileid="100004540" data-ratio="0.4444444444444444" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTrQWSdbDohEbmXPmwKyXic0icMGviaT7DlpA7DqV56aaMiaHjhMicoeD4fxzg/640?wx_fmt=other&amp;from=appmsg" data-type="other" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTrQWSdbDohEbmXPmwKyXic0icMGviaT7DlpA7DqV56aaMiaHjhMicoeD4fxzg/640?wx_fmt=other&amp;from=appmsg"></figure><p data-tool="mdnice编辑器">可视化比较非空间和BANKSY的umap结果：</p><pre data-tool="mdnice编辑器"><span></span><code>rdnames &lt;- reducedDimNames(se)<br><br>umap_nsp &lt;- plotReducedDim(se,<br>    dimred = grep(<span>"UMAP.*lam0$"</span>, rdnames, value = <span>TRUE</span>),<br>    colour_by = cnames[<span>1</span>]<br>)<br>umap_bank &lt;- plotReducedDim(se,<br>    dimred = grep(<span>"UMAP.*lam0.2$"</span>, rdnames, value = <span>TRUE</span>),<br>    colour_by = cnames[<span>2</span>]<br>)<br>plot_grid(<br>    umap_nsp,<br>    umap_bank,<br>    ncol = <span>2</span><br>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-imgfileid="100004537" data-ratio="0.35714285714285715" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTriaXNz1uxZtyVehKUfE9VU1pTTm2jqHFa9hDkjqFOQ7lJXUk2JWhD3cw/640?wx_fmt=other&amp;from=appmsg" data-type="other" data-w="980" src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTriaXNz1uxZtyVehKUfE9VU1pTTm2jqHFa9hDkjqFOQ7lJXUk2JWhD3cw/640?wx_fmt=other&amp;from=appmsg"><figcaption>img</figcaption></figure><h3 data-tool="mdnice编辑器"><span>三. BANKSY的函数和关键参数</span></h3><h4 data-tool="mdnice编辑器"><span>3.1 R包BANKSY封装的函数</span></h4><section data-tool="mdnice编辑器"><table><thead><tr><th>Neighborhood matrix computation</th><th>Annotation</th></tr></thead><tbody><tr><td><code>computeBanksy()</code></td><td>Compute the component neighborhood matrices for the BANKSY matrix.</td></tr><tr><td><code>getBanksyMatrix()</code></td><td>Builds the BANKSY matrix from neighborhood matrices.</td></tr><tr><td><strong>Dimensionality reduction</strong></td><td><br></td></tr><tr><td><code>runBanksyPCA()</code></td><td>Run PCA on a BANKSY matrix.</td></tr><tr><td><code>runBanksyUMAP()</code></td><td>Run UMAP on a BANKSY embedding.</td></tr><tr><td><strong>Clustering</strong></td><td><br></td></tr><tr><td><code>clusterBanksy()</code></td><td>Perform clustering in BANKSY's neighborhood-augmented feature space.</td></tr><tr><td><code>connectClusters()</code></td><td>Relabel cluster labels across parameter runs to maximise their similarity.</td></tr><tr><td><code>compareClusters()</code></td><td>Compare cluster outputs based on various clustering comparison measures.</td></tr><tr><td><code>smoothLabels()</code></td><td>k-Nearest neighbor cluster label smoothing.</td></tr><tr><td><code>clusterNames()</code></td><td>Get names of clustering runs.</td></tr><tr><td><strong>Datasets</strong></td><td><br></td></tr><tr><td><code>hippocampus</code></td><td>Mouse Hippocampus VeraFISH data</td></tr><tr><td><code>rings</code></td><td>An unrealistic simulation of spatially-resolved omics data.</td></tr><tr><td><strong>Misc.</strong></td><td><br></td></tr><tr><td><code>simulateDataset()</code></td><td>Simulate an unrealistic spatial omics dataset.</td></tr></tbody></table></section><h4 data-tool="mdnice编辑器"><span>3.2 相关函数的关键参数</span></h4><p data-tool="mdnice编辑器">BANKSY的核心函数有一些关键参数，在这里作者做了详细的介绍（https://prabhakarlab.github.io/Banksy/articles/parameter-selection.html）：</p><h5 data-tool="mdnice编辑器"><span>3.2.1 <code>computeBanksy()</code>:</span></h5><pre data-tool="mdnice编辑器"><span></span><code>k_geom &lt;- c(<span>15</span>, <span>30</span>)<br>se &lt;- computeBanksy(se, assay_name = aname, compute_agf = <span>TRUE</span>, k_geom = k_geom)<br></code></pre><ul data-tool="mdnice编辑器"><li><section><p><strong>AGF usage</strong>: For characterising neighborhoods, <em>BANKSY</em> computes the weighted neighborhood mean (<code>H_0</code>) and the azimuthal Gabor filter (<code>H_1</code>), which estimates gene expression gradients. Setting <code>compute_agf=TRUE</code> computes both <code>H_0</code> and <code>H_1</code>.</p></section></li><li><section><p><strong>k-geometric</strong>: <code>k_geom</code> specifies the number of neighbors used to compute each <code>H_m</code> for <code>m=0,1</code>. If a single value is specified, the same <code>k_geom</code> will be used for each feature matrix. Alternatively, multiple values of <code>k_geom</code> can be provided for each feature matrix. Here, we use <code>k_geom[1]=15</code> and <code>k_geom[2]=30</code> for <code>H_0</code> and <code>H_1</code> respectively. More neighbors are used to compute gradients.</p></section></li></ul><p data-tool="mdnice编辑器"><code>computeBanksy</code> populates the <code>assays</code> slot with <code>H_0</code> and <code>H_1</code> in this instance:</p><pre data-tool="mdnice编辑器"><span></span><code>se<br><span>#&gt; class: SpatialExperiment </span><br><span>#&gt; dim: 120 10205 </span><br><span>#&gt; metadata(1): BANKSY_params</span><br><span>#&gt; assays(4): counts normcounts H0 H1</span><br><span>#&gt; rownames(120): Sparcl1 Slc1a2 ... Notch3 Egfr</span><br><span>#&gt; rowData names(0):</span><br><span>#&gt; colnames(10205): cell_1276 cell_691 ... cell_11635 cell_10849</span><br><span>#&gt; colData names(4): sample_id sdimx sdimy sizeFactor</span><br><span>#&gt; reducedDimNames(0):</span><br><span>#&gt; mainExpName: NULL</span><br><span>#&gt; altExpNames(0):</span><br><span>#&gt; spatialCoords names(2) : sdimx sdimy</span><br><span>#&gt; imgData names(1): sample_id</span><br></code></pre><h5 data-tool="mdnice编辑器"><span>3.2.2 <code>runBanksyPCA()</code></span></h5><pre data-tool="mdnice编辑器"><span></span><code>lambda &lt;- c(<span>0</span>, <span>0.2</span>)<br>se &lt;- runBanksyPCA(se, use_agf = c(<span>FALSE</span>, <span>TRUE</span>), lambda = lambda, seed = <span>1000</span>)<br><span>#&gt; Using seed=1000</span><br><span>#&gt; Using seed=1000</span><br><span>#&gt; Using seed=1000</span><br><span>#&gt; Using seed=1000</span><br></code></pre><p data-tool="mdnice编辑器">The <code>lambda</code> parameter is a mixing parameter in <code>[0,1]</code> which determines how much spatial information is incorporated for downstream analysis. With smaller values of <code>lambda</code>, BANKY operates in <em>cell-typing</em> mode, while at higher levels of <code>lambda</code>, BANKSY operates in <em>domain-finding</em> mode. As a starting point, we recommend <code>lambda=0.2</code> for cell-typing and <code>lambda=0.8</code> for zone-finding. Here, we run <code>lambda=0</code> which corresponds to non-spatial clustering, and <code>lambda=0.2</code> for spatially-informed cell-typing. We compute PCs with and without the AGF (<code>H_1</code>).</p><p data-tool="mdnice编辑器"><code>runBanksyPCA</code> populates the <code>reducedDims</code> slot, with each combination of <code>use_agf</code> and <code>lambda</code> provided.</p><pre data-tool="mdnice编辑器"><span></span><code>reducedDimNames(se)<br><span>#&gt; [1] "PCA_M0_lam0"   "PCA_M0_lam0.2" "PCA_M1_lam0"   "PCA_M1_lam0.2"</span><br></code></pre><h5 data-tool="mdnice编辑器"><span>3.2.3 <code>clusterBanksy()</code>聚类参数</span></h5><p data-tool="mdnice编辑器">Next, we cluster the BANKSY embedding with Leiden graph-based clustering. This admits two parameters: <code>k_neighbors</code> and <code>resolution</code>. <code>k_neighbors</code> determines the number of k nearest neighbors used to construct the shared nearest neighbors graph. Leiden clustering is then performed on the resultant graph with resolution <code>resolution</code>. For reproducibiltiy we set a seed for each parameter combination.</p><pre data-tool="mdnice编辑器"><span></span><code>k &lt;- <span>50</span><br>res &lt;- <span>1</span><br>se &lt;- clusterBanksy(se, use_agf = c(<span>FALSE</span>, <span>TRUE</span>), lambda = lambda, k_neighbors = k, resolution = res, seed = <span>1000</span>)<br><span>#&gt; Using seed=1000</span><br><span>#&gt; Using seed=1000</span><br><span>#&gt; Using seed=1000</span><br><span>#&gt; Using seed=1000</span><br></code></pre><p data-tool="mdnice编辑器"><code>clusterBanksy</code> populates <code>colData(se)</code> with cluster labels:</p><pre data-tool="mdnice编辑器"><span></span><code>colnames(colData(se))<br><span>#&gt; [1] "sample_id"                "sdimx"                   </span><br><span>#&gt; [3] "sdimy"                    "sizeFactor"              </span><br><span>#&gt; [5] "clust_M0_lam0_k50_res1"   "clust_M0_lam0.2_k50_res1"</span><br><span>#&gt; [7] "clust_M1_lam0_k50_res1"   "clust_M1_lam0.2_k50_res1"</span><br></code></pre><p data-tool="mdnice编辑器"><strong>Comparing cluster results</strong></p><p data-tool="mdnice编辑器">To compare clustering runs visually, different runs can be relabeled to minimise their differences with <code>connectClusters</code>:</p><pre data-tool="mdnice编辑器"><span></span><code>se &lt;- connectClusters(se)<br><span>#&gt; clust_M1_lam0_k50_res1 --&gt; clust_M0_lam0_k50_res1</span><br><span>#&gt; clust_M0_lam0.2_k50_res1 --&gt; clust_M1_lam0_k50_res1</span><br><span>#&gt; clust_M1_lam0.2_k50_res1 --&gt; clust_M0_lam0.2_k50_res1</span><br></code></pre><p data-tool="mdnice编辑器">Visualise spatial coordinates with cluster labels.</p><pre data-tool="mdnice编辑器"><span></span><code>cnames &lt;- colnames(colData(se))<br>cnames &lt;- cnames[grep(<span>"^clust"</span>, cnames)]<br>cplots &lt;- lapply(cnames, <span>function</span>(cnm) {<br>    plotColData(se, x = <span>"sdimx"</span>, y = <span>"sdimy"</span>, point_size = <span>0.1</span>, colour_by = cnm) +<br>        coord_equal() +<br>        labs(title = cnm) +<br>        theme(legend.title = element_blank()) +<br>        guides(colour = guide_legend(override.aes = list(size = <span>2</span>)))<br>})<br><br>plot_grid(plotlist = cplots, ncol = <span>2</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-imgfileid="100004538" data-ratio="0.96" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTrjLr46I1pORSGWMvzIqRu7KTsOtA3lRicBkLla8HiaJibibkLdaTsWSEqHg/640?wx_fmt=other&amp;from=appmsg" data-type="other" data-w="525" src="https://mmbiz.qpic.cn/mmbiz_jpg/fTW9zRI3eqUffobfsLtm11jVN9MLsqTrjLr46I1pORSGWMvzIqRu7KTsOtA3lRicBkLla8HiaJibibkLdaTsWSEqHg/640?wx_fmt=other&amp;from=appmsg"></figure><p data-tool="mdnice编辑器">Compare all cluster outputs with <code>compareClusters</code>. This function computes pairwise cluster comparison metrics between the clusters in <code>colData(se)</code> based on adjusted Rand index (ARI):</p><pre data-tool="mdnice编辑器"><span></span><code>compareClusters(se, func = <span>"ARI"</span>)<br><span>#&gt;                          clust_M0_lam0_k50_res1 clust_M0_lam0.2_k50_res1</span><br><span>#&gt; clust_M0_lam0_k50_res1                    1.000                     0.67</span><br><span>#&gt; clust_M0_lam0.2_k50_res1                  0.670                     1.00</span><br><span>#&gt; clust_M1_lam0_k50_res1                    1.000                     0.67</span><br><span>#&gt; clust_M1_lam0.2_k50_res1                  0.747                     0.87</span><br><span>#&gt;                          clust_M1_lam0_k50_res1 clust_M1_lam0.2_k50_res1</span><br><span>#&gt; clust_M0_lam0_k50_res1                    1.000                    0.747</span><br><span>#&gt; clust_M0_lam0.2_k50_res1                  0.670                    0.870</span><br><span>#&gt; clust_M1_lam0_k50_res1                    1.000                    0.747</span><br><span>#&gt; clust_M1_lam0.2_k50_res1                  0.747                    1.000</span><br></code></pre><p data-tool="mdnice编辑器">or normalized mutual information (NMI):</p><pre data-tool="mdnice编辑器"><span></span><code>compareClusters(se, func = <span>"NMI"</span>)<br><span>#&gt;                          clust_M0_lam0_k50_res1 clust_M0_lam0.2_k50_res1</span><br><span>#&gt; clust_M0_lam0_k50_res1                    1.000                    0.741</span><br><span>#&gt; clust_M0_lam0.2_k50_res1                  0.741                    1.000</span><br><span>#&gt; clust_M1_lam0_k50_res1                    1.000                    0.741</span><br><span>#&gt; clust_M1_lam0.2_k50_res1                  0.782                    0.915</span><br><span>#&gt;                          clust_M1_lam0_k50_res1 clust_M1_lam0.2_k50_res1</span><br><span>#&gt; clust_M0_lam0_k50_res1                    1.000                    0.782</span><br><span>#&gt; clust_M0_lam0.2_k50_res1                  0.741                    0.915</span><br><span>#&gt; clust_M1_lam0_k50_res1                    1.000                    0.782</span><br><span>#&gt; clust_M1_lam0.2_k50_res1                  0.782                    1.000</span><br></code></pre><p data-tool="mdnice编辑器">See <code>?compareClusters</code> for the full list of comparison measures.</p><h3 data-tool="mdnice编辑器"><span>四. 总结</span></h3><p data-tool="mdnice编辑器">相较于传统的单细胞/空转聚类算法，<strong>BANKSY</strong>在细胞/Spots的表达矩阵的基础上，进一步联合了空间坐标信息，这种策略能够有效提高细胞/Spots分类的准确性和效率，进而揭示细胞间的相互作用和微环境影响。此外，BANKSY在处理大规模数据集时运行速度非常快，且兼容多样本分析以及传统的整合分析算法如Harmony。最后，BANKSY适<span>用于</span>多种<span>空间</span>数据类型<span>（例如 10x Visium、Slide-seq、MERFISH、CosMX、CODEX</span><span>）</span><span>，当然</span>也适合最新的<a target="_blank" href="https://mp.weixin.qq.com/s?__biz=MzUzMTEwODk0Ng==&amp;mid=2247520976&amp;idx=1&amp;sn=8a03a261e67bb11fa6b22c6853e234d9&amp;scene=21#wechat_redirect" textvalue="10X Visium HD" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2">10X Visium HD</a>空转数据~</p><p data-tool="mdnice编辑器">下面是来自推文【<a href="https://mp.weixin.qq.com/s?__biz=MzkwOTQwOTE4OA==&amp;mid=2247486914&amp;idx=1&amp;sn=98e4409fb89ebc8642f27d63e97a0ca0&amp;scene=21#wechat_redirect" data-linktype="2">Nat.Genet. | BANKSY：基于邻域核和空间组学的可扩展分析算法统一细胞分型和组织域分割，解析局部微环境</a>】的点评：</p><blockquote data-tool="mdnice编辑器"><p>BANKSY算法的核心理念，即一个细胞的状态和功能可以通过其所处的微环境来更准确地识别，启发了未来算法开发的方向。在很多生物学研究中，细胞的空间位置对其功能的影响是不可忽视的，而BANKSY通过将空间邻域描述符与细胞自身的基因表达向量相结合，提供了一种全新的视角来理解细胞在组织中的角色。此外，BANKSY的可扩展性和对参数变化的鲁棒性，也为处理大规模空间组学数据集提供了有效的解决方案。这种将生物信息学与机器学习技术相结合的方法，不仅为空间组学数据分析提供了新的工具，也为未来在其他组学数据分析中整合不同类型信息提供了可能的方向。这种跨学科的融合，特别是在生物学和计算科学之间的交叉，将是推动生命科学研究进步的关键。</p></blockquote></section><p><br></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/VhLW5J326GAHIv-gBWIZng",target="_blank" rel="noopener noreferrer">原文链接</a>
