---
title: "单细胞蛋白质活性推断（PISCES）Pipeline"
date: 2023-02-04T07:21:46Z
draft: ["false"]
tags: [
  "fetched",
  "生信随笔"
]
categories: ["Acdemic"]
---
单细胞蛋白质活性推断（PISCES）Pipeline by 生信随笔
------
<div><section data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><p data-tool="mdnice编辑器">文章发表在：</p><ul data-tool="mdnice编辑器"><li><section>NC https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5902599/</section></li><li><section>预印本 https://www.biorxiv.org/content/10.1101/2021.05.20.445002v4</section></li><li><section>Cell https://www.sciencedirect.com/science/article/pii/S0092867421005730</section></li></ul><p data-tool="mdnice编辑器">Github:</p><ul data-tool="mdnice编辑器"><li><section><p>新版：https://github.com/califano-lab/PISCES</p></section></li><li><section><p>旧版：califano-lab/single-cell-pipeline https://github.com/califano-lab/single-cell-pipeline</p></section></li><li><section><p>ARACNe-AP https://github.com/califano-lab/ARACNe-AP/blob/master/README.md</p></section></li></ul><p data-tool="mdnice编辑器"><strong>PISCES的用途：</strong></p><ul data-tool="mdnice编辑器"><li><section>单细胞蛋白活性推断（The pipeline for Protein Activity Inference in Single Cells，PISCES）是基于网络调控分析单细胞基因表达谱的方法。PISCES将高可变性的、表达谱数据伴有技术噪音的单细胞测序数据转换为稳定且可重复性良好的蛋白活性表达谱。PISCES主要基于两个算法：</section></li><ul><li><section>精确的细胞网络重构算法ARACNe；</section></li><li><section>基于富集调控分析对蛋白质活性虚拟推断算法metaVIPER。</section></li></ul><li><section>ARACNe算法是应用最广泛的一种基于基因表达数据推断转录交互作用的算法。而metaVIPER算法通过ARACNe推断的一个既定蛋白的靶向调控基因（如其转录因子等）的表达数据作为此蛋白活性高低的依据。<strong>一般来说，PISCES可以从单细胞表达数据精确的评估多至6000个以上的蛋白活性，显著提高了针对单个细胞测序中部分不可检测到的mRNA的生物作用及其相关基因产物的分析能力。</strong></section></li></ul><p data-tool="mdnice编辑器">本文参考：</p><ul data-tool="mdnice编辑器"><li><section>基于单细胞测序的蛋白活性推断（PISCES）分析流程笔记，凎！</section></li><li><section><a href="https://mp.weixin.qq.com/s?__biz=MzI5ODI0NzM2OQ==&amp;mid=2247484504&amp;idx=1&amp;sn=2769e0a10970182c5f8611c66bfe06c1&amp;scene=21#wechat_redirect" data-linktype="2">metaVIPER：从单细胞转录组得到单细胞蛋白水平矩阵，你试过吗？（一）</a></section></li></ul><h3 data-tool="mdnice编辑器">Step0. 环境部署</h3><p data-tool="mdnice编辑器">首先在集群上安装ARACNe-AP（基于自适应分区的精确细胞网络重建算法）。</p><p data-tool="mdnice编辑器">但是，安装ARACNe-AP前需要确保ant的安装：</p><pre data-tool="mdnice编辑器"><span></span><code><span>cd</span> ~/software_install/github/ARACNe-AP-master/<br><span>#下载ant</span><br>wget -c https://dlcdn.apache.org//ant/binaries/apache-ant-1.9.16-bin.zip<br><span>#解压</span><br>unzip apache-ant-1.9.16-bin.zip<br><span>#设置全局环境</span><br><span>export</span> ANT_HOME=~/software_install/github/ARACNe-AP-master/apache-ant-1.9.16/<br><span>export</span> PATH=<span>${ANT_HOME}</span>/bin:<span>$PATH</span><br><span>#测试安装是否成功</span><br>$ ant -version <br>Apache Ant(TM) version 1.9.16 compiled on July 10 2021<br></code></pre><p data-tool="mdnice编辑器">然后下载安装ARACNe-AP：</p><pre data-tool="mdnice编辑器"><span></span><code>cd ~/software_install/github/ARACNe-AP-master/<br><span>#下载</span><br>wget -c https://github.com/califano-lab/ARACNe-AP/archive/refs/heads/master.zip<br><span>#解压</span><br>unzip master.zip -d ARACNeAP<br><span>#用ant安装</span><br><span>#The jar will be placed in dist/aracne.jar. The documentation can be found in docs/index.html.</span><br>cd ARACNeAP<br>ant main<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.46550472040668117" data-src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSeWS9TS5KJGvQSClIibUyOfUkFdy7iccHN7DpSM29kJPIoqqU4icHgMLdqw/640?wx_fmt=other" data-type="other" data-w="1377" src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSeWS9TS5KJGvQSClIibUyOfUkFdy7iccHN7DpSM29kJPIoqqU4icHgMLdqw/640?wx_fmt=other"><figcaption>image-20221005131747190</figcaption></figure><p data-tool="mdnice编辑器">安装很快，最后会出现：</p><pre data-tool="mdnice编辑器"><span></span><code>BUILD SUCCESSFUL<br>Total time: 3 seconds<br></code></pre><blockquote data-tool="mdnice编辑器"><p>The jar will be placed in <code>dist/aracne.jar</code>. The documentation can be found in <code>docs/index.html</code>.</p></blockquote><pre data-tool="mdnice编辑器"><span></span><code><span>#测试安装是否成功</span><br>$ java -Xmx5G -jar ./dist/aracne.jar<br>Exception <span>in</span> thread <span>"main"</span> java.lang.NullPointerException<br> at java.io.File.&lt;init&gt;(File.java:279)<br> at aracne.Aracne.main(Unknown Source)<br></code></pre><p data-tool="mdnice编辑器">然后我们用软件自带的测试数据，测试一下是否正常可以使用：</p><p data-tool="mdnice编辑器">自带的测试数据集：</p><pre data-tool="mdnice编辑器"><span></span><code>cat <span>test</span>/matrix.txt | head<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.3186907838070629" data-src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSePWBE220AdB7xo7icT2U5cwMZZhvrkT2BPs0zkG5a3cWtnrSFJkR00YQ/640?wx_fmt=other" data-type="other" data-w="1161" src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSePWBE220AdB7xo7icT2U5cwMZZhvrkT2BPs0zkG5a3cWtnrSFJkR00YQ/640?wx_fmt=other"><figcaption>image-20221005132841734</figcaption></figure><blockquote data-tool="mdnice编辑器"><p>1.ARACNe-AP input所需的文件及格式？</p><ul><li><section><p>Gene expression matrix.</p></section></li><li><section><p>List of regulators (e.g. Transcription Factors)</p></section></li></ul><p>2.运行ARACNe所需的步骤：</p><ul><li><section>首先，运行ARACNe所需的步骤计算互信息的阈值；</section></li><li><section>然后，对输入矩阵的bootstrap运行ARACNe；</section></li><li><section>最后，合并（consolidation），即将bootstrap合并为最终的网络文件</section></li></ul><p>3.运行ARACNe的可选方法：</p><ul><li><section>去除DPI(数据处理不平等)将保留通过互信息阈值的每条边。</section></li><li><section>默认情况下，ARACNe操作于输入矩阵的引导版本。可以关闭此功能。</section></li><li><section>在consolidation步骤中，Bonferroni校正应用于从泊松分布获得的p值，用于根据每个边在不同自助带中的外观确定其重要性。可以关闭这个校正，结果输出网络会稍微大一些。</section></li></ul><p>4.ARACNe-AP输出输出的格式</p><p>除了单独的bootstraps之外，ARACNe-AP的整合步骤将在用户提供的输出文件夹中生成一个名为network.txt的文件。这个文件分四列显示每个重要的interaction:</p><ul><li><section>The regulator.</section></li><li><section>The target.</section></li><li><section>The MI (Mutual Information) of the pair.</section></li><li><section>The pvalue of the pair (assessed during the consolidation step by integrating the bootstraps).</section></li></ul><p>5.软件参数</p><p><code>-e</code> is the expression file</p><p><code>-d</code> is an optional expression file for the targets (meaning you can specify an expression file for tfs, and one for targets, with the same sample names. This is for aracne plus)</p><p><code>-t</code> is the TF list</p><p><code>-o</code> is the output folder</p><p><code>--consolidate</code> is telling java to run aracne in consolidate mode (that is, you point it to a directory with bootstraps, and they will be consolidated)</p><p><code>--calculateThreshold</code> is telling Java to run it in threshold mode</p><p><code>-p</code> is the p-value threshold for the MI to be significant (1E-8 usually)</p><p>--consolidatepvalue is the p-value threshold for the Poisson test of edge significance in multi-bootstrap mode (if omitted, it is set to 0.05</p><p><code>-s</code> is the optional seed, to make the threshold mode and the bootstrap reproducible</p><p><code>--threads</code> is the number of threads (it is used only in standard mode, i.e. bootstrap)</p><p><code>--nodpi</code> tells ARACNE not to run DPI</p><p><code>--nobootstrap</code> tells ARACNE not to do bootstrapping</p><p><code>--nobonferroni</code> removes the Bonferroni correction</p></blockquote><p data-tool="mdnice编辑器">注意：示例基于提供的测试集：test/matrix.txt(基因表达矩阵)和test/tfs.txt(调控列表)。另外，示例3(运行100次引导)是使用“for循环”编写的，它是使用受控种子运行100次引导的有用方法。</p><h4 data-tool="mdnice编辑器">Step1: calculate threshold with a fixed seed</h4><pre data-tool="mdnice编辑器"><span></span><code>java -Xmx5G -jar ./dist/aracne.jar -e <span>test</span>/matrix.txt  -o outputFolder --tfs <span>test</span>/tfs.txt --pvalue 1E-8 --seed 1 \<br>--calculateThreshold<br></code></pre><h4 data-tool="mdnice编辑器">Step2: run ARACNe on a single bootstrap</h4><pre data-tool="mdnice编辑器"><span></span><code>java -Xmx5G -jar ./dist/aracne.jar -e <span>test</span>/matrix.txt  -o outputFolder --tfs <span>test</span>/tfs.txt --pvalue 1E-8 --seed 1<br></code></pre><h4 data-tool="mdnice编辑器">Step 3: run 100 reproducible bootstraps</h4><p data-tool="mdnice编辑器">UNIX loop：</p><pre data-tool="mdnice编辑器"><span></span><code><span>for</span> i <span>in</span> {1..100}<br><span>do</span><br>java -Xmx5G -jar ./dist/aracne.jar -e <span>test</span>/matrix.txt  -o outputFolder --tfs <span>test</span>/tfs.txt --pvalue 1E-8 --seed <span>$i</span><br><span>done</span><br></code></pre><p data-tool="mdnice编辑器">Windows loop：</p><pre data-tool="mdnice编辑器"><span></span><code><span>for</span> /l %i <span>in</span> (1, 1, 100) <span>do</span> java -Xmx5G -jar ./dist/aracne.jar -e <span>test</span>/matrix.txt  -o outputFolder --tfs <span>test</span>/tfs.txt \<br>--pvalue 1E-8 --seed %i<br></code></pre><h4 data-tool="mdnice编辑器">Step 4: consolidate bootstraps in the output folder</h4><pre data-tool="mdnice编辑器"><span></span><code>java -Xmx5G -jar ./dist/aracne.jar -o outputFolder --consolidate<br></code></pre><p data-tool="mdnice编辑器">这个步骤生成了network.txt文件：</p><pre data-tool="mdnice编辑器"><span></span><code>$ cat outputFolder/network.txt | head |less -SN<br> 1 Regulator  Target  MI      pvalue<br>      2 405     153571  0.5149763575053061      1.355405152381195E-5<br>      3 1050    79444   0.2482805373344508      0.0<br>      4 1050    79447   0.39080759239919655     1.4107826018516789E-11<br>      5 865     128061  0.26717974518527854     0.0<br>      6 571     79822   0.2709520399311077      0.0<br>      7 571     79823   0.28829864923176357     0.0034311441071253057<br>      8 1050    79415   0.43269553060687893     0.0<br>      9 867     8086    0.5407596642100952      0.0<br>     10 4299    56946   0.65579383457389        3.1359581065260045E-6<br></code></pre><blockquote data-tool="mdnice编辑器"><p>除了单独的bootstraps之外，ARACNe-AP的整合步骤将在用户提供的输出文件夹中生成一个名为network.txt的文件。这个文件分四列显示每个重要的interaction:</p><ul><li><section>The regulator.</section></li><li><section>The target.</section></li><li><section>The MI (Mutual Information) of the pair.</section></li><li><section>The pvalue of the pair (assessed during the consolidation step by integrating the bootstraps).</section></li></ul></blockquote><blockquote data-tool="mdnice编辑器"><p>以下两个步骤可以不跑：</p></blockquote><h4 data-tool="mdnice编辑器">Example 5: run a single ARACNE with no bootstrap and no DPI</h4><pre data-tool="mdnice编辑器"><span></span><code><span>#java -Xmx5G -jar ./dist/aracne.jar -e test/matrix.txt  -o outputFolder --tfs test/tfs.txt --pvalue 1E-8 --seed 1 \</span><br><span>#--nobootstrap --noDPI</span><br></code></pre><h4 data-tool="mdnice编辑器">Example 6: consolidate bootstraps without Bonferroni correction</h4><pre data-tool="mdnice编辑器"><span></span><code><span>#java -Xmx5G -jar ./dist/aracne.jar -o outputFolder --consolidate --nobonferroni</span><br></code></pre><p data-tool="mdnice编辑器">除了ARACNE安装之后，我们还需要安装一些R包：</p><pre data-tool="mdnice编辑器"><span></span><code><span>## CRAN packages</span><br>install.packages(<span>"BiocManager"</span>, <span>"devtools"</span>,<br>                 <span>"ggplot2"</span>, <span>"ggpubr"</span>, <span>"RColorBrewer"</span>, <span>"pheatmap"</span>,<br>                 <span>"Seurat"</span>, <span>"uwot"</span>, <span>"igraph"</span>)<br><span>## BioConductor packages</span><br>BiocManager::install(<span>"viper"</span>)<br>BiocManager::install(<span>"biomaRt"</span>)<br></code></pre><p data-tool="mdnice编辑器">注意PISCES最新的版本和说明文档不兼容，需要下载上一个版本的包进行安装，见文末的链接：</p><pre data-tool="mdnice编辑器"><span></span><code><span>## GitHub packages</span><br>devtools::install_local(<span>"./PISCES-master.Old.zip"</span>)<br></code></pre><p data-tool="mdnice编辑器">然后开始运行PISCES流程。</p><h3 data-tool="mdnice编辑器">Step1. PISCES流程</h3><pre data-tool="mdnice编辑器"><span></span><code>rm(list = ls())<br><span>library</span>(viper)<br><span>library</span>(Seurat)<br><span>library</span>(ggplot2)<br><span>library</span>(ggpubr)<br><span>library</span>(pheatmap)<br><span>library</span>(RColorBrewer)<br><span>library</span>(MUDAN)<br><span>library</span>(umap)<br><span>library</span>(igraph)<br><span>library</span>(biomaRt)<br><span>library</span>(uwot)<br><span>library</span>(Matrix)<br><span>library</span>(PISCES)<br><span>library</span>(patchwork)<br></code></pre><h4 data-tool="mdnice编辑器">1. 数据加载及预处理</h4><p data-tool="mdnice编辑器">这里和单细胞分析流程一样，从数据加载到单细胞分析的常规流程,包括QC ，标准化，降维聚类，分群等等，我们加载pbmc3k数据快速走一遍流程：</p><pre data-tool="mdnice编辑器"><span></span><code><span>### 1.加载单细胞数据</span><br><span>## load data from 10x</span><br><span># exp.mat &lt;- Read10X(paste('PATH_TO_YOUR_DATA/filtered_feature_bc_matrix/', sep = ''))</span><br></code></pre><pre data-tool="mdnice编辑器"><span></span><code><span>library</span>(SeuratData)<br><span>## load data from 10x</span><br>data(<span>"pbmc3k"</span>)<br>pbm3k.data = pbmc3k<br></code></pre><pre data-tool="mdnice编辑器"><span></span><code><span>###### 走单细胞分析的常规流程 QC 标准化 降维聚类 分群等等</span><br><span>## create SEURAT object and perform QC; change these thesholds based on the quality of your data</span><br><span># pbm3k.data &lt;- CreateSeuratObject(counts = exp.mat, min.cells = 3, min.features = 200)</span><br>mt.features &lt;- grep(<span>"MT-"</span>, rownames(pbmc3k),value = <span>T</span>)<br>pbm3k.data[[<span>"percent.mt"</span>]] &lt;- PercentageFeatureSet(object = pbm3k.data, features = mt.features)<br>pbm3k.data &lt;- SCTransform(pbm3k.data, variable.features.n = <span>5000</span>, vars.to.regress = <span>'percent.mt'</span>)<br><br><span>## cluster to identify cell types if your data is heterogeneous; not necessary for experimentally labeled / sorted data</span><br><span>## the goal is to separate the data into distinct cell types for network generation</span><br><span># Seurat clustering</span><br>pbm3k.data &lt;- RunPCA(pbm3k.data, verbose = <span>FALSE</span>)<br>pbm3k.data &lt;- RunUMAP(pbm3k.data, dims = <span>1</span>:<span>30</span>, verbose = <span>FALSE</span>)<br>pbm3k.data &lt;- FindNeighbors(pbm3k.data, dims = <span>1</span>:<span>30</span>, verbose = <span>FALSE</span>)<br>pbm3k.data &lt;- FindClusters(pbm3k.data, verbose = <span>FALSE</span>)<br></code></pre><h4 data-tool="mdnice编辑器">2. PISCES的聚类流程</h4><pre data-tool="mdnice编辑器"><span></span><code><span>###### PISCES clustering (in gene expression space)</span><br>pbm3k.data &lt;- CorDist (pbm3k.data, pca.feats = <span>10</span>)<br>pbm3k.data &lt;- LouvainResRange(pbm3k.data)<br></code></pre><blockquote data-tool="mdnice编辑器"><p>if your data has fewer than 10K UMIs / cell, we recommend generating metacells the clustering vector can be any of those generated in the previous step; here we use the PISCES clustering.</p></blockquote><p data-tool="mdnice编辑器">官方教程说如果细胞数量很多的话，建议用metacells合并细胞：</p><pre data-tool="mdnice编辑器"><span></span><code>gexp.dist &lt;- pbm3k.data@assays$SCT@misc$dist.mat<br>pisces.metacell.mats &lt;- MetaCells(counts.mat = as.matrix(pbm3k.data@assays$RNA@counts),<br>                                       dist.mat = gexp.dist,<br>                                       clust.vec =  pbm3k.data@assays$SCT@misc$louvain.clust$opt.clust)<br><br><span>#你的PISCES clustering得到了几群细胞，这里你就会得到几个表达矩阵，每个表达矩阵中含有250个细胞样本</span><br><span>#再次读取表达矩阵，这里演示假如我得到了3群细胞的表达矩阵</span><br>dir.create(<span>'Test.Pbmc3k/'</span>)<br><span>for</span> (i <span>in</span> <span>1</span>:length(names(pisces.metacell.mats))) {<br>  saveRDS(pisces.metacell.mats[[i]], <br>          file = paste(<span>'Test.Pbmc3k/Human_'</span>, <br>                       i, <span>'_arac.rds'</span>, sep = <span>''</span>))<br>  <span>library</span>(tibble)<br>  write.table(pisces.metacell.mats[[i]] %&gt;% as.data.frame()%&gt;% rownames_to_column(.,var = <span>"gene"</span>),<br>            file = paste0(<span>'Test.Pbmc3k/Human_'</span>, <br>                         i, <span>'_arac.txt'</span>), sep = <span>'\t'</span>,row.names = <span>F</span>,quote = <span>F</span>)<br>}<br></code></pre><p data-tool="mdnice编辑器">或者用户可以简单地为每个集群保存矩阵，并将它们用于带ARACNe的网络生成；也可以使用整个数据集来生成meta cell或者直接输入到ARACNe，但是这样做运行非常慢。<strong>鉴于目前大家的单细胞基本能达到1w以上，所以还是选择用metacell处理一下吧。</strong></p><p data-tool="mdnice编辑器">然后将保存好的txt格式的文件用于后续ARACNe-network构建：</p><h4 data-tool="mdnice编辑器">3. ARACNe-network构建</h4><p data-tool="mdnice编辑器">参考Step0环境部署，安装好ARACNe之后，四步走运行ARACNe即可。由于上面利用metacell生成了多个csv文件，下面我们用shell批量运行即可：</p><pre data-tool="mdnice编辑器"><span></span><code><span>cd</span> ~/software_install/github/ARACNe-AP-master<br>cat &gt;aracen3.sh<br><span>for</span> id <span>in</span> {1..2}<br><span>do</span><br><span>echo</span> <span>$id</span><br>cpulimit --<span>limit</span>  3000  -- java -Xmx5G -jar dist/aracne.jar -e Test.Pbmc3k/Human_<span>${id}</span>_arac.txt -o ResFolder_<span>${id}</span> --tfs human_hugo/tfs-hugo.txt --pvalue 1E-8 --seed 1 \--calculateThreshold<br><br>cpulimit --<span>limit</span>  3000  -- java -Xmx5G -jar ./dist/aracne.jar -e Test.Pbmc3k/Human_<span>${id}</span>_arac.txt  -o ResFolder_<span>${id}</span> --tfs human_hugo/tfs-hugo.txt --pvalue 1E-8 --seed 1<br><br><span>for</span> i <span>in</span> {1..100} <br><span>do</span> <br>java -Xmx5G -jar dist/aracne.jar -e Test.Pbmc3k/Human_<span>${id}</span>_arac.txt -o ResFolder_<span>${id}</span> --tfs human_hugo/tfs-hugo.txt --pvalue 1E-8 --seed <span>$i</span> <br><span>done</span><br><br>java -Xmx5G -jar dist/aracne.jar -o ResFolder_<span>${id}</span> --consolidate<br><br>cp ResFolder_<span>${id}</span>/network.txt ./network_<span>${id}</span>.txt<br><span>done</span><br></code></pre><p data-tool="mdnice编辑器">运行：</p><pre data-tool="mdnice编辑器"><span></span><code>nohup bash aracen3.sh &amp;<br></code></pre><h4 data-tool="mdnice编辑器">4. 基于蛋白质活性的聚类分析</h4><pre data-tool="mdnice编辑器"><span></span><code><span>#这里演示还是假如我们有2个cluster</span><br>mat1 = read_rds(<span>"./Test.Pbmc3k/Human_1_arac.rds"</span>)<br>n1 = read.table(<span>"./Test.Pbmc3k/network_1.txt"</span>,header = <span>T</span>)<br>write_tsv(n1,<span>"./Test.Pbmc3k/network_1.tsv"</span>,col_names = <span>F</span>)<br>RegProcess(<span>"./Test.Pbmc3k/network_1.tsv"</span>, mat1, out.dir = <span>'Test.Pbmc3k/'</span>, out.name = <span>'pisces_1_net_'</span>)<br><br>mat2 = read_rds(<span>"./Test.Pbmc3k/Human_2_arac.rds"</span>)<br>n2 = read.table(<span>"./Test.Pbmc3k/network_2.txt"</span>,header = <span>T</span>)<br>write_tsv(n2,<span>"./Test.Pbmc3k/network_2.tsv"</span>,col_names = <span>F</span>)<br>RegProcess(<span>"./Test.Pbmc3k/network_2.tsv"</span>, mat1, out.dir = <span>'Test.Pbmc3k/'</span>, out.name = <span>'pisces_2_net_'</span>)<br><br><span>#搞个循环</span><br>file.names = list.files(<span>"./Test.Pbmc3k/"</span>,<span>"_arac.rds"</span>)<br><span>for</span> (i <span>in</span> length(file.names)) {<br>  mat1 = read_rds(paste0(<span>"./Test.Pbmc3k/"</span>,file.names[i]))<br>  n1 = read.table(paste0(<span>"./Test.Pbmc3k/network_"</span>,i,<span>".txt"</span>),header = <span>T</span>)<br>  write_tsv(n1,file = paste0(<span>"./Test.Pbmc3k/network_"</span>,i,<span>".tsv"</span>),col_names = <span>F</span>)<br>  RegProcess(a.file = paste0(<span>"./Test.Pbmc3k/network_"</span>,i,<span>".tsv"</span>), <br>             exp.mat = mat1, out.dir = <span>'Test.Pbmc3k/'</span>, out.name = paste0(<span>'pisces_'</span>,i,<span>'_net_'</span>))<br>}<br><span>#RegProcess()函数生成的文件保存为rds格式，先使用lapply和read_rds()函数读list</span><br>net.list = lapply(<span>1</span>:length(file.names), <span>function</span>(x){<br>  read_rds(paste0(<span>'Test.Pbmc3k/'</span>,<span>'pisces_'</span>,x,<span>'_net_'</span>,<span>'pruned.rds'</span>))<br>})<br></code></pre><pre data-tool="mdnice编辑器"><span></span><code><span>## viper and protein-activity based clustering</span><br><span>## net.list here would be a list of networks generated from ARACNe</span><br>data.obj = CreateSeuratObject(counts = pbm3k.data@assays$RNA@counts,<br>                               meta.data = pbm3k.data@meta.data)<br><span>#将Seurat对象里的count矩阵拿出来命名为PISCES，然后放回到Seurat对象里去，并设置为当前默认的active.assay</span><br>data.obj &lt;- AddPISCESAssay(data.obj)<br><span>#针对PISCESassay进行CPMTransform()、GESTransform()标准化。</span><br>data.obj &lt;- CPMTransform(data.obj)<br>data.obj &lt;- GESTransform(data.obj)<br><br><span>#蛋白活性推断，数据存在scale.data</span><br>data.obj &lt;- PISCESViper(data.obj, net.list)<br><br><span>#根据蛋白活性矩阵计算细胞间距离</span><br>data.obj &lt;- CorDist(data.obj) <br></code></pre><pre data-tool="mdnice编辑器"><span></span><code><span># 降维</span><br>MakeUMAP &lt;- <span>function</span>(dat.object, cbc = <span>FALSE</span>, num.feats = <span>10</span>) {<br>  <span># extract viper matrix</span><br>  dat.mat &lt;- dat.object@assays[[dat.object@active.assay]]@scale.data<br>  <span># adjust data if cbc is specified</span><br>  <span>if</span> (cbc) {<br>    cbc.feats &lt;- apply(dat.mat, <span>2</span>, <span>function</span>(x) { names(sort(x, decreasing = <span>TRUE</span>))[<span>1</span>:num.feats] })<br>    cbc.feats &lt;- unique(unlist(as.list(cbc.feats)))<br>    dat.mat &lt;- dat.mat[match(cbc.feats, rownames(dat.mat)) ,]<br>  }<br>  <span># make umap</span><br>  umap.mat &lt;- uwot::umap(t(dat.mat), metric = <span>'correlation'</span>)<br>  rownames(umap.mat) &lt;- colnames(dat.mat)<br>  <span># add umap to object</span><br>  dat.object@assays[[dat.object@active.assay]]@misc[[<span>'umap'</span>]] &lt;- umap.mat<br>  <span>return</span>(dat.object)<br>}<br>make_mds &lt;- <span>function</span>(dist.mat) {<br>  mds.mat &lt;- cmdscale(dist.mat, k = <span>2</span>)<br>  <span>return</span>(mds.mat)<br>}<br>data.obj &lt;- MakeUMAP(data.obj)<br><br>dist.mat &lt;- data.obj@assays$PISCES@misc$dist.mat<br>dist.mat &lt;- make_mds(dist.mat)<br>data.obj@assays$PISCES@misc$mds = dist.mat<br><br><span># clustering and MR analysis</span><br>data.obj &lt;- LouvainResRange(data.obj)<br><span>#找每个分群的master regulator</span><br>data.obj &lt;- MWUMrs(data.obj)<br><span>## the master regulators will be added under data.obj@assays$PISCES@misc$mwuMRs</span><br><span>## the object is a list of lists; a pair of lists for each cluster, one for positive MRS and the other for negative, sorted by log p-value</span><br><br><span>## scatter plots using ggplot</span><br><span>## generate plots</span><br>plot.df &lt;- data.frame(<span>'MDS1'</span> = data.obj@assays$PISCES@misc$mds[,<span>1</span>],<br>                      <span>'MDS2'</span> = data.obj@assays$PISCES@misc$mds[,<span>2</span>],<br>                      <span>'UMAP1'</span> = data.obj@assays$PISCES@misc$umap[,<span>1</span>],<br>                      <span>'UMAP2'</span> = data.obj@assays$PISCES@misc$umap[,<span>2</span>],<br>                      <span>'Cluster'</span> = as.factor(data.obj@assays$PISCES@misc$pisces.cluster),<br>                      <span>"celltype"</span>=pbm3k.data$seurat_annotations)<br><span># umap plot</span><br>umap.plot1 &lt;- ggplot(plot.df, aes(UMAP1, UMAP2)) + geom_point(aes(color = Cluster)) +<br>  ggtitle(paste(<span>"Human"</span>, <span>' (UMAP)'</span>, sep = <span>''</span>))<br><br>umap.plot2 &lt;- ggplot(plot.df, aes(UMAP1, UMAP2)) + geom_point(aes(color = celltype)) +<br>  ggtitle(paste(<span>"Human"</span>, <span>' (UMAP)'</span>, sep = <span>''</span>))<br>umap.plot1 + umap.plot2<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.436222005842259" data-src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSeiaQOmnujLZ5FOziczMqNW5LM3dqe5vXLGAzMPFFicx8tlib1wVLEAicgs4g/640?wx_fmt=other" data-type="other" data-w="1027" src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSeiaQOmnujLZ5FOziczMqNW5LM3dqe5vXLGAzMPFFicx8tlib1wVLEAicgs4g/640?wx_fmt=other"><figcaption>image-20221006141500075</figcaption></figure><pre data-tool="mdnice编辑器"><span></span><code><span># mds plot</span><br>mds.plot1 &lt;- ggplot(plot.df, aes(MDS1, MDS2)) + geom_point(aes(color = Cluster)) +<br>  ggtitle(paste(<span>"Human"</span>, <span>' (MDS)'</span>, sep = <span>''</span>))<br><br>mds.plot2 &lt;- ggplot(plot.df, aes(MDS1, MDS2)) + geom_point(aes(color = celltype)) +<br>  ggtitle(paste(<span>"Human"</span>, <span>' (MDS)'</span>, sep = <span>''</span>))<br>mds.plot1 + mds.plot2<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.43613707165109034" data-src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSeic0bIwsmdJ2jUd7KvjegrUibqZicyPTzK4zAkibmUrWo56fwN8bPUiaFtKg/640?wx_fmt=other" data-type="other" data-w="1284" src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSeic0bIwsmdJ2jUd7KvjegrUibqZicyPTzK4zAkibmUrWo56fwN8bPUiaFtKg/640?wx_fmt=other"><figcaption>image-20221006141441690</figcaption></figure><p data-tool="mdnice编辑器">蛋白活性推测的数据储存在scale.data插槽</p><pre data-tool="mdnice编辑器"><span></span><code>length(row.names(data.obj@assays$PISCES@scale.data)) <span>#只有482个蛋白</span><br></code></pre><p data-tool="mdnice编辑器">蛋白活性表达量：</p><pre data-tool="mdnice编辑器"><span></span><code>p1 = VlnPlot(data.obj,features = <span>"XBP1"</span>,<br>             group.by = <span>"seurat_annotations"</span>,<br>             assay = <span>"PISCES"</span>,<br>             slot = <span>"scale.data"</span>) + ggtitle(<span>"Protein"</span>)<br>p2 = VlnPlot(data.obj,features = <span>"XBP1"</span>,<br>               group.by = <span>"seurat_annotations"</span>,<br>               assay = <span>"RNA"</span>)+ ggtitle(<span>"mRNA"</span>)<br>wrap_plots(p1,p2,guides = <span>"collect"</span>)<br></code></pre><figure data-tool="mdnice编辑器"><img data-ratio="0.4375" data-src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSeZAnWicHw71BqCuiaQBgN1B9RXPkyQG0jYGXJodnQf8ouRWGtrh8WxdDw/640?wx_fmt=other" data-type="other" data-w="1024" src="https://mmbiz.qpic.cn/mmbiz/fTW9zRI3eqWaMww2hFsnpVia3UZqLPLSeZAnWicHw71BqCuiaQBgN1B9RXPkyQG0jYGXJodnQf8ouRWGtrh8WxdDw/640?wx_fmt=other"><figcaption>image-20221006143622979</figcaption></figure><p data-tool="mdnice编辑器">保存一下重要的数据：</p><pre data-tool="mdnice编辑器"><span></span><code>save(data.obj,pbm3k.data,<br>     file = <span>"./Test.Pbmc3k/Pisces.All.Rdata"</span>)<br></code></pre><p data-tool="mdnice编辑器">注意https://github.com/califano-lab/PISCES目前更新了最新的流程，但是他的说明文档居然没更新，这样导致了说明文档里的大量函数与github上的包不兼容。所以我们要安装PISCES的上一个版本。</p><p data-tool="mdnice编辑器">我已经把本教程所有的安装包及示例数据，以及输出结果放到了网盘，后台回复：</p><p><mp-pay-preview-filter></mp-pay-preview-filter></p></section></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/aLTIQrmr4GOd7ziEYtHG4A",target="_blank" rel="noopener noreferrer">原文链接</a>
